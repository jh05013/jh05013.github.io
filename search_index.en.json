[{"url":"https://jh05013.github.io/","title":"Home","description":null,"body":"Hello, world!\n","path":null},{"url":"https://jh05013.github.io/about/","title":"About","description":null,"body":"Programming\nGeneral\nSee the list of related stuff I use.\nAlgorithms\nI solve algorithmic problems.\njh05013 on BOJ,\nsolved.ac, and\nProject Euler.\n\nRust snippets, feel free to use.\nI also used to make problems. Here are some of mine that I find interesting:\n\nDev, Please Add This!\n회문은 회문아니야!!\n성공\nEconomic One-way Roads\n교집합 만들기\n모자 퍼즐\n\nGaming\nI play games.\n\njh05013 on Steam.\n\nI’ve also played on Steam Deck since early 2024.\n\n\njh05013 on Flash Flash Revolution.\n\nI also make charts.\nI’m also a staff.\n\n\n\nTop 10 Games\n(Roughly in order)\n\nThe Stanley Parable: Ultra Deluxe Interactive story\nBraid Puzzle platformer\nReturn of the Obra Dinn Mystery\nPortal 2 Puzzle platformer\nBaba Is You Puzzle\nChants of Sennaar Puzzle\nTUNIC Adventure\nPhoenix Wright: Ace Attorney Trilogy Mystery, visual novel\nUndertale Adventure\nCrypt of the NecroDancer Rhythm Roguelike\n\nHonorable mentions (no particular order):\nWe Love Katamari, Portal, VVVVVV, OneShot, Hypnospace Outlaw,\nThe Witness, Cuphead, Gorogoa, What Remains of Edith Finch, Superliminal,\nThe Talos Principle 2\n(Yes, I like puzzle games)\n","path":null},{"url":"https://jh05013.github.io/about/uses/","title":"Uses","description":null,"body":"Software\n\nOS: Linux Mint\nTerminal: Nushell\nBrowser: Firefox\n\nuBlock Origin\nDeArrow\n\n\nText Editor &amp; Notes\n\nGeany for text editing\nObsidian for notes\n\n\n\nProgramming\n\nLanguages\n\nRust\nTypst for math typesetting\nCoq &amp; Lean (still learning) for formal verification\n\n\nIDE: Visual Studio Code\nGitHub\n\n","path":null},{"url":"https://jh05013.github.io/blog/","title":"Blog","description":null,"body":"Hello, world?!\n","path":null},{"url":"https://jh05013.github.io/blog/recursion/","title":"재귀의 본질","description":null,"body":"\n\t\n\t\tNote\n\t재귀를 처음 배우신다면 맨 아래에 첨부한 링크를 같이 참조하는 것이 좋습니다.\n\n\n\n재귀를 배웁니다. 재귀 함수는 자기 자신을 호출하는 함수입니다. 좋습니다.\n재귀로 팩토리얼을 구현합니다. 잘 돌아갑니다. factorial(5)는 factorial(4)를 부르고, 이건 다시 factorial(3)을 부르고… factorial(0)을 부르고, 이건 1을 반환하고, factorial(1)이 여기에 1을 곱해서 1을 반환하고… factorial(5)가 여기에 5를 곱해서 120을 반환합니다. 그럴싸합니다.\n재귀로 피보나치를 구현합니다. 잘 돌아갑니다. 강좌에 두 갈래로 마구 뻗는 함수 호출 과정이 그림으로 등장합니다. 구체적으로 뭐가 어떤 순서로 호출되는 건지는 안 나와있지만 넘어갑니다.\n문제는 하노이 탑입니다. 풀이가 있지만 이게 왜 동작하는지, 이걸 어떻게 생각해 내는 건지는 알 수 없습니다. 원판 n-1개를 1에서 2로 옮긴다고 했지만 함수 호출이 어떻게 일어나서 그렇게 되는지 추적할 수 없습니다. 원판을 일곱 번 옮기는 그림이 있지만 도움이 되지 않습니다. 며칠째 호출 과정을 추적하다가 결국 포기하고 풀이를 암기하기로 합니다.\n제 경험이 그랬다는 건 아니지만, 위와 같은 일을 겪는 사례를 심심찮게 찾아볼 수 있습니다.\n재귀가 원래 이렇게 이상한 존재일까요? 그렇지 않습니다. 재귀의 본질은 이 복잡한 호출 과정을 따라가는 데서 나오지 않습니다. 오히려 따라가지 않는 데서 나옵니다.\n재귀를 푸는 방법\n재귀로 문제를 푸는 규칙은 이렇습니다.\n\n입력 크기가 가장 작을 때 (0, 1 등) 문제를 풉니다.\n입력 크기가 N보다 작을 때 문제를 풀 수 있다고 가정합니다. 구체적으로 어떻게 풀었는지는 생각하지 않습니다.\n이제 입력 크기가 N일 때 문제를 풉니다.\n\n재귀의 장벽을 깨뜨리는 첫걸음은 2번입니다. “구체적으로 어떻게 풀었는지는 생각하지 않습니다.”\n사실 생각해 보면 프로그램의 동작 과정을 바닥까지 다 따라갈 필요가 없습니다. 예를 들어 print (printf, cout, …)도 내부적으로 뭔가를 호출할 텐데, 우리는 print를 처음 배울 때 내부를 굳이 뜯어보지 않습니다. print가 뭔가를 출력하는 함수라고 믿고 그냥 씁니다. 재귀도 마찬가지입니다. 단지 내부가 자기 자신이 될 뿐입니다.\n팩토리얼\n위 규칙으로 팩토리얼을 풀어봅시다. 먼저 N == 0이라면 1을 반환합니다.\n이제 입력 크기가 N보다 작을 때 문제를 풀 수 있다고 가정합니다. 즉 factorial(N-1)은 $(N-1)!$을 반환합니다. 구체적으로 factorial(N-1)이 어떻게 동작하는지는 생각하지 않습니다.\n이제 $N! = (N-1)! \\times N$이고 $(N-1)!$은 factorial(N-1)이니까, factorial(N-1) * N을 반환하면 됩니다.\n이를 재귀로 구현했을 때 왜 제대로 동작하는지를 이해하려면, 마찬가지로 입력 크기가 N보다 작을 때 제대로 동작한다고 가정합니다. 이번에도 구체적으로 왜 그런지는 생각하지 않습니다. factorial(5)를 계산하려고 한번에 다섯 단계까지 깊이 들어갈 필요가 없습니다. factorial(4) = 4!임을 이미 아는 상태라고 가정하고 거기서 바로 끝내면 됩니다. 이걸 일일이 풀어 계산하는 건 컴퓨터의 몫입니다.\n하노이 탑\n우선 하노이 탑을 풀이할 때 “재귀를 사용해 보자“가 먼저 나오면 안 됩니다. 문제에 대해 아직 아무것도 알아낸 게 없는 상태에서는 재귀를 떠올릴 수 없습니다.\n하노이 탑을 손으로 풀려고 시도해 보면, 원판이 클수록 그 위에 있을 수 있는 다른 원판이 많아지기 때문에 옮기기 어렵다는 것을 알 수 있습니다. 특히 맨 밑에 있는 N번째 원판은 매우 제한적인 상황에서만 옮길 수 있습니다. 그럼에도 N번째 원판을 어떻게든 기둥 1에서 3으로 옮겨야 합니다.\nN번째 원판을 기둥 1에서 3으로 옮길 수 있는 상황은 어떤 상황일까요?\n\n  해답\n  (1) N번째 원판 위에 있는 다른 모든 원판을 어떻게든 치워야 하고, (2) 기둥 3에 아무 원판도 있지 않아야 합니다.\n그런 상황은 하나 밖에 없습니다. 기둥 1에 N번째 원판 하나, 기둥 2에 다른 모든 원판이 있고, 기둥 3은 비어있을 때입니다.\n\n그래서 맨 처음 해야 되는 일은…\n\n  해답\n  어떻게든 \"다른 모든 원판\"을 전부 기둥 1에서 2로 옮기는 것입니다.\n그런데 이건 하노이 탑 문제와 동일합니다. 원판이 하나 줄었고 도착지가 바뀌었을 뿐입니다.\n\n그러면 그 문제는 어떻게 풀어야 할까요?\n\n  해답\n  같은 문제가 다시 등장했으니 재귀를 사용합니다.\n재귀의 규칙에 따라, 원판 N-1개를 다 옮길 수 있다고 가정하고 구체적으로 어떻게 옮기는지는 생각하지 않습니다. 도착점 이슈는 번호를 다시 붙이면 같은 문제가 되기 때문에 걱정할 필요가 없습니다. 그렇게 가정하고… 가정에 따라 그냥 옮기면 됩니다.\n\n나머지 과정은 비슷합니다. N번째 원판을 1에서 3으로 옮기고, 2에 있었던 “다른 모든 원판“을 전부 3으로 옮깁니다. 이번에도 구체적으로 어떻게 옮기는지는 생각하지 않습니다.\n이를 정리하면,\n\n재귀적으로 원판 N-1개짜리 하노이 탑을 풀어서 1에서 2로 옮긴다.\nN번째 원판을 1에서 3으로 옮긴다.\n재귀적으로 원판 N-1개짜리 하노이 탑을 풀어서 2에서 3으로 옮긴다.\n\n가 됩니다. 이제 위 과정을 그대로 코드로 옮기면 끝입니다. (물론 원판이 1개일 때는 따로 처리합시다.) 재귀의 규칙을 잘 따랐기 때문에 올바르게 동작합니다.\n그래도 조금 의심된다면 풀이를 검토해 봅시다.\n\n1번 과정이 끝나면 원판 1부터 N-1까지가 기둥 1에서 2로 옮겨집니다. 재귀의 규칙에 따라, 그게 왜 되는지는 생각하지 않습니다. 그냥 됩니다.\n그 상태에서는 N번째 원판을 1에서 3으로 옮길 수 있습니다.\n3번 과정이 끝나면 원판 1부터 N-1까지가 기둥 2에서 3으로 옮겨집니다. 이번에도 그게 왜 되는지는 생각하지 않습니다.\n\n이게 진짜 돼요?\n얼핏 보면 뭔가 사기인 것 같지만, 이 논리가 통하는 이유는 다음과 같습니다.\n\nfactorial(0) = 1입니다. 재귀 함수에서 이 경우를 따로 처리했을 것입니다.\nfactorial(1) = 1 * factorial(0)입니다. 바로 위에서 factorial(0) = 1임을 이미 파악했습니다. 따라서 factorial(1) = 1 * 1 = 1입니다.\nfactorial(2) = 2 * factorial(1)입니다. 바로 위에서 factorial(1) = 1임을 이미 파악했습니다. 따라서 factorial(2) = 2 * 1 = 2입니다.\nfactorial(3) = 3 * factorial(2)입니다. 바로 위에서 factorial(2) = 2임을 이미 파악했습니다. 따라서 factorial(3) = 3 * 2 = 6입니다.\n…\nfactorial(N) = N * factorial(N-1)입니다. 바로 위에서 factorial(N-1) = (N-1)!임을 이미 파악했습니다. 따라서 factorial(N) = N * (N-1)! = N!입니다.\n\n하노이 탑도 마찬가지입니다.\n\n원판이 1개일 때 잘 됩니다.\n원판이 1개일 때 잘 된다고 가정하면, 재귀의 규칙에 따라 원판이 2개일 때도 잘 됩니다. 원판이 1개일 때 잘 된다는 것을 바로 위에서 파악했습니다. 따라서 원판이 2개일 때도 잘 됩니다.\n원판이 2개일 때 잘 된다고 가정하면, 재귀의 규칙에 따라 원판이 3개일 때도 잘 됩니다. 원판이 2개일 때 잘 된다는 것을 바로 위에서 파악했습니다. 따라서 원판이 3개일 때도 잘 됩니다.\n…\n\n수학적 배경이 있으시다면 사실 이게 수학적 귀납법과 같은 이치임을 눈치채셨을 수도 있겠습니다. 이것이 바로 재귀의 본질입니다.\n\n  수학적 귀납법이란?\n  자연수 $N$에 대한 명제 $P$를 증명할 때 다음 두 사실을 증명하는 테크닉을 수학적 귀납법이라고 합니다.\n(1) $P(0)$은 참이다. 0도 자연수라고 합시다.\n(2) 모든 자연수 $k$에 대해, $P(k)$가 참이라면 $P(k+1)$도 참이다.\n그러면 $P(0)$이 참이고, $P(0)$이 참이니까 $P(1)$이 참이고, 그래서 $P(2)$도 참이고, … 어떤 $N$을 보더라도 $P(N)$이 참이기 때문에, 명제 $P$는 참입니다.\n\n이처럼 재귀의 규칙을 수학이 정당화해 주기 때문에, 우리는 재귀의 규칙을 따르는 것에만 신경 쓰면 됩니다. 심지어 저 “$P(1)$이 참이고 그래서 $P(2)$가 참이고…“에도 신경 쓸 필요가 없습니다. 컴퓨터와 수학이 알아서 처리해 줄 것입니다.\n비슷한 글\n\nBaaaaaaaarkingDog, 실전 알고리즘 0x0B강 - 재귀\nEddy, 야, 너두 재귀할 수 있어: 재귀가 풀리는 4단계 접근법\ndjm03178, 재귀 함수에 대한 이해\n\n","path":null},{"url":"https://jh05013.github.io/blog/ufo50-porgy/","title":"Porgy My Beloved","description":null,"body":"\nI heard of this UFO 50 thing\nwhile participating in Galactic Puzzle Hunt 2024.\nThe idea of 50 fully-fleshed games was something I could not ignore -\nit’s too good to be true! So December last year, I went ahead and grabbed it.\nMy first pick was Porgy because the fish looked cute.\nIt also ended up being my first gold and cherry, before golding anything else.\nI’ll just say, I loved every moment of the 7 hours I spent on this game!\nAnd I’m not even a fan of Metroid-vania. Porgy just clicked well despite that.\nGranted, I did look up the map on the internet for a tiny bit.\n\n\t\n\t\tTip\n\tThe Porgy experience gets tremendously better once you realize:\n\nYour fuel bar is not a timer. It’s actually an odometer.\nYou don’t use fuel by staying in place. Feel free to take it slow!\nYou don’t use fuel by firing torpedo either. Spam torpedo.\nYou can hold B to keep firing torpedo, and lock your direction\n(e.g. move left while shooting to the right).\nWhen you return to the base without dying, you save your progress;\nthis includes upgrades, destroyed 2x2 big rocks, and damage dealt to bosses.\nSeriously, 2nd layer bosses are pretty much impossible without realizing this.\n\n\n\nA common complaint with Porgy seems to be that there are too few equipment slots,\nbut I think it was fine?\nI saw a main challenge of this game as establishing and mastering your\nexploration strategies under various limitations.\nEquipment choice especially was a fun puzzle and I think\nit made the gameplay a bit more interesting for me, in spite of\nhaving to run back and forth a lot.\nI mentally named a few of those sets as “Observer Porgy”, “Excavator Porgy”,\n“Combatant Porgy”, “Treasure Hunter Porgy”, and so on.\nMy only wish is that the buster upgrade could have been permanent\nbecause it’s almost always necessary.\nAll in all, the first experience with UFO 50 was a delight\nand I can’t wait for the other 49 games.\n","path":null},{"url":"https://jh05013.github.io/blog/first/","title":"Test test test","description":null,"body":"Zola 라는 블로그 도구를 써보고 있습니다.\n✨\n\nThis quote contains:\n\nbold italic strikethrough\nItems\n\nSub-items\n\n\nItems\n\nCheckboxes\n\nNo, you can’t click on them\n\nAlso:\n\nnumbered item\nok!\n\n\nlink\nFootnote1 was here. Proof: let $\\epsilon &lt; 0$, then\n$$\n\\int_0^1 x dx = \\infty\n$$\nContradiction QED\n\n\t\n\t\tCaution\n\tThe proof above has\nan error.\nOr does it?\nCan you find it?\n\n  Answer\n  Yes, you can find it.\n\n\nABC\nH1\nH2\nH3\nH4\nH5\nH6\ncode\n\n\nzxc\nasdsdfdfg\nasdsdfdfg\n\nMedia\n\n\n\n\n\nasdf\n\nLorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum\nLorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum\nLorem ipsum Lorem ipsum Lorem ipsvm Lorem ipsum Lorem ipsum\nLorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum\nLorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum\nLorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum\nLorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum\n\n  Go to Top\n  Example\n\nForms\n\n  \n    \n    &nbsp;Ok you *can* click on these\n  \n  \n    \n    &nbsp;Here I clicked them for u\n  \n  \n    \n    &nbsp;Except this one\n  \n  \n    \n    &nbsp;??\n  \n\n\n  \n    \n    &nbsp;Milk\n  \n  \n    \n    &nbsp;Eggs\n  \n  \n    \n    &nbsp;Flour\n  \n  \n    \n    &nbsp;Coffee\n  \n  \n    \n    &nbsp;Combustible lemons\n  \n\nColor:\n\n\n\n\n\nfootnote, yes. ↩\n\n\n\n","path":null},{"url":"https://jh05013.github.io/blog/koi2018-source/","title":"우연히 2018 정올 예선 문제들의 출처를 찾아버렸습니다.","description":null,"body":"헨리 듀드니(Henry Dudeney)는\n샘 로이드, 마틴 가드너 등과 함께 19-20세기의 수학 퍼즐 시대를 풍미하던 수학자였습니다.\n그의 활동기로부터 100년 가량 지난 때에 열린\n2018년 정보올림피아드 예선은 검수를 했는지 의심될 정도로 수많은 문제점이 터져 나온 대회였습니다.\n말하면 끝도 없지만, 이 글의 초점은 아닙니다.\n이 대회를 7년이 지난 지금 다시 이야기하고 있는 이유는, 수학 퍼즐을 수집하다가 2018 정올 예선의\n일부가 헨리 듀드니의 퍼즐을 그대로 가져온 것이라는 사실을 우연히 알게 되었기 때문입니다…\n1\n\n동네의 어려운 아이들에게 매주 조금씩 용돈을 나눠주는 것을 즐기는 마음씨 좋은 할아버지가 있었다. 하루는 이 할아버지가 다음 주에 네 명이 더 오게 된다면 용돈을 천원씩 덜 줄 수 밖에 없겠구나 라고 얘기했다. 그랬더니 다음 주에는 더 어려운 친구들에게 용돈을 주라며 그 지난주 보다 다섯 명이 덜 오게 되었다. 그래서 모인 아이들은 이천원씩을 더 받아가게 되었다. 한 명이 받아간 돈은? 단, 할아버지가 매주 아이들에게 나누어 주는 용돈의 총합은 같다.\n\n이 문제는 헨리 듀드니의 Generous Gifts 문제입니다.\n\nA generous man set aside a certain sum of money for equal distribution weekly to the needy of his acquaintance. One day he remarked: “If there are five fewer applicants next week, you will each receive 2 shillings more.” Unfortunately, instead of there being fewer there were actually four more persons applying for the gift. “This means,” he pointed out, “that you will each receive one shilling less.” Now, how much did each person receive at that last distribution?\n\n5명 덜 오는 것과 4명 더 오는 것이 뒤바뀐 점만 제외하면 동일한 문제입니다.\n안타깝게도 번역에 몇 가지 문제점이 있었는데요…\n\n가장 치명적인 오류로, “equal distribution“은 각 아이한테 똑같이 나눠준다는 뜻인데\n매주 나눠주는 총합이 같다는 것으로 오역해서 정답이 없는 문제가 되었습니다.\n그런데 “총합“이 어디서 온 걸까요? 바로 “sum of money“입니다.\n하지만 이건 돈의 총합이라는 뜻이 아니라 그냥 액수를 의미합니다.\nSum이라고 다 합을 뜻하는 게 아니에요…\n큰따옴표가 사라져서 끔찍한 비문이 되었습니다. 할아버지가 네 명이 더 온다고요?\n\n2\n\n한 농부가 시장에 가서 백마리의 동물을 구매하는데 총 일천만원이 들었다. 송아지 한마리에 오십만원, 새끼양 한마리에 일십만원, 그리고 토끼는 한마리에 오천원이 들었다면, 농부가 구매한 토끼는 몇 마리인가?\n\n헨리 듀드니의 Market Transactions 문제입니다.\n\nA farmer goes to market and buys 100 animals at a total cost of £100. The price of cows being £5 each, sheep £1 each, and rabbits 1s. each, how many of each kind does he buy? Most people will solve this, if they succeed at all, by more or less laborious trial, but there are several direct ways of getting the solution.\n\n풀이에서 각 동물을 한 마리는 샀다는 걸 가정하는데 왜인지는 잘 모르겠습니다.\n원래는 심심풀이 퍼즐로 낸 문제라서 어느 정도의 모호성은 이해가 되지만,\n대회 문제로 그대로 옮기진 말았어야 할 것 같습니다.\n3\n\n어떤 사람이 바람 방향으로 자전거를 타고 1 km를 가는데 3분이 걸렸다. 바람의 세기가 동일한 상태에서 돌아오는 길은 4분이 걸렸다면, 바람이 불지 않을 때는 1 km를 가는데 얼마나 걸릴까? 단, 자전거 페달을 밟는 힘은 항상 일정하다.\n\n이것도 헨리 듀드니의 Riding in the Wind 문제입니다.\n\nA man on a bicycle rode a mile in 3 minutes with the wind at his back, but it took him 4 minutes to return against the wind. How long would it take him to ride a mile if there was no wind?\n\n문제를 푸는 데 필요한 기본적인 가정이 다 빠져있는 이유는 바로\n원본이 심심풀이 퍼즐로 낸 문제였기 때문이 아니었을까요?\n아무튼 이것도 대회 문제로 그대로 옮기진 말았어야 할 것 같습니다.\n","path":null},{"url":"https://jh05013.github.io/blog/big-o/","title":"빅-O, 빅-Ω, 빅-Ө는 최악, 최선, 평균을 의미하지 않습니다.","description":null,"body":"이 글은 BOJ 블로그에 있는 글과 동일합니다.\n알고리즘 공부를 시작할 때 맨 처음 만나는 개념 중 시간, 공간 복잡도가 있습니다.\n안타깝게도, 이는 오개념이 가장 많이 퍼진 주제이기도 합니다.\n여러 오개념이 있지만 이 글에서는…\n\n“빅-Ω 표기법은 최선의 경우를 다룰 때 사용한다. 빅-Ө 표기법은 평균의 경우를 다룰 때 사용한다. 빅-O 표기법은 최악의 경우를 다룰 때 사용한다.”\n\n…라는 오개념을 다룹니다. 이 주장은 각종 블로그 글은 물론, 이름 있는 출처에도 가끔씩 나오며\n심지어 책으로도 나왔습니다.\n잘못된 말입니다. 빅-O, 빅-Ω, 빅-Ө 표기법은 그 자체로 최선, 최악 등의 경우를 가정하지 않으며,\n세 표기법 모두를 최선, 최악, 평균의 경우에 모두 사용할 수 있습니다.\n단지 최악의 경우 및 빅-O 표기법을 가장 많이 쓸 뿐입니다.\n올바른 용례\n“길이가 n인 정수 리스트 L에 정수 target이 있는지 판별하세요“라는 문제를\n다음과 같은 의사코드로 풀었다고 해봅시다.\n\n최악의 경우는 L에 target이 없어서 L 전부를 훑어볼 때이고,\n최선의 경우는 맨 첫 수가 target과 같을 때입니다. 따라서\n\n이 알고리즘의 최선의 경우 시간 복잡도는 O(1)이자, Ω(1)이자, Ө(1)입니다.\n이 알고리즘의 최악의 경우 시간 복잡도는 O(n)이자, Ω(n)이자, Ө(n)입니다.\n평균 시간 복잡도는 정의하기 조금 어렵지만, 직관적으로 생각할 수 있는 평균의 기준을 따른다면 시간 복잡도는 O(n)이자, Ω(n)이자, Ө(n)일 것입니다.\n\n시간 복잡도가 O(f(n))이라는 것은 수행 시간이 최대 f(n)만큼 커진다는 뜻입니다.\n그것뿐입니다. 정확히 무슨 수행 시간인지는 맥락에 따라 다릅니다.\n상한은 최악을 의미하지 않습니다\n“빅-O 표기법은 수행 시간의 상한을 표현한다“는 맞는 말입니다.\n최악의 경우에서 빅-O 표기법을 쓰면 최악의 수행 시간의 상한이 되고,\n최선의 경우에서 빅-O 표기법을 쓰면 최선의 수행 시간의 상한이 됩니다.\n딱 보면 뭔가 말이 안 되는 것 같은데요.\n쉬운 이해를 위해, 알고리즘 중간고사를 봤다고 생각해 봅시다.\n시험이 막 끝나서 정확한 점수는 모르지만, 어느 정도 예상은 할 수 있습니다.\n최악의 경우(실수를 꽤 했을 때)와 최선의 경우(시도한 문제들의 풀이가 완벽할 때)\n얼마나 받을지 예상을 해봅니다.\n이제 친구가 여러분에게 물어봅니다. “몇 점 받을 것 같아?”\n\n“못 봐도 80점은 나오지 않을까?“라고 답한다면,\n“못 봐도“는 최악의 경우, “80점“은 예상 점수의 하한입니다.\n아무리 실수를 많이 해서 마구 틀리더라도 적어도 80점은 될 것 같다는 뜻입니다.\n“잘 보면 90점도 나올 것 같아!“라고 답한다면,\n“잘 보면“은 최선의 경우, “90점“은 예상 점수의 하한입니다.\n정말 잘 봐서 시도한 모든 풀이가 완벽하면 적어도 90점은 될 것 같다는 뜻입니다.\n“못 보면 70점 밑으로도 갈 것 같아…“라고 답한다면,\n“못 보면“은 최악의 경우, “70점“은 예상 점수의 상한입니다.\n“잘 봐도 60점 안 될 거야……“라고 답한다면,\n“잘 봐도“는 최선의 경우, “60점“은 예상 점수의 상한입니다.\n괜찮습니다. 기말고사를 잘 보면 되죠.\n\n이처럼 최선과 최악의 케이스에서 모두 예상 점수의 하한과 상한을 논할 수 있습니다.\n중요한 것은 하한, 상한이 그 자체로 최선, 최악을 의미하는 것이 아니라,\n단순히 특정 시나리오에서 예상 점수의 범위를 표현할 때 쓰인다는 것입니다.\n알고리즘도 마찬가지입니다. 최선과 최악의 케이스에서 모두 수행 시간의 하한과 상한을 논할 수 있습니다.\n하한, 상한은 단순히 특정 시나리오에서 수행 시간의 범위를 표현합니다. 그래서,\n\n“최악의 시간 복잡도가 O(n)“이라는 것은, 최악의 경우에 정확한 연산 횟수는 세보지 않았지만\n그래도 선형 시간 안에는 돈다는 뜻입니다. 이때 n은 최악의 경우에 대한 상한입니다.\n“최선의 시간 복잡도가 O(n)“이라는 것은, 최선의 경우에 정확한 연산 횟수는 세보지 않았지만\n그래도 선형 시간 안에는 돈다는 뜻입니다. 이때 n은 최선의 경우에 대한 상한입니다.\n“최악의 시간 복잡도가 Ω(n)“이라는 것은, 최악의 …중략…\n그래도 선형 시간보다 빠르지는 않다는 뜻입니다.\n“최악의 시간 복잡도가 Ө(n)“이라는 것은, 최악의 …중략…\n그래도 딱 선형 시간이 걸린다는 뜻입니다.\n\n그러고 보니 Ө도 하나 얘기를 해야 되는데요…\n빅-Ө는 중간을 의미하지도 않습니다\n비슷한 오개념으로 “빅-Ө는 빅-O와 빅-Ω의 중간을 의미한다“라는 것이 있습니다.\nn과 n^2의 중간은 어디일까요?\n시간 복잡도가 Ө(f(n))이라는 것은 O(f(n))인 동시에 Ω(f(n))이라는 뜻입니다.\n알고 있는 Ω(하한)과 O(상한)이 다르다면, Ө는 아마도 중간 어딘가이긴 하겠지만,\n정확히는 Ө를 논할 수 없다고 말해야 옳습니다.\nO와 Ω가 한 함수에서 딱 만나야 Ө가 생기는 것입니다.\n오해가 퍼진 이유\n“빅-O가 최악의 경우를 의미한다“라는 오개념이 퍼진 이유는 여러 가지가 있겠지만,\n이런 이유를 들 수 있을 것 같습니다.\n\n빅-O와 최악의 경우가 대개 자주 엮입니다.\n아무 입력이나 들어올 수 있는 온라인 저지 환경에서는 최악의 경우에서도 빠른 알고리즘이 선호됩니다.\n그리고 수행 시간이 얼마 이하임을 알아야 알고리즘이 정당하다고 할 수 있는데,\n그 상한의 역할을 하는 게 빅-O 표기법입니다.\n그래서 알고리즘 문제 풀이에서는 빅-O로 최악의 시간 복잡도를 구하는 경우가 많습니다.\n“상한“과 “최악의 경우“가 의미상으로 비슷해 보입니다.\n그도 그럴 게, 최악의 시간 복잡도가 O(f(n))인 알고리즘은 모든 경우에서 O(f(n))의 시간에 돕니다.\n최악의 시간 복잡도는 어떻게 보면 모든 입력의 시간 복잡도에 대한 상한인 셈입니다.\n하지만 다시 정리하자면 빅-O에서 얘기하는 상한은 최선, 최악 관계없이\n특정 경우에서 함수의 상한을 얘기하는 것으로, 꼭 모든 경우에 대한 상한일 필요는 없습니다.\nӨ를 쓸 수 있는 상황에서도 O를 쓰는 경우가 많습니다.\n물론 잘못된 것은 아니지만, 최악과 빅-O가 더 깊게 엮이는 효과를 어느 정도 불렀을 것 같습니다.\n(사실 저도 씁니다. 셋 중에 아스키 문자가 O밖에 없어서요…)\n\n빅-O가 최악의 경우를 뜻한다고 잘못 생각한다면,\n반대로 빅-Ω가 최선의 경우라고 잘못 생각하는 것도 자연스러워 보입니다.\n그리고 최악과 최선을 빼고 남은 게 평균이라서\n빅-Ө가 평균이라는 오개념까지 완성된 게 아닐까 추정해 봅니다.\n","path":null},{"url":"https://jh05013.github.io/blog/wf2022/","title":"ICPC World Finals 2022/23 풀이","description":null,"body":"구현하지 않은 게 있어서 틀린 내용이 있을 수도 있습니다.\n제가 구현해서 정답 받은 건 ✅로 표시했습니다.\n46P/47G. Turning Red\n스위치 $i$를 누른 횟수를 $x_i$라고 합시다. $x_i$는 0, 1, 2 중 하나여야 최적입니다.\n각 전구가 최대 두 스위치에 연결되어 있다는 점에 주목합시다.\n\n전구가 아무 스위치에도 연결되지 않았다면, 그 전구가 붉은색이면 무시합니다. 아니라면 impossible입니다.\n전구가 스위치 1개 $i$에만 연결되었다면, $x_i$의 값이 하나로 고정됩니다.\n전구가 스위치 2개 $i, j$에 연결되었다면, $x_i + x_j$ mod 3의 값이 하나로 고정됩니다.\n\n스위치 1개짜리 전구로 $x_i$ 값들을 고정한 다음, 스위치 2개짜리 전구를 간선 $(i, j)$로 나타내고, 가중치를 그 고정된 $x_i + x_j$ mod 3값으로 둡시다. 이제 이분그래프 판별과 비슷한 방법으로 모든 조건에 맞는 해가 있는지 판별할 수 있습니다.\n조건에 맞는 해가 있다면, 연결 요소마다 가능한 해가 최대 3개입니다. 3개의 후보 중 최적인 것을 골라서 모두 합하면 됩니다.\n✅ 46Q. Doing the Container Shuffle\n기댓값의 선형성에 의해\n\n1을 뽑는 데 필요한 행동 수의 기댓값\n모든 $x$에 대해, $x$를 막 뽑은 상태에서 $x+1$을 뽑는 데 필요한 행동 수의 기댓값\n\n의 합을 구하면 됩니다. 편의상 스택에서 트럭으로 옮기는 건 제외하고, 최종 답에 $n$을 더해서 출력합시다.\n1을 뽑는 데 필요한 행동 수의 기댓값은 맨 처음에 1 위에 쌓인 물건 개수의 기댓값과 같습니다. 다시 기댓값의 선형성에 의해 이 값은 (순열에서 1 뒤에 있는 물건의 개수) / 2입니다.\n$x$를 막 뽑은 상태에서 $x+1$을 뽑는 데 필요한 행동 수의 기댓값은 좀 더 복잡합니다. 일반성을 잃지 않고 $x$가 맨 처음에 왼쪽 스택에 들어갔다고 합시다.\n우선 순열에서 $x+1$이 $x$보다 먼저 등장하는 경우를 생각해 봅시다. 순열을 A x+1 B x C 로 나타내면 스택의 맨 처음 상태로는 다음 두 경우가 가능하고, 각각이 나올 확률은 1/2입니다.\n\n$x$를 막 뽑은 상태에서 스택의 모습은 다음과 같습니다. $C_L$이 거꾸로 써진 것은 순서가 뒤집혀 있음을 나타냅니다.\n\n$A_L$의 크기를 $|A_L|$, 그 크기의 기댓값을 $E[|A_L|]$이라고 합시다. 그러면 $E[|A_L|] = \\frac{|A|}{2}$입니다. $A_R$, $B_L$, $B_R$, $C_L$, $C_R$도 마찬가지입니다. 단, $|A|$를 구할 때는 $x$보다 큰 수만 세어야 합니다. 그보다 작은 수는 이미 제거되었기 때문입니다. 이제 왼쪽의 기댓값은 $\\frac{|B|}{2}$, 오른쪽은 $\\frac{|B|}{2} + |C|$이므로, 전체 기댓값은 둘의 평균인 $\\frac{|B| + |C|}{2}$입니다.\n순열에서 $x+1$이 $x$보다 나중에 나오는 경우도 비슷하게 풀어보면\n\n이번에도 $\\frac{|B| + |C|}{2}$가 나옵니다.\n이를 종합해 보면, 순열에서 $x$와 $x+1$중 먼저 나오는 쪽을 찾고, 그의 오른쪽에 있으면서 $x+1$보다 큰 수의 개수를 구해 2로 나누면 됩니다. 이 값은 펜윅 트리로 구할 수 있습니다.\n46R. Zoo Management\n한 번의 행동에서 사용한 간선은 vertex-disjoint cycle들을 이뤄야 합니다. 편의상 한번에 한 사이클만 고른다고 합시다. 그러면 각 행동은 “사이클을 하나 골라서 한 칸 아무 방향으로 회전시킨다“라고 할 수 있습니다.\n아무 사이클에도 속하지 않는 간선, 즉 단절선은 영원히 사용할 수 없으므로 그래프에서 지워버릴 수 있습니다. 그러면 biconnected component 여러 개가 남고, 각각을 독립적으로 풀면 됩니다.\nBiconnected component가 정확히 사이클 1개라면 그냥 회전만 할 수 있습니다. KMP나 해싱 등 아무 방법으로 한 수열이 다른 수열의 회전인지 판별하면 됩니다. 예를 들어 KMP를 쓴다면, “다른 수열“을 복제하고 이어 붙여서 두 배로 늘리고, 거기서 “한 수열“을 찾으면 됩니다.\nBiconnected component가 사이클 2개 이상으로 이루어져 있다면, 모든 순열이 가능할 것처럼 생겼습니다. 하지만 정확히 그렇진 않습니다. 결론부터 말하면, component에 짝수 길이 사이클이 없으면 짝순열만 만들 수 있고, 아니면 모든 순열을 만들 수 있습니다. 증명은 생략하나, 사각형 두 개가 정점 하나를 공유하고 있는 그래프를 생각해보면 감이 올 수도 있습니다.\n홀수 길이 사이클은 이분 그래프 판별로 풀 수 있다는 점이 잘 알려져 있는데, 짝수 길이 사이클은 어떻게 찾을까요? 짝수 길이 사이클이 없으면 component 전체가 선인장입니다. 간선을 공유하는 사이클이 2개 있다면 거기서 짝수 길이 사이클을 찾을 수 있기 때문입니다. 따라서 선인장인지 판별하고, 선인장의 각 블록 중 하나라도 짝수 길이 사이클인지 보면 됩니다.\n짝순열을 써서 우리가 원하는 동물 배치를 할 수 있다는 사실은 어떻게 알 수 있을까요? 동물 번호가 중복될 수도 있어서 곤란해 보입니다. 다행히도 생각보다 간단합니다. 중복되는 동물이 있다면, 두 배치가 그냥 순열 관계인지만 확인하면 됩니다. 중복되는 동물 한 쌍을 교환하면 순열의 홀짝성이 바뀌지만 배치는 그대로니까, 어떤 배치를 만들든 홀순열과 짝순열이 모두 가능하기 때문입니다. 중복되는 동물이 없다면 평소에 하던 대로 하면 됩니다.\n혹시나 해서 첨언하자면 순열의 홀짝성을 판별할 때 세그트리/펜윅트리를 쓸 필요가 전혀 없습니다. 그냥 순열을 사이클로 분할했을 때 짝수 사이클의 개수의 홀짝성이 답입니다.\n✅ 46S/47J. Bridging the Gap\n$N &lt; C$이면 그냥 입력된 수의 최댓값이 답입니다. ($N = C$여도 그렇지만, 상관없습니다.) 이제 $N \\geq C$라고 가정합니다. 또한 건너는 시간이 오름차순으로 정렬되어 있다고 가정합니다. 즉 $i &lt; j$이면 사람 $i$가 $j$보다 빠르거나 같습니다.\n$C = 2$의 경우 이미 BOJ에 있는 문제고, 이런 논문이 있습니다. 그 경우의 풀이를 찾고 더 큰 $C$에 대해 일반화하면 다른 논문 및 이 문제의 풀이를 얻습니다. 이 글에서는 $C = 2$일 때의 증명과 일반적인 $C$에서의 결론만 소개하고, 일반적인 $C$에서의 증명은 생략합니다.\n$C = 2$라고 가정합니다. 다리를 건너가는 것을 앞 횡단, 다시 건너 돌아오는 것을 뒤 횡단, 둘을 묶어서 횡단이라고 부릅시다.\n정리 1. 모든 앞 횡단의 크기가 2명, 모든 뒤 횡단의 크기가 1명인 최적해가 존재합니다.\n증명. 그렇지 않은 횡단이 있다면, 그중 첫 횡단을 잡아 “문제의 횡단“이라고 합시다. 그럼 다음 4가지 케이스가 있고, 각각 더 좋은 해를 만들 수 있습니다. \"\" 로 감싼 것이 문제의 횡단입니다.\n\n■\n그러한 최적해에서 앞 횡단은 $N-1$개, 뒤 횡단은 $N-2$개입니다.\n정리 2. 횡단에 소요되는 전체 시간은 (모든 앞 횡단에 대해, 더 느린 사람의 시간의 합) + (모든 사람에 대해, (그 사람이 건너는 시간) * (그 사람이 앞으로 횡단한 횟수 - 1)의 합)입니다.\n증명. 앞 항은 모든 앞 횡단의 시간의 합입니다. (앞으로 횡단한 횟수 - 1)은 (뒤로 횡단한 횟수)와 같고, 정리 1에 의해 모든 뒤 횡단의 크기는 1이므로, 뒤 항은 모든 뒤 횡단의 시간의 합입니다. ■\n정리 2는 앞 횡단만 가지고 전체 횡단 시간을 계산할 수 있음을 의미합니다. 그렇다면 아예 뒤 횡단을 버리고, 특정 조건이 성립하는 앞 횡단만 잘 정해서 최적해를 탐색할 수 있으면 좋을 것 같습니다. 실제로 그런 데다가, 앞 횡단의 순서도 중요하지 않습니다.\n정리 3. 두 명짜리 앞 횡단 $p_1q_1, \\cdots, p_{N-1}q_{N-1}$이 있을 때, 각 사람이 앞 횡단 중 적어도 하나에 포함된다면, 앞 횡단의 순서가 $p_1q_1, \\cdots, p_{N-1}q_{N-1}$ 의 어떤 한 순열인 올바른 횡단 순서가 존재합니다.\n앞 횡단을 $pq$로 표기했는데, 이때 $p$와 $q$ 사이 대소관계는 정해두지 않았습니다. $p &lt; q$일 수도 있고 $p &gt; q$일 수도 있습니다.\n증명. 앞 횡단을 한 번만 하는 사람을 “정착민”, 그렇지 않은 사람을 “유목민“이라고 합시다.\n$N$에 대한 귀납법을 사용합니다. $N = 2$면 자명합니다.\n$N \\geq 3$이라고 합시다. 각 사람의 앞 횡단 횟수의 평균은 $1 &lt; \\frac{2N-2}{N} &lt; 2$이므로, 정착민과 유목민이 적어도 한 명씩은 존재합니다. 이제\n\n정착민 $x$와 유목민 $y$로 이루어진 앞 횡단 $xy$가 있다면, $xy$를 제거하고 귀납법으로 $N-1$명짜리 횡단 순서를 얻어낸 다음, 뒤 횡단 $x$, 앞 횡단 $xy$를 덧붙이면 됩니다.\n그렇지 않다면 $N \\geq 4$이고, 정착민 2명짜리 앞 횡단 $xy$와 유목민 2명짜리 앞 횡단 $zw$가 있습니다. 둘 다 제거하고 귀납법으로 $N-2$명짜리 횡단 순서를 얻어낸 다음, 뒤 횡단 $z$, 앞 횡단 $xy$, 뒤 횡단 $w$, 앞 횡단 $zw$를 덧붙이면 됩니다.\n\n■\n이제 뒤 횡단을 볼 필요가 없으니, 앞 횡단을 줄여서 그냥 “횡단“이라고 부르겠습니다. 횡단의 순서는 중요하지 않고, 조합만 찾으면 됩니다. 그중에서 구체적으로 어떤 형태가 최적인지 살펴봅시다.\n직관적으로 생각해 보면, 우선 가장 빠른 사람들이 유목민 역할을 해야 할 것 같습니다. 또한 가장 오래 걸리는 사람들끼리 짝지어서 횡단해야 할 것 같고, 횡단 개수를 맞추려면 유목민을 중간에 섞어야 하는데, 유목민과 정착민이 같이 횡단해야 한다면 빠른 정착민들이랑 유목민 1이 같이 가야 할 것 같습니다. 이 성질들을 엄밀하게 정리하면 다음과 같습니다.\n정리 4. 다음을 모두 만족시키는 최적해가 존재합니다.\n\n(1) 유목민 $x, y$에 대해 횡단 $xy$가 있을 때, 그 횡단은 $12$입니다.\n(2) 유목민 $x$와 정착민 $y$에 대해 횡단 $xy$가 있을 때, $x = 1$입니다.\n(3) 정착민 $x, y, z$에 대해 횡단 $1x$와 $yz$가 있을 때, $x &lt; y$, $x &lt; z$입니다.\n(4) 정착민 $x, y$에 대해 횡단 $xy$가 있을 때, $|x - y| = 1$입니다.\n\n다른 말로 하면 $12, 12, \\cdots, 12, 13, 14, \\cdots, 1k, [k+1][k+2], [k+3][k+4], \\cdots, [N-1]N$ 꼴의 최적해가 있습니다.\n증명.\n\n(1) 그렇지 않다면 $12$로 바꿔도 됩니다.\n(2) 그렇지 않다면 $1y$로 바꿔도 됩니다.\n(3) 일반성을 잃지 않고 $y &lt; z$라고 합시다. $x &gt; y$라면 $1y$와 $xz$로 바꿔도 됩니다.\n(4) 위의 (1)(2)(3)에 의해, 정착민 2명짜리 횡단에 참여하는 사람들은 특정 $k$에 대해 $k, k+1, \\cdots, N$입니다. $k$에 대한 귀납법을 거꾸로 사용합니다. $k &gt; N$이라면 자명합니다. 횡단 $k[k+1]$이 없다면, 정착민 $x, y &gt; k+1$에 대해 횡단 $kx$와 $ky$가 있습니다. 이를 $k[k+1]$과 $xy$로 바꿔도 됩니다. 귀납법에 의해 $k+2$ 또는 그 이후의 정착민에 대해서도 (4)가 성립합니다.\n\n■\n후보가 대략 $\\frac{N}{2}$개이므로 각각의 시간을 계산하여 $O(N^2)$에 풀 수 있습니다.\n위 정리들은 더 큰 $C$에 대해 다음과 같이 일반화됩니다. 증명은 생략합니다.\n정리 1+. 모든 앞 횡단의 크기가 2명 이상, 모든 뒤 횡단의 크기가 1명인 최적해가 존재합니다.\n정리 2+ 와 3+ 는 정리 2, 3과 거의 같습니다.\n정리 4+. 다음을 모두 만족시키는 최적해가 존재합니다.\n\n(1&amp;2) 횡단에 유목민이 $k$명 있을 때, 그 유목민은 $1, \\cdots, k$입니다.\n(4) 각 횡단에서 정착민의 번호는 연속합니다.\n(3) 정착민이 있는 횡단을 가장 느린 사람의 시간에 대한 오름차순으로 정렬하면 유목민의 명수는 내림차순입니다.\n(보너스) 정착민이 있는 횡단 중 크기가 $C$보다 작은 것은 최대 하나이며, 그 횡단은 $1, \\cdots, (횡단\\ 크기)$입니다.\n\n이제 알고리즘을 설계할 준비가 되었습니다. 맨 처음에 모든 사람들이 “색칠되지 않았다“고 하고, 추가로 횡단의 개수 조건을 맞추는 데 사용할 “빚“이라는 정수를 초기값 0으로 관리합시다.\n\n(1) $C$명 이하가 색칠되지 않은 상태로 남을 때까지,\n\n0 이상 $C-1$ 이하의 정수 $k$를 정합니다. $k$는 단조증가해야 합니다.   - 색칠되지 않은 맨 마지막 사람을 x라고 할 때, 유목민 $1, \\cdots, k$와 정착민 $x-(C-k)+1, \\cdots, x$를 횡단시키고, 빚에 $1-k$를 더합니다.\n\n\n(2) 빚이 0 미만이면 실패입니다. 아니라면 색칠되지 않은 사람들을 모두 횡단시킵니다.\n(3) 빚이 0이 될 때까지,\n\n2 이상 $C$ 이하의 정수 $k$를 정합니다.\n유목민 $1, \\cdots, k$를 횡단시키고, 빚에서 $k-1$을 뺍니다.\n\n\n\n(1)(3)에서 $k$를 잘 정하는 게 목표입니다. DP 식을 세워보면 (색칠되지 않은 사람 수, 빚, (1)에서 마지막으로 정한 $k$값)으로 $O(N^3)$개의 상태가 생길 것처럼 생겼습니다. 하지만\n\n빚이 음수인 상태는 고려할 필요가 없습니다. 빚이 감소하려면 $k&gt;1$이어야 하는데, 그러면 단조증가 조건에 의해 빚이 매번 감소해서 0으로 못 돌아오기 때문입니다.\n빚은 $[\\frac{N}{C}]$ 이하입니다. 빚이 증가하려면 $k=0$이어야 하는데, 그럴 때마다 빚이 1 증가하고 $C$명이 색칠되기 때문입니다.\n빚이 항상 0이상이라는 조건이 있는 한 $k$가 단조증가해야 한다는 조건은 필요가 없고, 따라서 마지막으로 정한 $k$ 값도 볼 필요가 없습니다.\n\n그러므로 상태 $O(\\frac{N^2}{C})$개에 상태 당 전이 $C$개로 총 $O(N^2)$에 문제를 풀 수 있습니다.\n✅ 46T/47D. Carl’s Vacation\n최적의 경로는 (1) 출발 사각뿔의 한 면을 타고 직선을 따라 바닥에 내려가고, (2) 바닥에서 도착 사각뿔의 바닥으로 직선을 따라 이동하고, (3) 도착 사각뿔의 한 면을 타고 직선을 따라 꼭대기로 올라가야 합니다.\n(2)의 시작점과 도착점은 정사각형의 한 변 위에 있습니다. 변을 하나씩 선택하고, 각 변 위의 정확히 어느 지점에서 출발하고 도착할 건지를 변수 $a$와 $b$로 나타내면, (1), (2), (3)의 길이는 모두 $a$와 $b$에 대한 볼록함수입니다. 볼록함수의 합 역시 볼록함수이므로, 전체 길이도 볼록함수입니다. 따라서 삼분탐색을 이중으로 중첩해서 쓰면 됩니다.\n물론 (2)에서 밑면을 뚫고 지나가면서 조건을 어기는 경우도 있겠지만, 그런 경우는 애초에 최적이 아닙니다.\n✅ 46U. Toy Train Tracks\n우선 직선 조각 $S$개, 커브 조각 $C$개를 다 써서 루프를 만들 수 있는지 판별해 봅시다. $S$와 $C$가 작은 경우부터 하나씩 손으로 풀어보면 규칙을 찾을 수 있습니다. 결론부터 말하면,\n\n$S$는 짝수여야 합니다.\n$C$는 4 이상의 짝수여야 합니다.\n$C \\equiv 2 (mod\\ 4)$이거나 $C = 8$일 경우, $S$는 2 이상이어야 합니다.\n\n나머지 경우가 불가능한 이유는 후술합니다.\n가능한 경우는 $C = 4$, $C = 6$, $C = 8$, $C \\equiv 2 (mod\\ 4)$, $C \\equiv 0 (mod\\ 4)$로 케이스워크를 하면 됩니다.\n\n이제 본 문제를 풀어봅시다. 위 가능한 경우들을 정리해 보면 직선 조각을 1개 이하, 커브 조각을 7개 이하로 남기는 해가 존재하므로, $(S, C)$에 따라 최대 16개의 후보를 만들고 그중 가장 긴 것을 출력하면 됩니다.\n불가능한 경우 증명:\n\nS가 홀수이면 불가능: 격자를 체스판으로 색칠하고, 루프를 탔을 때 각 칸에 들어오는 방향을 생각해 봅시다. 커브 조각만 사용하면 검은 칸은 항상 가로로, 흰 칸은 항상 세로로 들어옵니다. (물론 그 반대여도 됩니다.) 직선 조각을 하나 타는 순간 두 색의 역할이 바뀝니다. 즉 검은 칸은 세로로, 흰 칸은 가로로 들어오게 됩니다. 루프를 한 바퀴 돌면 두 색의 역할이 유지되어야 하므로 직선 조각은 짝수 번 타야 합니다.\nC가 홀수이면 불가능: 커브 조각을 탈 때마다 이동 방향이 가로에서 세로로, 세로에서 가로로 바뀝니다. 루프를 한 바퀴 돌면 이동 방향이 유지되어야 하므로 커브 조각은 짝수 번 타야 합니다.\nS가 0, C가 4k+2 꼴이면 불가능: 한 칸에서 커브 조각을 두 번 타면 그 칸과 대각선 방향으로 인접한 칸으로 가게 됩니다. 커브 조각 4k+2개 대신 대각선 조각 2k+1개가 있다고 생각하고 위의 C가 홀수이면 불가능 논리를 쓰면 됩니다.\nS가 0, C가 8이면 불가능: 직접 해보면 됩니다.\n\n✅ 46V/47C. Three Kinds of Dice\n편의상 1점, 0.5점이 아니라 2점, 1점씩 얻는다고 하고, 맨 마지막에 출력할 때 2로 나눕시다.\nD3를 굴려서 x가 나왔을 때 내(D3)가 얻는 점수의 기댓값을 f(x)라고 하면, f는 같은 값으로 이루어진 $2n+1$개 이하의 구간으로 이루어집니다. 예를 들어 예시의 1 1 6 6 8 8과 2 4 9는\n\nD3의 면마다 대응되는 f 값의 평균이 1 이상이면, D3는 그 주사위를 이기거나 비깁니다. 예를 들어 (2/3 + 2/3 + 2)/3 = 1.111... 이므로 두 번째 주사위가 첫 번째 주사위를 이깁니다. 이것으로 둘 중 어느 쪽이 D1이고 어느 쪽이 D2인지 알아낼 수 있습니다.\n이제 우리가 D3를 만들어야 합니다. 면의 개수를 마음대로 정할 수 있으므로, 각 x에 임의의 음이 아닌 유리수 가중치를 부여할 수 있습니다. 그 대신 가중치의 합은 1이라고 합시다. 또한 x의 값 말고 (D1의 f 값, D2의 f 값) 순서쌍이 중요하고, 서로 다른 순서쌍이 $4n+1$개 이하이므로, 가중치를 부여할 대상은 그 $4n+1$개뿐입니다. 이제 우리가 구할 값은\n\nD1의 f 값에 대한 (가중치를 고려한) 평균이 1 이상일 때, D2의 f 값에 대한 평균의 최솟값\nD2의 f 값에 대한 평균이 1 이하일 때, D1의 f 값에 대한 평균의 최댓값\n\n입니다.\n$(x, y)$ 순서쌍 여러 개에 음이 아닌 가중치를 뒀을 때 ($x$의 평균, $y$의 평균)으로 가능한 값의 영역은, $(x, y)$들을 좌표평면에 놓았을 때 볼록 껍질의 둘레 및 내부입니다.\n\n따라서 답은 그 볼록 껍질과 직선 $x = 1$의 교점, 그리고 볼록 껍질과 직선 $y = 1$의 교점입니다. 가중치에 유리수 조건이 있지만, 교점의 좌표도 유리수이므로 적절한 유리수 가중치가 항상 존재함을 알 수 있습니다. 구체적으로 어느 교점을 출력해야 되는지는 $x$, $y$ 중 어느 쪽이 D1, D2인지에 따라 적절히 정하면 됩니다.\n✅ 46W/47A. Riddle of the Sphinx\n\n1 0 0을 물어봅니다. 대답을 $a$라고 합시다.\n0 1 0을 물어봅니다. 대답을 $b$라고 합시다.\n0 0 1을 물어봅니다. 대답을 $c$라고 합시다.\n1 1 1을 물어봅니다. 대답을 $d$라고 합시다.\n\n만약 $a+b+c = d$라면, 스핑크스는 지금까지 참말만 했습니다. 아무거나 물어보고 대답을 들은 다음 $a$ $b$ $c$를 출력하면 됩니다.\n아니라면, 스핑크스는 한 번 거짓말을 했습니다. 이 시점에서 답의 후보는\n\n$(a, b, c)$\n$(d-b-c, b, c)$\n$(a, d-a-c, c)$\n$(a, b, d-a-b)$\n\n이고, 서로 다른 후보를 모두 구별하는 질의가 존재함을 증명할 수 있습니다. 스핑크스가 다음 질의에서는 참말을 할 것이므로 그걸 물어보면 됩니다.\n사실 경우를 나눌 것도 없이 그냥 1 2 3을 물어봐도 됩니다.\n46X. Quartets\n답이 yes인지 판별할 수 있으면, no일 경우 언제부터 반칙의 존재가 확실한지도 어렵지 않게 구할 수 있습니다. 그러니 답이 yes인지 판별하는 것에 집중합시다.\n예제 2를 따라가면서 풀이를 설명하면 좋을 것 같습니다. 맨 처음에 각 플레이어가 8장씩 나눠갖지만 각각이 무슨 카드인지 모르니, 다음과 같이 표기합시다. 정체를 알 수 없는 카드는 “모르는 카드”, 아니면 “아는 카드“라고 지칭합시다.\n\n첫 기록은 1 A 2 3C no 입니다. p A q ks no 형태의 기록은 다음과 같은 정보를 제공합니다.\n\n플레이어 p의 손에 k* 꼴의 카드가 있습니다. p의 손에 있는 아는 카드 중 k* 꼴이 있다면, 이는 아무 정보도 주지 않습니다. 없다면, p의 손에 있는 모르는 카드 중 하나가 k* 꼴입니다. 모르는 카드가 없다면 반칙의 존재가 확실합니다.\n플레이어 q의 손에 ks 카드가 없습니다. q의 손에 있는 아는 카드 중에 ks가 있다면 반칙의 존재가 확실합니다. 없다면, q의 손에 있는 모르는 카드 중 아무것도 ks가 아닙니다. 모르는 카드가 없다면 아무 정보도 주지 않습니다.\n\n다른 사람의 손으로 옮겨진 카드는 무조건 아는 카드가 되기 때문에, !1..8 + @1..3 has 3* 같이 여러 플레이어에 걸쳐서 주어지는 정보는 없습니다.\n\n다음 기록은 2 A 3 3A yes 입니다. p A q ks yes 형태의 기록은 다음과 같은 정보를 제공합니다.\n\n플레이어 p의 손에 k* 꼴의 카드가 있습니다. 위와 같습니다.\n플레이어 q의 손에 ks 카드가 있습니다. q의 손에 있는 아는 카드 중에 ks가 있다면 아무 정보도 주지 않습니다. 없다면, q의 손에 있는 모르는 카드 중 하나가 ks입니다. 일반성을 잃지 않고 맨 마지막 카드가 ks라고 할 수 있습니다. 모르는 카드가 없다면 반칙의 존재가 확실한데, 그런 경우가 실제로 발생할 수 있는지는 잘 모르겠습니다.\n\n\n다음 기록은 2 A 4 3D yes 입니다. 같은 방식으로 처리합니다. 손에 이미 3A가 있으니 “3* 꼴의 카드가 있음“은 아무 정보도 주지 않습니다.\n\n다음 기록은 2 A 1 3B no 입니다.\n\n다음 기록은 1 A 4 5B yes 입니다.\n\n다음 기록은 1 Q 5 입니다. p Q k 형태의 기록은 플레이어 p의 손에 kA, kB, kC, kD 카드가 있다는 정보를 제공합니다. 그런데 이 플레이어의 모르는 카드에 대한 정보가 이미 있었으니, 카드를 공개하면서 이 정보도 업데이트해야 합니다.\n\n!1..z has k* 정보가 있는 상태에서 !z 가 ks 라는 정보를 얻었으면, 앞의 정보는 더 이상 의미가 없으므로 제거합니다. 다른 세트의 카드라는 정보를 얻었으면, !1..(z-1) has k* 로 수정합니다.\n!1..z hasn't ks 정보가 있는 상태에서 !z 가 ks 라는 정보를 얻었으면 반칙의 존재가 확실합니다. 아니라면 !1..(z-1) hasn't ks 로 수정합니다.\n\n\n이제 아직 행방이 밝혀지지 않은 카드들을 모르는 카드에 잘 배정해서 모든 정보와 일치시킬 수 있는지 확인해야 합니다. 뭔가 매칭 문제를 닮았으니, 플로우 모델링을 시도해보면 다음 LR-flow 모델이 만들어집니다.\n\nsource, sink, P1, P2, P3, P4 정점을 만듭니다.\n각 플레이어 p 와 세트 k 의 쌍을 나타내는 pk 정점을 만듭니다. Pp 에서 pk 로 간선을 긋습니다. 용량은 4, 최소 유량은 p 에 “has k*” 정보가 있다면 1, 아니면 0으로 둡니다.\n행방이 밝혀지지 않은 카드를 나타내는 ks 정점을 만듭니다. p 에 “hasn't ks” 정보가 없다면 pk 에서 ks 로 간선을 긋습니다. 용량은 1, 최소 유량은 0으로 둡니다.\nks 에서 sink로 간선을 긋습니다. 용량과 최소 유량은 1로 둡니다.\n\n이제 LR-flow 를 돌려서 해가 있는지 확인하면 됩니다.\n✅ 46Y. Compression\n다음 그리디 전략을 생각해볼 수 있습니다.\n\n우선 연속된 같은 글자들을 하나로 합칩니다.\n그러면 1과 0이 번갈아서 나오는 형태가 되는데, 연속된 10이나 01들을 하나로 합칩니다. 마지막에는 0, 1, 01, 10, 010, 101 중 하나가 남습니다.\n\n이 전략은 최적입니다. 왜냐?\n\n정답의 길이가 1일 필요충분조건은 “한 종류의 글자로만 이루어져 있음“입니다. 0이 하나라도 있다면 0을 전부 지울 수 없고, 1도 마찬가지이기 때문에, 0과 1이 모두 있는 문자열은 길이를 2보다 짧게 줄일 수 없습니다.\n첫 글자를 바꿀 수 없습니다. 첫 글자를 바꾸려면 지워야 되는데, 그러면 문자열이 [abcde]abcdefgh 꼴이므로 지운 후에도 첫 글자가 유지됩니다.\n마찬가지로 마지막 글자도 바꿀 수 없습니다.\n01, 10, 010, 101은 (첫 글자, 마지막 글자)가 모두 다르고, 가능한 4가지 경우를 모두 커버하기 때문에, 0과 1이 모두 있는 문자열의 최종 결과는 넷 중에 정확히 하나로 정해져 있습니다.\n\n46Z. Archaeological Recovery\nTODO\n✅ 47B. Schedule\n먼저 주어진 $n$과 $w$에 대해 답이 유한인지 판별해 봅시다. 그러려면 길이 $n$의 이진 문자열 (편의상 1, 2가 아니라 0, 1이라고 합시다) $w$개를 만들어서 다음 조건을 만족시켜야 합니다.\n\n인덱스 $i$에 대해, $j$번째 문자열의 $i$번째 문자가 1 인 모든 $j$의 집합을 $S_j$라고 하자. 모든 서로 다른 인덱스 $i$, $j$에 대해, (1) $S_i \\cup S_j$에 없는 원소가 존재하고, (2) $S_i$와 $S_j$는 서로 부분집합 관계가 아니며, (3) $S_i \\cap S_j$는 공집합이 아니어야 한다.\n\n(1) (2) (3)은 해당 인덱스 쌍에 00, 01, 10, 11이 모두 존재함과 동치입니다.\n일반성을 잃지 않고 첫 번째 문자열이 00...00 이라고 하면 (1)은 저절로 해결됩니다. (2)와 (3)이 문제인데, 방향을 바꿔서 ${1, \\cdots, w}$의 부분집합 $n$개를 만든다고 합시다. 일단 (2)만 있다고 하면 슈페르너의 정리에 의해 가능한 $n$의 최댓값은 $\\binom{w-1}{[\\frac{w-1}{2}]}$ 입니다. 실제 해는 ${2, \\cdots, w}$의 모든 $[\\frac{w-1}{2}]$ 크기 부분집합을 쓰면 됩니다.\n(3)이 들어가도 결론은 비슷합니다. 이 논문에 따르면 가능한 $n$의 최댓값은 $\\binom{w-1}{[\\frac{w-1}{2}]+1}$ 입니다. 실제 해는 ${2, \\cdots, w}$의 모든 $[\\frac{w-1}{2}]+1$ 크기 부분집합을 쓰면 됩니다.\n이제 본 문제로 돌아갑시다. 주어진 $n$에 대해, 가능한 $n$의 최댓값이 그 이상이 되는 가장 작은 $w’$을 찾습니다. $w’ &gt; w$라면 답은 무한입니다. $w’ \\leq w$라면 답은 $w’$입니다. $w$ 대신 $w’$가 주어져도 답이 $w’$이니, 그보다 큰 $w$를 줘도 $w’$보다 작은 답을 만들 수 없기 때문입니다. 실제 해는 위에서 만든 이진 문자열 $w’$개를 돌아가면서 계속 출력하면 됩니다.\n47E. A Recurring Problem\nBenq 코멘트\n\nFor each continuation of length 4 up to a certain bound, count the number of recurrences with that continuation. This allows us to find the first four values of the continuation. Then, given the first four values of the continuation, we can enumerate all recurrences with that continuation, which turns out to be bounded by 4836557 for the given constraints. Though I had to spend several hours to fix the MLE / TLE / WA verdicts (the memory usage is barely under 2TB) …\n\narknave 코멘트\n\nThat looks largely correct. The main idea to speed up the solution and reduce its memory consumption is: for each continuation, instead of just counting the number of recurrences that begin with that continuation, compute all possible next values to this continuation, along with their frequencies. This lets you prune out a bunch of useless continuations since the values get very sparse after the first few values in the sequence.\n\n47F. Tilting Tiles\n사실 이 퍼즐에서 할 수 있는 행동은 거의 없습니다.\n\n같은 방향으로 두 번 밀 이유가 없습니다. 이 퍼즐은 2048 게임이 아닙니다.\n한 번 밀고 나서 바로 반대 방향으로 밀 이유가 없습니다. 그럼 바로 전 밀기가 의미가 없어집니다. 그래서 매번 바로 전 밀기 방향에 수직인 방향으로 밀어야 됩니다.\n처음에 x 방향으로 밀고, 다음에 x와 수직인 y 방향으로 밀었다면, 그 다음에는 x의 반대 방향으로 밀어야 합니다. y에 수직이어야 되는데 다시 x 방향으로 미는 건 효과가 없기 때문입니다.\n따라서 실제로 의미가 있는 행동은 소용돌이처럼 시계나 반시계 방향으로 돌아가면서 미는 것뿐입니다. 맨 처음 방향과 소용돌이의 회전 방향에 따라 총 8개의 후보가 있습니다.\n\n이제 한 소용돌이를 잡고, 그 전략으로 우리가 원하는 배치를 만들 수 있는지 판별해 봅시다. 시작 방향과 관계없이 네 방향으로 한 번씩 미는 것을 “소용돌이 한 바퀴 돌기“라고 부릅시다.\n첫 소용돌이를 돌고 나면 이후로 소용돌이 한 바퀴마다 공백의 위치가 같아짐을 증명할 수 있습니다. 예를 들어 5번 민 상태와 9번 민 상태는 각 칸에 적힌 글자는 다를 수 있어도, 각 칸이 공백인지 아닌지 여부는 같습니다.\n따라서 우리가 할 일은\n\n하나의 소용돌이로 치지 않고 따로 밀 횟수 $s$를 설정합니다. $0 \\leq s \\leq 5$ 입니다. (5도 고려해야 후술할 전략으로 모든 경우가 커버됩니다.)\n소용돌이 방향으로 $s$번 밉니다. 공백의 위치가 우리가 원하는 배치와 다르면 실패입니다.\n이제 공백은 됐고, 글자가 모두 맞을 때까지 소용돌이를 한 바퀴 단위로 돌립니다.\n\n여기서 끝나면 좋겠지만, 필요한 소용돌이 횟수가 너무 커서 시간 안에 안 돌 것입니다.\n소용돌이 1회는 공백이 아닌 글자들을 특정 순열에 따라 이동시키는 것으로 볼 수 있습니다. 그 순열을 얻어내려면 공백이 아닌 위치에 1, 2, 3, …을 차례대로 써넣고 소용돌이를 한 바퀴 돌리면 됩니다. 결국 우리가 풀어야 되는 문제는 다음과 같습니다.\n“시작 문자열, 끝 문자열, 순열이 주어졌을 때, 순열을 반복 적용시켜 시작 문자열을 끝 문자열로 만들 수 있는가?”\n순열을 사이클로 분할합니다. 그중 한 사이클의 시점에서 문제를 바라보면,\n“시작 문자열, 끝 문자열이 주어졌을 때, 시작 문자열을 회전시켜 끝 문자열로 만들 수 있는가?”\n단, 여기서의 시작과 끝 문자열은 그 사이클이 갖고 있는 문자들만 그 사이클 순서대로 뽑아서 만들어야 합니다. 이건 KMP나 해싱 등을 써서 풀 수 있습니다. 예를 들어 KMP를 쓴다면, 끝 문자열을 복제하고 이어 붙여서 두 배로 늘리고, 거기서 시작 문자열을 찾으면 됩니다. (어디서 들어본 말 같죠? 물론 서로 다른 대회에서 나왔습니다.)\n한 사이클이라도 위 질문에 대한 답이 “아니오“라면 실패입니다. 여기서 끝나면 좋겠지만, 모든 답이 “예“여도 전체가 성공이란 보장은 없습니다. 예를 들어\n\n위 두 경우 각각은 “예“이지만, 첫 번째 경우는 4k+2번, 두 번째 경우는 홀수 번 회전시켜야 되기 때문에, 순열을 아무리 적용해도 두 경우가 동시에 만족될 수는 없습니다. 따라서 단순히 “만들 수 있는가?“가 아니라 다음 문제를 풀어야 합니다.\n“시작 문자열, 끝 문자열이 주어졌을 때, 시작 문자열을 x칸 오른쪽으로 회전시켰을 때 끝 문자열이 될 필요충분조건이 $x \\equiv a (mod\\ m)$이라고 하자. $a$와 $m$은 얼마인가?”\n다행히도 “만들 수 있는가?“를 풀 수 있다면 위 문제도 쉽게 풀 수 있습니다. 이제 모든 사이클에 대해 모듈로 방정식 $x \\equiv a (mod\\ m)$을 모으고, 그 연립방정식의 해가 존재하면 성공, 아니면 실패입니다. 이제 중국인의 나머지 정리를 쓰면 됩니다. $m$의 최소공배수가 너무 클 수 있어서 정확한 해를 구하기는 어렵지만, 확장 유클리드로 해를 구하는 과정을 들여다 보면 사실 해의 존재성만 판별하는 건 gcd 하나로 충분함을 알 수 있습니다. “확장“도 지우고 그냥 유클리드 알고리즘을 쓰면 됩니다.\n✅ 47H. Jet Lag\n$k$초 동안 자고 일어났을 때 다음 $k$초 동안은 잘 수 없다는 조건이 거슬립니다. 이 조건이 없었다면 가능한 한 일찍 자고 늦게 일어나는 그리디 전략이 통했을 것입니다. 구체적으로,\n\n첫 이벤트 이전 기간, 또는 인접한 두 이벤트 사이의 빈 기간을 “공백기“라고 합시다. 즉 타임라인은 공백기와 이벤트가 번갈아서 나열되어 있습니다.\n첫 공백기 내내 잡니다. $k$초 동안 자면 다음 $2k$초 동안 깨어있을 수 있습니다.\n그 다음 공백기부터는, 잤을 때 더 늦게까지 깨어있을 수 있다면 내내 자고, 아니면 건너뜁니다.\n한 번이라도 이벤트가 끝날 때까지 깨어있을 수 없다면 불가능합니다.\n\n다행히도 “다음 $k$초 동안은 잘 수 없다는 조건“이 들어가도 위에서 만든 전략을 조금 수정해서 재활용할 수 있습니다. 인접한 잠 스케줄이 새로운 조건에 위배되면, 둘 중 앞쪽의 스케줄을 앞당겨서 더 일찍 일어나게 바꾸면 됩니다. $k$초 동안 잘 수 없다는 조건이 없었을 때 해가 존재하지 않는다면, 조건을 추가했을 때 해도 당연히 존재하지 않습니다.\n✅ 47I. Waterworld\n$nm$개 조각 각각의 겉넓이를 구하고, 그 조각에 배정된 값과 곱하여 모두 합해야 됩니다.\n같은 경도에 있는 조각의 겉넓이는 같습니다. 회전축을 기준으로 한 칸 만큼 돌리면 완전히 똑같은 모양이 나오기 때문입니다. 그러므로 특정 경도에 있는 조각의 겉넓이를 구하려면, 그 경도 범위로 구를 잘랐을 때 그 부분의 겉넓이를 구하고 $m$으로 나누면 됩니다.\n이를 구하려면 회전체의 겉넓이 공식을 쓰면 됩니다. $t$에 대한 매개변수 곡선 $(x(t), y(t)), t \\in [a, b]$를 $x$축을 중심으로 돌렸을 때 나오는 회전체의 겉넓이는 다음과 같습니다.\n$2 \\pi \\int_a^b y(t) \\sqrt{(\\frac{dx}{dt})^2 + (\\frac{dy}{dt})^2} dt$\n구체적으로, 구 $x^2 + y^2 + z^2 = r^2$를 $t_1 \\leq x \\leq t_2$ 범위로 잘랐을 때 그 부분의 겉넓이를 구해 봅시다. 우리가 원하는 호의 매개변수 곡선은 $(r \\cos t, r \\sin t), t \\in [cos^{-1} \\frac{x_2}{r}, cos^{-1} \\frac{x_1}{r}]$입니다. 위 공식에 대입해 보면 $\\sqrt{(\\frac{dx}{dt})^2 + (\\frac{dy}{dt})^2} = r$이므로, $A = 2 \\pi r^2 \\int_{t_1}^{t_2} \\sin t \\ dt = 2 \\pi r^2 [\\cos t]_{t_1}^{t_2} = 2 \\pi r (x_2-x_1)$ 입니다.\n그러니까, 어느 경도 범위로 자르느냐에 관계 없이 범위의 길이가 같으면 겉넓이도 같습니다. 결론적으로 모든 조각의 겉넓이가 같으므로, 그냥 입력된 수들의 평균을 출력하면 됩니다…\n47K. Alea Iacta Est\n$6^d$개의 상태가 있는 그래프를 생각합시다. 정점마다 어느 주사위를 고정할지를 잘 정해서, 랜덤 워크를 했을 때 도착점 중 하나에 도달하는 데 필요한 걷기 횟수의 기댓값을 최소화해야 합니다. 연립방정식을 세워서 가우스 소거 같은 걸 하기에는 어림도 없는 크기입니다.\n기댓값의 근사값을 구해도 충분하고, 그 값도 작은 편이기 때문에, 모든 정점의 기댓값을 특정 초기값으로 잡고 수렴할 때까지 계산을 돌려도 될 것처럼 생겼습니다. (아마?? 월파 라이브 방송에서 들은 거긴 한데 확실하진 않습니다… TODO) 아쉽게도 이 그래프는 간선이 너무 많아서 시간 안에 수렴은 커녕 한 번 돌리기도 어렵습니다. 사실상 완전그래프입니다! 모델링을 조금 수정해서, 정점이 좀 더 많아지더라도 간선이 선형 수준으로 떨어지도록 합시다.\n첫 번째 최적화는 전략과 굴리기를 분리하는 것입니다. 주사위마다 글자 6개뿐만 아니라 “곧 다시 굴릴 예정“을 의미하는 ?를 추가해 총 $7^d$개의 상태를 만듭니다. ?이 없는 상태에서는 일부 주사위를 ?로 만드는 총 $2^d$개의 간선을 추가합니다. 이 간선은 우리가 전략을 세워서 정점마다 하나씩 선택해야 합니다. 또한 ?이 있는 상태에서는 ?를 다시 굴리는 총 $6^{\\text{?의 개수}}$개의 간선을 추가합니다. 이 간선은 매번 균일한 확률로 무작위로 선택됩니다. 이렇게 해도 두 번째 종류의 간선이 너무 많습니다.\n두 번째 최적화는 한 번에 한 주사위만 ?로 바꾸거나 굴리는 것입니다. 즉 다음과 같이 상태를 만듭니다.\n\n(1) 주사위가 모두 굴려진 상태\n(2) 모두 굴려진 후, 첫 $i$개의 주사위를 ?로 바꾸거나 바꾸지 않은 상태\n(3) ?를 모두 결정한 후, 첫 $i$개의 주사위가 굴려진 상태\n\n상태 개수는 어림잡아서 백만 단위로 나옵니다. 이제 (1)-&gt;(2)와 (2)-&gt;(2) 방향 전이의 개수는 상태 당 2개, (2)-&gt;(3) 방향 전이의 개수는 상태 당 $d$개로 상한이 잡히기 때문에, 충분히 계산을 돌릴 수 있을 만큼 간선 개수가 줄었습니다.\n","path":null},{"url":"https://jh05013.github.io/blog/enumerating-triangles/","title":"삼각형 찾기","description":null,"body":"단순 그래프의 정점의 개수를 $n$, 간선의 개수를 $m$이라고 합시다. 이 그래프에 있는 삼각형, 즉 길이 3의 사이클을 모두 찾을 수 있을까요?\n$O(\\frac{nm}{w})$\n간선 하나 $uv$를 고정하고, 그 간선을 포함하는 삼각형을 찾아봅시다.\n인접 행렬을 만듭니다. 그러면 $u$와 $v$에 인접한 모든 정점 $a$에 대해 삼각형 $uva$를 찾을 수 있습니다. 인접 행렬의 $u$행과 $v$행에서 둘 다 인접 표시가 된 열을 찾으면 됩니다. 시간 복잡도는 $O(nm)$입니다.\n이 과정을 비트셋의 교집합 연산으로 최적화하면 시간 복잡도 $O(\\frac{nm}{w})$에 모든 삼각형을 찾을 수 있습니다. 64비트 컴퓨터에서 $w = 64$입니다.\n연습문제\n\nBOJ 20501 Facebook\nABC258 Triangle\nBOJ 8907 네온 사인 / BOJ 8096 Monochromatic Triangles를 말그대로 붉은색, 파란색 삼각형을 직접 세서 풀 수 있습니다.\n\n$O(m \\sqrt m)$\n정점 $v$의 차수를 $\\deg(v)$라고 할 때, 다음 식을 생각해 봅시다.\n$$\\sum_{uv \\in E} \\min(\\deg(u), \\deg(v))$$\n이 값은 $O(m \\sqrt m)$입니다.\n증명. $\\sum_{v \\in V} \\deg(v) = 2m$이므로, $\\deg(v) \\geq \\sqrt m$인 정점은 많아야 $O(\\sqrt m)$개입니다. 그래프가 단순하므로, $\\min(\\deg(u), \\deg(v)) \\geq \\sqrt m$인 간선은 많아야 $O(m)$개입니다. 나머지 간선은 $\\min(\\deg(u), \\deg(v)) \\leq \\sqrt m$입니다. ■\n이제 정점을 차수 순으로, 동점일 경우 번호 순으로 정렬해서 위에서 아래로 늘어놓읍시다. 위 $v$에서 아래 $p$로 가는 간선을 $v \\downarrow p$라고 합시다.\n모든 간선 $v \\downarrow p$에 대해 간선 $pq$(위아래 상관없음)를 모두 찾을 수 있습니다. 예를 들면 아래와 같은 경우가 있습니다.\n\n그러한 $(v, p, q)$ 쌍은 $O(\\sum_{v \\rightarrow p \\in E} \\deg(p)) = O(m \\sqrt m)$개 존재합니다. $\\min(\\deg(v), \\deg(p)) = \\deg(p)$이기 때문입니다.\n따라서, 위에서 아래로 가는 $v \\downarrow p \\downarrow q$ 꼴의 경로도 당연히 모두 찾을 수 있습니다.\n이제 각 $v \\downarrow p \\downarrow q$에 대해 $q$와 $v$가 인접한지 확인하면 됩니다. 간단하게는 해시셋으로 구현할 수 있지만 이는 너무 무겁고, 다음과 같은 방법으로 진행할 수 있습니다.\n\n우선 크기 $n$의 배열 $A$를 초기화합니다.\n각 $v$에 대해…\n\n각 간선 $v \\downarrow p$에 대해 $A[p]$를 마킹합니다. 즉 $A[p]$는 “$p$가 $v$의 아래에 있으면서 인접하다“라는 뜻입니다.\n다시 각 간선 $v \\downarrow p$에 대해, 간선 $p \\downarrow q$들을 순회합니다. $A[q]$가 마킹되어 있다면 삼각형 $vpq$를 찾았습니다.\n다시 각 간선 $v \\downarrow p$에 대해 $A[p]$의 마킹을 지웁니다.\n\n\n\n각 삼각형은 $a \\downarrow b \\downarrow c$ 꼴의 경로를 정확히 하나씩 갖고 있으므로, 각 삼각형이 정확히 한 번씩 세어집니다. 총 시간 복잡도는 $O(m \\sqrt m)$입니다. 같은 방법으로 그래프에는 삼각형이 최대 $O(m \\sqrt m)$개 있음을 증명할 수 있습니다.\n연습문제\n\nLC Enumerate Triangles\nBOJ 1762 평면그래프와 삼각형을 평면그래프 조건 없이 풀 수 있습니다.\n\n추가 연습문제\nBOJ 14571 모래시계 in $O(m \\sqrt m)$\n모든 삼각형을 $O(m \\sqrt m)$에 찾습니다. 각 정점 $v$에 대해, $v$를 포함하는 삼각형 $vpq$에 대해 간선 $pq$의 목록을 저장해 둡니다.\n모래시계의 중심 $v$를 고정하고, $v$에 대한 간선 $pq$로 이루어진 부분그래프를 생각해 봅시다. 이 부분그래프의 간선 $e$개 중 두 개를 고르되 겹치는 정점이 없도록 하는 경우의 수를 구하면 됩니다. 첫 번째 간선 $ab$를 고르고, 나머지 간선 중 $a$ 또는 $b$와 이어지는 것을 모두 제외하면, 남은 간선의 개수는 $e - \\deg(a) - \\deg(b) + 1$입니다. 이때 $\\deg$는 부분그래프 기준입니다.\n부분그래프에서 차수를 관리하는 것은 위의 $A$ 배열과 같은 방식으로 진행할 수 있습니다.\n사각형의 개수\n삼각형뿐만 아니라 사각형도 셀 수 있습니다! 사각형은 최대 $O(m^2)$개 있을 수 있지만, 개수는 $O(m \\sqrt m)$에 구할 수 있습니다.\n메인 아이디어는 아래 그림과 같습니다. 사각형을 $v \\downarrow p \\rightarrow q$ 꼴의 경로 두 개로 분할할 수 있으니, 그런 형태의 경로를 세는 것입니다. 각 $v \\downarrow p$에 대해, $v$의 아래에 있으면서 $v$와 $p$에 인접한 정점 $q$의 개수를 $k_{vp}$라고 하면, 모든 $\\frac{k_{vq}(k_{vq}-1)}{2}$의 합을 구하면 됩니다.\n\n앞에서 보았듯이 $k_{vq} &gt; 0$인 $(v, q)$는 $O(m \\sqrt m)$개이고, 0보다 큰 모든 $k_{vq}$를 $O(m \\sqrt m)$에 구할 수 있습니다.\n위 과정을 조금 변형하면 각 정점을 포함하는 사각형의 개수도 셀 수 있습니다.\nBOJ 2390 ⎐\n제가 이 알고리즘을 배운 계기가 된 문제입니다. 검수하면서 풀이를 고민하다가 “사각형을 $O(M^2)$보다 빠르게 셀 수 없는데 어떻게 ⎐를 셀 수 있지?“라고 생각했는데, 사각형을 $O(M \\sqrt M)$에 셀 수 있더라고요…\n바로 위에서 보았듯이, 각 정점 $v$에 대해 $v$를 포함하는 사각형의 개수를 셉니다. 이제 ⎐에서 차수가 4인 정점을 “⎐의 중심“이라고 하면, 각 정점 $v$에 대해 $v$가 중심인 ⎐의 개수를 셉니다. 사각형의 개수에 $deg(v)-2$를 곱하면 됩니다.\n모든 $v$에 대해 위 값을 구하고 합하면, 놀랍게도 크기 5의 완전 그래프에서 출력이 60이 나옵니다. 왜냐하면 다음 🪁 모양 케이스를 제외하지 않았기 때문입니다.\n\n🪁를 세기 위해, 각 간선 $pq$에 대해 $pq$를 포함하는 삼각형의 개수를 셉니다. 그 후 각 간선 $pq$에 대해 $pq$가 사각형의 대각선인 🪁의 개수를 세줍니다. 삼각형의 개수를 $k$라고 할 때 $\\binom{k}{2} (deg(p)-3) (deg(q)-3)$이 답입니다.\n참고로 이 ⎐ 문양의 정체는 NPN open collector로, 전기회로에서 사용하는 문양입니다.\nBOJ 28200 4\n모든 삼각형을 찾습니다. 각 정점 $v$에 대해, $v$를 포함하는 삼각형 $vpq$에 대해 간선 $pq$의 목록을 저장해 둡니다.\n한 점 $v$를 고정하고, $v$에 대한 간선 $pq$로 이루어진 부분그래프를 생각해 봅시다. 이 부분그래프에서 삼각형의 개수를 세면 되는데, 대부분의 정점에 대해서는 부분그래프가 작을 것이기 때문에 비트셋으로 풀 수 있습니다. 자세한 내용은 에디토리얼을 참조하세요.\n참조\n\nPaul Burkhardt, David G. Harris, Simple and efficient four-cycle counting on sparse graphs\n\n","path":null},{"url":"https://jh05013.github.io/blog/wf2021/","title":"ICPC World Finals 2021 풀이","description":null,"body":"11월에 ICPC World Finals 2021에 참가했습니다.\n이후 11월 말까지 한 문제를 제외한 나머지를 모두 풀었고, 이 글에서 모든 문제의 풀이를 정리합니다.\n최근 3년과 달리 상대적으로 쉬운 (플래 하급 이하) 문제가 좀 더 많이 나왔는데,\n그것들을 푸느라 더 어려운 문제에 쓸 시간이 부족했습니다.\nA: Crystal Crosswind\n바람의 방향이 $(w_x, w_y)$, 가장자리의 집합이 $S$라고 하면 다음과 같은 정보를 얻습니다.\n\n(1) $(x, y) \\in S$일 경우, $(x, y)$은 분자고, $(x - w_x, y - w_y)$는 빈칸입니다.\n(2) $(x, y) \\notin S$일 경우, $(x, y)$가 빈칸이거나 $(x - w_x, y - w_y)$가 분자입니다.\n\n두 번째 조건은 “(2A) $(x, y)$가 분자면 $(x - w_x, y - w_y)$도 분자”,\n혹은 “(2B) $(x - w_x, y - w_y)$가 빈칸이면 $(x, y)$도 빈칸“과 동치입니다.\n먼저 분자가 가장 적은 경우부터 구해봅시다.\n우선 (1)로부터 무조건 분자여야 하는 칸이 정해집니다.\n그리고 (2A)로부터 추가로 무조건 분자여야 하는 칸이 어디인지 알 수 있습니다.\n(2A)를 반복적으로 적용시키다가 더 이상 무조건 분자여야 하는 칸이 안 생길 때가 바로 답입니다.\n나머지 모든 칸을 빈칸으로 둬도 모든 규칙이 만족되기 때문입니다.\n따라서 (2A)에 해당하는 각 칸 $(x, y)$에서 $(x - w_x, y - w_y)$로 간선을 긋고,\n(1)에 해당하는 칸들을 시작점으로 하여 그래프 순회를 해주면 됩니다.\n이때 각 칸이 적어도 한 번 방문되었을 경우 그 칸에는 분자가 있고, 아니면 빈칸입니다.\n분자가 가장 많은 경우도 비슷합니다.\n(1)로부터 무조건 빈칸이어야 하는 칸이 정해지고, 여기에 (2B)를 반복적으로 적용시켜야 합니다.\n하지만 여기서 끝나는 게 아니라, (3) 격자의 바깥은 전부 빈칸입니다.\n격자의 바깥에는 칸이 너무 많으니까 이걸 일일이 다 체크하지 말고, 여기다가 (2B)를 한 번 적용시켜서,\n각 칸 $(x, y)$에 대해 $(x - w_x, y - w_y)$가 격자 바깥이면 $(x, y)$를 빈칸으로 두면 됩니다.\n이제 (2B)에 해당하는 간선들을 긋고,\n(1)과 (3 + 2B)에 해당하는 칸들을 시작점으로 하여 그래프 순회를 해주면 됩니다.\n시간 복잡도는 $O(d_x d_y k)$입니다.\nB: Dungeon Crawler\n시작점을 루트로 잡읍시다.\n열쇠와 함정을 무시할 경우, 트리 순회를 하는데 가장 깊은 (루트에서 가장 먼) 점에서 멈추는 것이 최적입니다.\n따라서 답은 2*(간선 길이의 합) - (가장 깊은 점의 깊이)입니다.\n이제 함정과 열쇠가 있다고 합시다. 우선 함정이 열쇠의 조상이면 impossible입니다.\n아닐 경우, 가장 마지막으로 방문하는 정점이 d라고 합시다. 가장 깊은 점이 아닐 수도 있습니다.\n열심히 케이스 분석을 해보면서, 각 경로를 지나는 횟수를 아래 그림에서 빨간 글씨로 표시해보면\n다음과 같습니다.\n\n함정과 열쇠의 LCA를 $l$, 열쇠와 $d$의 LCA를 $z$라고 하면\n답은 2*(간선 길이의 합) - (d의 깊이) + 2*(z에서 l까지 거리)입니다.\n모든 $d$에 대해 이걸 계산하고 최솟값을 찾으면 됩니다.\n쿼리를 같은 시작점들끼리 묶어, 각 시작점마다 $O(n)$ 시간 전처리를 한 번씩 해줄 수 있다고 합시다.\n그 후 각 쿼리를 어떻게든 $O(n)$에 수행하면 $O(n^2 + qn)$이고, 이는 약 4억이므로 시간 내에 돌아갑니다.\n저기서 시간이 걸리는 요인은 (1) LCA 계산, (2) 거리 계산입니다.\n(1) LCA의 경우, 모든 정점과 열쇠의 LCA를 구하는 것이 문제입니다.\nLCA는 희소 배열 외에도 오일러 투어 + 구간 최솟값 쿼리로 풀 수 있음이 알려져 있습니다.\n이 구간 최솟값도 범위의 한쪽 끝이 정해져 있기 때문에,\n세그먼트 트리 같은 걸 쓸 필요 없이 그냥 범위를 하나씩 늘려 주면서 최솟값을 갱신하면\n전체 $O(n)$에 모든 LCA를 구할 수 있습니다.\n(2) 거리 계산의 경우, $z$와 $l$은 조상 관계이기 때문에 두 정점의 깊이의 차를 구하면 됩니다.\nC: Fair Division\n첫 번째 해적이 받는 금화의 비율은 $\\sum_{i=0}^{\\infty}(1-f)^{ni} = \\frac{1}{1-(1-f)^n}$입니다.\n$(j+1)$번째 해적이 받는 금화의 비율은 $\\frac{(1-f)^j}{1-(1-f)^n}$입니다.\n따라서 금화의 비는 $1 : (1-f) : \\cdots : (1-f)^{n-1}$입니다.\n$f = \\frac{p}{q}$이고 $p$와 $q$가 서로소라고 하면, 금화의 비는\n$q^{n-1} : q^{n-2}(q-p) : \\cdots : (q-p)^{n-1}$입니다.\n이 수들은 서로소이므로 $q^{n-1} + \\cdots + (q-p)^{n-1}$의 합이 $m$의 약수여야 합니다.\n그러려면 일단 $q^{n-1} \\leq m$이어야 되는데, $n-1 \\geq 5$이고\n$m \\leq 10^{18}$이기 때문에 $q \\leq 3981$까지만 보면 됩니다. (1000이 아닙니다!)\n오버플로우를 막으려면 저 $n$개 항을 통째로 합하는 게 아니라,\n하나하나 더하면서 $m$을 넘을 때 바로 끊어줘야 합니다.\n시간 복잡도는 $O(m^{2/(n-1)})$입니다.\nD: Guardians of the Gallery\n대회 당시 유일하게 아무도 못 푼 문제였습니다.\n아쉽게도 딱 한 테스트케이스에서 틀린 팀이 있었다고 합니다.\n우선 조각상이 보이는 영역을 구해야 합니다. 조각상에서 각 꼭짓점으로 반직선을 긋습니다.\n각 반직선에 대해, 그 반직선이 미술관의 어디까지 닿는지를 계산합니다.\n간단하게 생각하면 반직선과 각 선분의 교점을 구하고 가장 가까운 교점을 구하면 되는데,\n실제로는 반직선의 왼쪽과 오른쪽 영역이 모두 막히는 교점까지 가야 합니다.\n예를 들어 아래 그림에서 A 방향으로 그은 반직선은 A에서 끝나는 게 아니라\n오른쪽 영역까지 막히는 B까지 가야 합니다.\n각 선분이 어느 방향에서 교차하는지를 구하고, 교점을 가까운 순으로 정렬한 다음 하나씩 확인하면 됩니다.\n시간 복잡도는 $O(n^2)$이고, 이 다각형에는 변이 $O(n)$개 있습니다.\n\n이제 출발점에서 목표 영역까지 가는 최단거리를 구해야 합니다. 최단경로는 다음과 같은 형태입니다.\n(1) 우선 미술관의 꼭짓점 몇 개를 거치고, (2) 마지막에 목표 영역의 한 변에 수직인 방향으로 직진합니다.\n(1)은 출발점, 목표 영역의 꼭짓점 및 미술관의 꼭짓점들을 정점으로 잡고,\n서로 이동 가능한 정점 쌍을 이어 그래프를 만든 뒤 데이크스트라 알고리즘을 돌려서 구할 수 있습니다.\n정점 쌍이 서로 이동 가능한지 판별하려면 둘을 잇는 선분이 미술관의 각 변과 (끝점 제외하고)\n안 겹치는지 판별하면 됩니다. 시간 복잡도는 $O(n^3)$입니다.\n\n마지막으로, (2)는 각 정점에서 목표 영역의 각 변으로 수선을 긋고,\n마찬가지로 미술관의 각 변과 안 겹치는지 + 수선이 실제로 그 변과 만나는지 판별하면 됩니다.\n시간 복잡도는 $O(n^3)$입니다.\nE: Hand of the Free Marked\n우선 Fitch Cheney trick의 원본부터 분석해 봅시다.\n이 마술은 본질적으로 52개 카드 집합에서의 크기 5의 조합에서\n52개 카드 집합에서의 크기 4의 순열로 가는 일대일함수를 만드는 문제입니다.\n조교는 조합에서 순열로 함수를 적용하고, 마술사는 그 순열에서 다시 조합으로 역함수를 적용하는 것이죠.\n카드가 전체 $n$개이고 그중에서 $k$개를 뽑는다면,\n전자는 $A := \\frac{n!}{k!(n-k)!}$개이고, 후자는 $B := \\frac{n!}{(n-k+1)!}$인데,\n$A \\leq B$이면 일대일함수가 존재할 것 같이 생겼습니다.\n계산해보면 $n = k!+k-1$일 때 정확히 $A = B$이고,\n$n$이 그보다 커지면 $A &gt; B$라서 일대일함수가 존재할 수 없습니다.\n물론 순열을 이루는 카드 4개가 모두 조합에 속해야 하기 때문에,\n$A \\leq B$라고 해서 아무렇게나 일대일함수를 만들면 안 됩니다.\n다행히도 조건을 만족하는 일대일함수가 항상 존재합니다. 왜냐?\n전자와 후자를 잇는 이분그래프를 생각합시다. 카드가 많을 때 가능하다면 적을 때도 가능하니까,\n$n = k!+k-1$, $A = B$라고 합시다.\n이제 이 그래프에 완전 매칭이 존재함을 홀의 정리로 증명합니다.\n각 전자 조합은 정확히 $k!$개의 후자 순열과 인접하고, $A = B$니까\n각 후자 순열도 정확히 $k!$개의 전자 조합과 인접합니다.\n즉 이 그래프는 $k!$-regular graph입니다.\n이제 전자 조합을 $s$개 골랐다고 하면, 이 조합들은 $k!s$개의 간선과 연결되어 있기 때문에,\n적어도 $s$개의 후자 순열이 이 조합들과 인접해야 합니다.\n따라서 홀의 정리에 의해 완전 매칭이 존재합니다.\n$A &gt; B$일 경우, 마술이 성공할 확률은 $\\frac{B}{A}$입니다.\n함숫값이 가능한 한 안 겹치도록 함수를 만들었으면, 전자의 원소 중에서 함수를 취하고\n“역함수“를 취했을 때 자기 자신으로 돌아올 수 있는 원소가 $B$개이기 때문입니다.\n이제 이 문제에서는 카드가 너무 많아서, 덱에서 카드를 몇 개 뺄 생각은 안 하고\n카드에 마킹을 해놓아서 마술사가 마지막 카드의 마킹을 알 수 있습니다.\n얼핏 생각해보면 전자는 그대로 조합이고, 후자는 순열에다가 마킹 하나가 추가로 주어진 거니까\n그대로 $A$와 $B$를 구하면 될 것처럼 생겼지만,\n이러면 regular graph가 아니라서 위의 증명이 통하지 않습니다.\n그 대신, 마술사가 마지막만이 아니라 모든 카드의 마킹을 알 수 있다는 사실에 주목합시다.\n무슨 카드에 무슨 마킹이 있는지 외우면 그만이니까요.\n따라서 마킹의 조합은 마술사와 조교가 공유하는 정보입니다.\n그뿐만 아니라, 마킹의 조합을 고정하고 나면 원본 Fitch Cheney trick과 동일한 문제가 됩니다.\n마킹의 조합을 백트래킹으로 뽑아내고, 각 조합에 대해 그 조합이 실제로 뽑힐 확률과\n그 조합에서 마술이 성공할 확률을 곱하여 모두 더하면 답을 얻습니다.\n마킹의 조합의 개수는 $m$과 $k$의 중복조합인데, $m=k=10$일 때 이는 $\\binom{19}{10}=92378$이므로\n충분히 모두 뽑아낼 수 있습니다. 이제 각 마킹 $i$에 대해, 그 마킹이 된 카드가 전체 $A_i$개이고\n그중에서 $C_i$개를 뽑았다고 하면, 그 조합이 뽑힐 확률은\n$\\frac{1}{\\binom{n}{k}} \\prod \\binom{A_i}{C_i}$이고,\n그 조합에서 마술이 성공할 확률은\n$\\min(1, \\frac{1}{\\prod \\binom{A_i}{C_i}} (k-1)! \\prod \\binom{A_i}{C_i} \\sum_{C_i &gt; 0} \\frac{\\binom{A_i}{C_i - 1}}{\\binom{A_i}{C_i}})$ $= \\min(1, (k-1)! \\sum_{C_i &gt; 0}\\frac{C_i}{A_i - C_i + 1})$\n입니다.\n저는 여기에 log를 씌워서 계산한 다음 exp로 되돌리는 식으로 구현했는데,\nlong double도 안 되고 __float128까지 써야 $10^{-10}$ 정도의 절대오차로 통과했습니다.\n모범 코드는 double만 쓴 걸로 봐서 식을 어떻게 정리했느냐에 따라\ndouble로도 충분히 통과되는 것으로 보입니다.\n시간 복잡도는 $O(\\binom{m+k-1}{k}m)$입니다.\nFitch Cheney trick을 직접 선보이고 싶다면\n이 문제와\n이 문제를 풀어보시면 되겠습니다.\n참고로 간선이 너무 많아서 이분 매칭 알고리즘을 직접 돌리는 식으로는 풀 수 없고,\n매칭을 머리로 찾아내야 합니다.\nF: Islands from the Sky\n지문이 무서워 보이지만 (3차원 기하???),\n정작 읽어보면 대부분이 지문을 무서워 보이게 만드는 장치라고 느껴집니다.\n$\\theta$에 대해 이분탐색을 합니다. $\\theta$를 정하면 각 사다리꼴 영역이 정해집니다.\n비행기의 높이가 $h$이면 밑변의 길이는 $2h \\tan \\theta$이고,\n방향은 비행 경로를 90도씩 회전시켜서 구할 수 있습니다.\n이제 각 섬이 적어도 한 사다리꼴의 내부에 속하는지 판별합니다.\n사다리꼴은 볼록다각형이므로 섬의 모든 꼭짓점만 확인하면 됩니다.\n시간 복잡도는 $O((\\sum_{i=1}^n n_i) m\\log X)$입니다.\n저희 팀의 다른 팀원 분은 이분탐색 없이 풀었는데, 손 계산이 좀 들어갈 것 같습니다.\nG: Mosaic Browsing\n패턴과 격자의 높이가 1일 경우\n와일드카드 문자열 매칭\n문제와 동일하고, FFT로 풀 수 있습니다.\n이 문제에서는 격자에 와일드카드가 없으므로 $T_j$는 안 곱해도 됩니다. 계수가 꽤 큰 편이므로 주의하세요.\n높이가 2 이상일 경우, 그냥 격자를 일렬로 펴고 패턴에 와일드카드 패딩을 붙이면 높이 1 문제로 환원됩니다.\n예를 들어 예제는 이렇게 될 겁니다.\n물론 몇몇 인덱스는 격자에 안 맞기 때문에 매칭이 되어도 출력하지 말아야 합니다.\n\nbitset으로 푸는 방법도 있다고 합니다…\nH: Prehistoric Programs\nAtCoder Beginner Contest 167F와 같은 문제이고,\n다른 대회에서도 몇 번 나왔다고 합니다.\n심지어 2016년 월드 파이널 Swap Space와도 거의 같은 문제입니다!\n우선 주어진 문자열이 올바른 괄호 문자열인지 판별하는 문제를 생각해봅시다.\nPS를 입문할 때 접해보셨을 유명한 문제입니다.\n문자를 차례대로 보면서 (이면 카운터를 1 증가시키고 )이면 1 감소시킬 때,\n카운터가 단 한 번도 음수가 되지 않으면서 마지막에는 0이 되어야 합니다.\n이제 이 문제로 돌아와보면, 각 조각은 다음과 같은 정보로 표현할 수 있습니다.\n“이 조각을 사용하려면 카운터가 $x$ 이상이어야 하고, 사용하면 카운터가 $d$만큼 변한다.”\n모든 $d$의 합이 0이 아니면 당연히 impossible입니다. 이제 합이 0이라고 가정합시다.\n$d \\geq 0$인 조각들을 올라가는 조각, $d &lt; 0$인 조각들을 내려가는 조각이라고 합시다.\n그러면 먼저 올라가는 조각이 다 나오고, 그 다음에 내려가는 조각이 다 나와야 합니다.\n어떤 올바른 해에서 내려가는 조각 바로 다음에 올라가는 조각이 나왔다면\n그 둘을 교환해도 여전히 올바른 해가 되기 때문입니다.\n이 조건대로 나열하면 카운터는 올라가는 조각을 다 쓰면서 정점을 찍고 다시 내려가는 조각을 다 써서\n0으로 돌아오게 됩니다.\n그 정점을 기준으로 둘로 나누고, 내려가는 조각을 쓰는 과정을 뒤집으면,\n올라가는 조각을 쓰는 과정만 두 번 있는 형태가 됩니다.\n따라서 올라가는 조각만 쓰는 문제를 두 번 풀면 됩니다.\n이제 올라가는 조각들을 잘 정렬해야 되는데, 그 순서는 바로 $x$에 대한 오름차순입니다.\n어떤 올바른 해에서 $(x_1, d_1)$ 바로 다음에 $(x_2, d_2)$이 나오고 $x_1 &gt; x_2$라면,\n$(x_1, d_1)$을 쓰는 순간에 카운터는 $c \\geq x_1$인데,\n둘을 교환하면 $c \\geq x_1 &gt; x_2$, $c + d_2 \\geq c \\geq x_1$이라서\n여전히 올바른 해가 되기 때문입니다.\n이렇게 정렬했는데도 올바른 괄호 문자열이 안 되면 impossible이고,\n되면 그 순서를 그대로 출력해주면 됩니다.\nI: Spider Walk\n편의를 위해, 거미줄이 원형이 아니라 1번과 $N$번 가닥이 안 이어진 선형이라고 합시다.\n풀이는 거의 달라지지 않습니다. 이제 우리가 풀어야 하는 문제는 다음과 같습니다.\n\n사다리타기를 하는데, $i$번째 가닥에서 시작해서 $s$번째 가닥의 맨 밑에 도착하려고 합니다.\n그어야 하는 다리의 최소 개수를 각각의 $i$에 대해 구하세요.\n\n위에서 아래로 움직이면서 각 가닥으로부터 $s$번째 가닥까지 가는 게 아니라,\n거꾸로 아래에서 위로 움직이면서 $s$번째 가닥으로부터 각 가닥까지 간다고 생각합시다.\nDP[i][j]를, 첫 $i$개의 다리만 고려하고 나머지 다리를 자유롭게 그을 수 있을 때\n$j$번째 가닥에 오는 최소 비용이라고 합시다.\nDP[0][..]은 $s$를 시작으로 양옆으로 하나씩 늘어나는 형태일 것입니다.\n우선 DP[i][..]은 이웃한 DP 값들의 차이가 1 이하임을 염두에 둡시다.\n이웃한 DP 값이 2 이상 차이가 날 경우, 낮은 쪽에서 높은 쪽으로 다리를 이어주면\n더 좋은 해가 나오기 때문입니다.\nDP[i][..]가 계산되었을 때 DP[i+1][..]을 계산하려면,\n\ni번째 다리가 $a$와 $a+1$을 잇는다고 합시다.\nDP[i+1][a+1]과 DP[i+1][a]에 각각 DP[i][a]와 DP[i][a+1]을 넣고,\n나머지 DP[i+1][..] 값들은 DP[i][..]를 그대로 따라갑니다.\n두 DP 값이 교환되면서 이웃한 DP 값의 차이가 2가 될 수 있습니다.\n이 경우 높은 쪽을 하나 낮춰줍니다. 일단 DP[i+1][a]와 DP[i+1][a+1]만 낮춰줍시다.\n그런데 저 값들을 낮추면서 또 다른 이웃한 DP 값의 차이가 2가 될 수 있습니다.\n얘네들은 한꺼번에 낮춰줍시다. DP[i+1][a] = v라고 할 때, 각 DP[i+1][..]를 다시 계산합니다. DP[i+1][b]에는 현재 값과 v + (a에서 b까지의 거리) 중 최솟값을 넣으면 됩니다.\nDP[i+1][a+1] = v'도 마찬가지로 써서 각 DP[i+1][..]를 다시 계산합니다.\n\n여기까지 하면 $O(nm)$입니다.\n네 번째, 다섯 번째 과정에서 DP[i+1][b]들을 효율적으로 계산해야 합니다.\nv + (a에서 b까지의 거리)는 절댓값 함수이기 때문에, 기울기가 1 또는 -1인 일차함수 여러 개로 표현할 수 있습니다. 따라서 이는 세그먼트 트리 lazy propagation으로 최적화할 수 있습니다. Lazy 값을 (p, q)로 둬서 min(현재 값, x+p, -x+q)`을 표현하면 됩니다. 시간 복잡도는 $O(n + m \\log n)$입니다.\n이외에도 DP 값의 차이가 1인 이웃한 인덱스들을 그룹으로 묶어서 std::set으로 관리하는 풀이가 있습니다. 네 번째 과정에서 최대 하나의 그룹이 통째로 내려갈 것입니다. 따라서 내려갈 때 양옆의 그룹과 합쳐야 되면 합치고, DP 값을 교환할 때 그룹을 분리하는 식으로 구현할 수 있습니다.\nJ: Splitstream\n우선 각 노드에 들어가는 수의 개수를 계산합니다. 1번을 입력으로 받는 노드는 정확히 $m$개의 수를 받습니다. Split 노드는 자신이 입력으로부터 받은 양을 두 출력 노드에 대강 반씩 나눠줍니다. 정확한 양은 자신에 들어가는 수의 개수의 홀짝성에 따라 다릅니다. Merge 노드는 출력 노드에 자신이 두 입력으로부터 받은 양 만큼 넘겨줍니다. 이 모든 것은 재귀 DP를 돌리거나, 위상 정렬하고 그 순서대로 DP를 돌려서 구할 수 있습니다.\n쿼리를 처리하려면, $x$에서부터 입력 노드를 타고 거꾸로 거슬러 올라가면서 $k$를 관리하면 됩니다. 현재 보고 있는 입력이 split 노드의 출력일 경우 그 노드의 입력으로 올라가고, $k$는 대강 두 배가 됩니다. 정확한 양은 그 입력이 split 노드의 어느 방향 출력인지에 따라 다릅니다. Merge 노드일 때는 조금 복잡합니다. Merge 노드의 두 입력에 들어가는 수가 각각 $a$, $b$개라고 합시다. $k \\leq 2 \\times \\min(a, b)$라면, $k$의 홀짝성에 따라 어느 입력으로 올라가는지가 다르고 $k$는 대강 절반이 됩니다. 아니라면, 둘 중 개수가 큰 입력으로 올라가고 $k$는 $\\min(a, b)$만큼 감소합니다.\n거슬러 올라가다가 한 번이라도 $k$가 현재 입력에 있는 수의 개수를 넘어가면 none이고, 넘어가는 일 없이 1번 입력까지 올라갔으면 그 $k$를 그대로 출력하면 됩니다. $O(qn)$인데 $q$와 $n$이 모두 작기 때문에 시간 내에 잘 돌아갑니다.\nK: Take On Meme\n각각의 밈은 벡터로 볼 수 있습니다. 노드 $v$의 최종 밈으로 가능한 모든 벡터의 집합을 $S_v$라고 합시다.\n우선 벡터의 집합 $S$와 $T$에 대해,\n\n$-S = {-p : p \\in S}$, 즉 모든 벡터를 180도 뒤집은 집합,\n$S + T = {p+q : p \\in S, q \\in T}$, 즉 두 집합에서 하나씩 뽑아 합치는 모든 경우를 담은 집합이라고 합시다. 이를 “집합의 덧셈“이라고 합시다. 마찬가지로 3개, $\\cdots$, $k$개의 집합에 대해서도 덧셈을 정의할 수 있습니다.\n\n이제 $S_v$를 다음과 같이 계산합니다.\n\n리프 노드이고 해당하는 밈이 $p$일 경우, $S_v = { p }$입니다.\n자식 노드가 $1, \\cdots, k$라고 합시다. 어떤 $i$에 대해, $S_1, \\cdots, S_k$ 중 $S_i$만 그대로 두고 나머지를 $-S$로 뒤집은 다음, 그 집합들을 전부 더한 것을 $T_i$로 정의합니다. 이제 $S_v = \\bigcup_i T_i$입니다.\n\n참 쉽죠? 아쉽게도 밈이 9,000개를 넘는데, 이러면 절대로 문제를 풀 수 가없으니 출제자가 치명적인 약점을 남겨 놨죠. 이 문제의 치명적인 약점은 바로 좌표 범위와 차수가 작다는 것입니다. 우리는 결코 이 문제를 포기하지도, 실망시키지도, 마음 바꿔 버리고 떠나지도 않을 겁니다.\n사실 우리가 구해야 되는 건 $S_1$의 원소 중 원점에서 가장 먼 것입니다. 그러면 $S_v$의 원소를 다 들고 있지 말고, “원점에서 먼” 것들만 적당히 들고 있으면 되지 않을까요? 맞습니다. 각 벡터를 점으로 생각했을 때 볼록 껍질을 이루는 것들만 들고 있으면 됩니다. 그러니까 $S_v$는 그냥 벡터의 집합이 아니라 볼록다각형이라고 생각해도 충분합니다.\n볼록다각형으로 생각하면 둘을 더하는 것도 간편합니다. 이를 민코프스키 합이라고 하고, 선형 시간에 구할 수 있습니다. 합집합은 그냥 볼록 껍질 알고리즘을 아무거나 쓰면 됩니다.\n이렇게 하면 최적화가 매우 많이 된다는 건 짐작 가능하지만, 정확한 시간 복잡도를 구하기는 어렵습니다. 대충 어림잡아 봅시다.\n\n좌표 범위가 $X$일 때 볼록 다각형의 점의 개수는 $O(X^{2/3})$임이 알려져 있습니다.\n어떤 노드 $v$의 자식 노드가 $k$개이고, $v$ 서브트리 안에 리프 노드가 $f$개라고 하면, 좌표 범위는 $Xf$이므로 최종적으로 $O((Xf)^{2/3})$개의 점이 남고, 이는 $O(k \\log k(Xf)^{2/3})$ 정도에 계산할 수 있습니다.\n따라서 $S_1$은 $O(n \\log k(Xn)^{2/3})$ 정도에 계산할 수 있습니다.\n$n = 10^4, k = 100, X = 10^3$을 넣으면 약 32억이 나옵니다.\n서브트리가 작을 때는 $O((Xn)^{2/3})$개보다 훨씬 적은 점이 쓰이고, 서브트리가 클 때도 매번 최악의 케이스가 나오는 건 불가능에 가깝기 때문에, 실제로는 32억보다 훨씬 적은 연산이 들 것임을 짐작할 수 있습니다. 이론적으로도 더 작은 상한을 얻는 게 가능할 것 같습니다.\n\n실제로 돌려 보면 별다른 최적화를 하지 않아도 여유롭게 통과합니다. 제 구현은 약 200 ms가 걸립니다.\nL: Where Am I?\n각 시작점에서 출발했을 때 각 마커를 언제 방문하는지 계산합니다. 이 문제를 풀어보시면 좋습니다. $O(N^2M)$에 구할 수 있고, 사실 $O((NM)^2)$에 시뮬레이션 돌려서 계산해도 잘 짜면 시간 내에 돈다고 합니다. ($N$은 격자의 크기, $M$은 마커의 개수)\n각 시작점마다 그 방문 시각들을 정렬합니다. 그 후 그 목록들을 다시 한 번 사전순으로 정렬합니다. 예를 들면 이런 식으로 나올 겁니다. (정확한 수는 아니고 그냥 아무거나 쓴 겁니다.)\n\n(3, 3)과 (4, 1)을 처음으로 구별 가능한 시점은 7입니다. 6까지는 둘 다 마커를 1, 5에서 방문해서 서로 구별할 수 없지만, 7이 되면서 (3, 3) 쪽만 마커를 방문하기 때문입니다. 이를 일반화해보면, 목록이 $A$와 $B$인 두 지점을 구별 가능한 최초의 시점은 $A[i] \\neq B[i]$인 가장 작은 $i$에 대해 $\\min(A[i], B[i])$입니다.\n이 비교 과정을 모든 목록으로 확장해봅시다. 시점 0이 되면 (1, 3)과 (2, 4)가 나머지 전부와 구별이 됩니다. 이제 재귀적으로 (1, 3)과 (2, 4)를 구별하고, 나머지 전부를 서로 구별하면 됩니다.\n$solve(t, l, r)$을 현재 시각이 $t$일 때 $l$번째부터 $r$번째 목록까지 구별하는 함수라고 합시다. $l &gt; r$일 경우 할 게 없습니다. $l = r$일 경우 $l$번째 목록이 시각 $t$에서 유일하게 결정됩니다. $l &lt; r$일 경우, $l$번째 목록이 마커를 다시 방문하는 순간까지 시각을 올렸다가, 그 시각 $t’$에 마커를 방문하는 목록이 $l$부터 $k$번째라면, $solve(t’, l, k)$와 $solve(t’, k+1, r)$을 재귀적으로 호출해주면 됩니다.\n출력할 때 $y$ 순으로 먼저 비교해서 정렬해야 한다는 점을 주의하세요.\n","path":null},{"url":"https://jh05013.github.io/blog/shape-union/","title":"도형의 합집합과 넓이","description":null,"body":"\n도형의 불리언 연산이란, 여러 도형의 영역에 대한 집합 연산을 말합니다.\n두 원의 교집합의 넓이를 구하는 방법은 잘 알려져 있습니다.\n부채꼴 2개의 넓이를 합친 다음, 이등변삼각형 2개의 넓이를 빼는 방식으로 구할 수 있습니다.\n같은 방법으로 두 원의 합집합의 넓이도 구할 수 있습니다.\n하지만 원이 3개만 되어도 이런 “포함 배제” 접근을 하기 어렵습니다.\n이 글에서는 도형의 합집합 및 그 넓이를 구하는 일반적인 방법을 소개합니다.\n테두리 따기\n아래 그림에서 테두리가 갖고 있는 중요한 성질을 찾아봅시다.\n\n테두리는 도형의 둘레로 이루어져 있습니다.\n그런데 이뿐만이 아닙니다. 도형의 둘레 중 다른 도형의 내부에 포함되지 않는 부분만이 테두리가 됩니다.\n도형의 합집합의 테두리를 구하는 방법은 다음과 같습니다.\n\n도형 사이의 모든 교점을 구합니다.\n각 도형마다 둘레를 다른 도형들과의 교점으로 분할합니다. 분할한 각 부분을 “조각“이라고 부릅시다.\n\n위 그림에서 예를 들어보면, 맨 아래의 원은 네 조각으로 분할되어 있습니다.\n원의 경우, 교점들을 각도 순으로 정렬하면 됩니다.\n다각형의 경우, 우선 꼭짓점으로 분할하고, 각 변마다 그 위의 교점들을 정렬하면 됩니다.\n\n\n각 조각마다, 원래 자신이 속했던 도형을 제외하고 나머지 중 적어도 하나의 내부에 포함되는지 판별합니다.\n포함되지 않는다면 그 조각은 테두리의 일부가 됩니다.\n\n꼭 조각 전체를 생각할 필요는 없고, 조각 위의 한 점을 잡아서 점이 도형 내부에 속하는지 판별해도 됩니다.\n\n\n\n모든 도형이 원일 경우, 교점은 $O(n^2)$개이므로 조각도 $O(n^2)$개이고,\n각 조각이 테두리를 이루는지 $O(n)$에 판별할 수 있으므로 전체 시간 복잡도는 $O(n^3)$입니다.\nJava에서의 사용\nJava에는 이 기능이 내장되어 있습니다. 합집합만이 아니라 교집합, 차집합, 대칭차집합 등을 지원합니다.\n도형은 java.awt.geom에 있는 클래스 Path2D, Ellipse2D 등으로 만들고 Area로 관리합니다. 만든 Area의 테두리를 PathIterator로 따올 수도 있습니다.\n\n자세한 내용은 공식 문서를 참조하세요.\n넓이 구하기\n그린 정리(Green theorem)1는 닫힌 곡선에 대한 면적분을 선적분으로 바꿔주는 정리입니다.\n\n$C$를 조각마다 매끄러운 단순 닫힌 곡선이라고 합시다.\n\n“조각마다 매끄러운“은 무한 번 미분 가능한 곡선을 여러 개 이어붙인 형태를 의미합니다.\n“단순“은 자기 자신과 교차하지 않음을 의미합니다.\n“닫힌“은 출발했던 점으로 돌아옴을 의미합니다.\n이러한 곡선의 예로 원이나 단순다각형이 있습니다.\n단순다각형의 경우 선분이 무한 번 미분 가능한 곡선이고,\n그 선분을 여러 개 이어붙인 형태이기 때문에 조각마다 매끄러운 곡선입니다.\n\n\n$D$를 그 곡선의 내부 영역이라고 합시다.\n$L$과 $M$이 $(x, y)$에 대한 함수라고 합시다. 여기에도 조건이 더 붙지만 이 글에서는 필요하지 않습니다.\n\n그러면 $C$를 반시계 방향으로 돌면서 선적분($\\oint$)을 한다고 할 때 다음이 성립합니다.\n$$\n\\oint_C(L\\ dx+ M\\ dy) =\n\\iint_D(\\frac{\\partial M}{\\partial x} - \\frac{\\partial L}{\\partial y}) \\ dx \\ dy\n$$\n이것으로 면적을 어떻게 구할 수 있을까요? 면적은 다음과 같습니다.\n$$\n\\iint_D 1 \\ dx \\ dy\n$$\n따라서 $\\frac{\\partial M}{\\partial x} - \\frac{\\partial L}{\\partial y} = 1$이 되도록\n$M$과 $L$을 잡아주면 됩니다.\n대표적으로 $M = \\frac{x}{2}$, $L = -\\frac{y}{2}$를 사용하고, 이때 그린 정리는 이렇게 바뀝니다.\n$$\n\\frac{1}{2} \\oint_C(x\\ dy - y\\ dx) =\n\\iint_D 1 \\ dx \\ dy\n$$\n이제 우리가 원하는 곡선 $C$를 잡아준 다음 선적분을 열심히 계산하면 됩니다.\n원 하나\n우선 중심이 $(x_c, y_c)$, 반지름이 $r$인 원 하나의 넓이를 구해봅시다.\n그러려면 $C$를 $\\theta$에 대한 매개변수 곡선으로 나타내면 됩니다.\n즉 $x = x_c + r \\cos \\theta$, $y = y_c + r \\sin \\theta$, $0 \\leq \\theta &lt; 2 \\pi$입니다. 이제,\n\n연쇄 법칙(chain rule)에 의해 $\\oint (x\\ dy - y\\ dx) = \\oint (x \\frac{dy}{d\\theta} d\\theta - y \\frac{dx}{d\\theta} d\\theta)$\n$\\frac{dy}{d\\theta} = r \\cos \\theta$\n$\\oint x \\frac{dy}{d\\theta} d\\theta = \\oint (x_c + r \\cos \\theta)(r \\cos \\theta) d\\theta = r \\oint (x_c \\cos \\theta + r \\cos^2 \\theta) d\\theta$\n$-\\oint y \\frac{dx}{d\\theta} d\\theta = \\oint (y_c + r \\sin \\theta)(r \\sin \\theta) d\\theta = r \\oint (y_c \\sin \\theta + r \\sin^2 \\theta) d\\theta$\n$\\frac{1}{2} \\oint (x \\frac{dy}{d\\theta} d\\theta - y \\frac{dx}{d\\theta} d\\theta) = \\frac{r}{2} \\oint (x_c \\cos \\theta + y_c \\sin \\theta + r) d\\theta$\n\n따라서 적분 결과는 $\\frac{r}{2}(x_c \\sin \\theta - y_c \\cos \\theta + r\\theta) + C$입니다.\n실제로 $\\theta$에 $0$과 $2\\pi$를 넣어서 빼보면 원의 넓이인 $\\pi r^2$만 남는 것을 확인할 수 있습니다.\n한편, $a \\leq \\theta \\leq b$에 해당하는 부채꼴 영역의 넓이를 구하려고\n$\\theta$에 $a$와 $b$를 넣어서 빼보면 이상한 값이 나오는데,\n이는 부채꼴 영역이 호 하나만 있는 게 아니라 선분 두 개가 더 있기 때문입니다.\n따라서 선분에 대해서도 선적분을 해줘야 합니다. 이에 대해서는 후술합니다.\n원 두 개\n테두리가 호 두 개로 이루어져 있다고 해봅시다.\n그러면 각각의 호를 매개변수 곡선으로 생각할 수 있습니다.\n호의 매개변수 곡선은 위와 별반 다르지 않습니다.\n방정식은 원과 같은데, $\\theta$의 범위만 다릅니다.\n이제 그린 정리를 여기에도 적용하려면 매개변수 곡선 두 개를 이어붙여\n하나의 매개변수 곡선으로 만들어야 합니다.\n그러려면 곡선의 방정식을 어떻게 바꿔야 할까요?\n안 바꿔도 됩니다.\n좀 더 단순화해서, 함수 $y = f_1(x)$ ($l_1 \\leq x \\leq r_1$), $y = f_2(x)$ ($l_2 \\leq x \\leq r_2$)\n두 개를 이어붙여 만든 함수 ($l_1 \\leq x \\leq r_1 + r_2 - l_2$)를 적분한다고 해봅시다.\n그러면 그 함수는\n\n$x \\leq r_1$이면 $y = f_1(x)$\n아니면 $y = f_2(x - r_1 + l_2)$\n\n가 됩니다. 그런데\n$\\int_{r_1}^{r_1 + r_2 - l_2} f_2(x - r_1 + l_2) dx = \\int_{l_2}^{r_2} f_2(x) dx$라서,\n그냥 두 함수를 따로 적분하고 합하면 됩니다.\n직관적으로, 함수를 $x$ 방향으로 평행이동한 것이라서 적분값이 달라질 리가 없습니다.\n매개변수 곡선도 마찬가지입니다.\n곡선들을 모아 하나의 큰 곡선으로 만들 필요 없이, 곡선 각각을 적분하고 합치면 됩니다.\n원 여러 개\n원이 여러 개 있을 때로 절차를 확장하면 다음과 같습니다.\n\n원의 합집합의 테두리를 이루는 호를 모두 구합니다.\n각 호에 대해 그린 정리를 적용해서 합칩니다.\n\n네, 이게 끝입니다. 매우 복잡한 디테일이 있을 것 같이 생겼지만 그렇지 않습니다.\n첫째로 들 수 있는 의문점은 “테두리를 ‘순서대로’ 따라가면서 적분해야 하지 않나?“일텐데요,\n그렇지 않습니다. 테두리의 모든 부분을 한 번씩 지나가기만 하면 됩니다.\n즉, 적분을 할 호를 선택하는 순서는 중요하지 않습니다.\n둘째로 “구멍이 있으면 이상해지지 않을까?“라는 의문이 들 수 있습니다.\n다행히도 구멍이 얼마나 있든 넓이는 잘 계산됩니다.\n왜냐하면 그 구멍은 시계방향으로 돌게 되어서, 자연스럽게 음의 넓이로 계산되기 때문입니다.\n아래 그림에서 빨간색 테두리는 반시계방향으로 도는 부분, 파란색 테두리는 시계방향으로 도는 부분입니다.\n원의 둘레를 반시계방향으로 돌 때 파란색 테두리에서 어떻게 되는지 확인해 보세요.\n\n선분이 포함된 도형\n다각형이나 부채꼴처럼 둘레에 선분이 포함될 경우,\n꼭짓점을 기준으로 분할해서 선분 단위로 생각하면 편합니다.\n선분은 매개변수 곡선 $x = x_c + v_x t$, $y = y_c + v_y t$, $0 \\leq t \\leq 1$로 표현할 수 있습니다.\n\n연쇄 법칙(chain rule)에 의해 $\\oint (x\\ dy - y\\ dx) = \\oint (x \\frac{dy}{dt} dt - y \\frac{dx}{dt} dt)$\n$= \\oint(v_y (x_c + v_x t)dt - v_x (y_c + v_y t)dt)$\n$= \\oint(v_y x_c - v_x y_c)dt$\n$= (v_y x_c - v_x y_c)t + C$\n\n$t$에 0과 1을 넣어서 빼면 그냥 $v_y x_c - v_x y_c$가 됩니다.\n문제 풀이\nBOJ 17804\nBOJ 17804 Knocked Ink는 잉크가 원형으로 퍼질 때,\n합집합의 넓이가 특정 값이 되는 순간을 구하는 문제입니다.\n원의 합집합의 넓이는 시간에 따른 증가함수이기 때문에 이분탐색으로 답을 구할 수 있습니다.\nojuz 색종이\nojuz 색종이는 색종이를 놓을 때마다\n각 색종이가 보이는 영역의 넓이를 구하는 문제입니다.\n서브태스크 1에서는 모든 색종이가 원이고, 2에서는 원 또는 삼각형입니다.\n$A_{i,j}$를 첫 $i$개의 색종이를 놓았을 때 $j$번째 색종이가 보이는 영역의 넓이라고 합시다.\n즉 우리가 구해야 하는 값은 모든 $A_{i,j}$입니다.\n$i = j$일 때는 그냥 도형 하나의 넓이를 구해주면 됩니다.\n$S_{l,r}$을 $l$번째부터 $r$번째까지의 색종이를 놓았을 때 전체 영역의 넓이라고 합시다.\n그러면 $i &lt; j$일 때 $A_{i,j} = S_{j,i} - S_{j+1,i}$입니다.\n모든 $A$ 값 대신에 모든 $S$ 값을 구해줍시다.\n일단 색종이를 다 놓은 다음 모든 도형의 둘레를 조각으로 나눕니다.\n그 다음 각 조각 및 모든 $l \\leq r$에 대해,\n그 조각이 $S_{l,r}$의 테두리를 이룰 경우 그 조각에 대한 적분값을 $S_{l, r}$에 더합니다.\n도형 $k$로부터 나온 조각 하나가 $S_{l,r}$의 테두리를 이루려면\n\n물론 $l \\leq k \\leq r$이어야 합니다.\n도형 $k$를 놓는 순간 그 조각이 테두리에 있어야 합니다.\n즉 도형 $l, \\cdots, k-1$ 바깥에 그 조각이 있어야 합니다.\n도형 $r$을 놓을 때까지 그 조각이 테두리에 남아있어야 합니다.\n즉 도형 $k+1, \\cdots, r$ 바깥에 그 조각이 있어야 합니다.\n\n$S_{l, r}$에 대한 표를 그려본다고 생각하면 각 조각이 영향을 미치는 $S$들은 직사각형을 이루기 때문에,\n누적합으로 각 $S$를 계산할 수 있습니다.\n주의할 점은 여러 조각이 완전히 일치할 수도 있다는 것입니다.\n예를 들어 두 원이 완전히 일치하거나, 두 삼각형의 둘레가 선분으로 겹칠 수 있습니다.\n이 경우 나중에 나타난 조각이 우위를 점하고 이전에 나타난 조각은 사라집니다.\n그래서 각 조각이 $S_{l,r}$의 테두리를 이루는지 판별할 때 주의를 기울여야 합니다.\n아쉽게도 서브태스크 1만 해도 구현량이 상당하기 때문에\n서브태스크 1 코드만 첨부합니다.\nBOJ 9598\nBOJ 9598 Cleaning the Hallway는\n도넛의 합집합의 넓이를 구하는 문제입니다.\n도넛의 바깥쪽 원은 반시계방향으로 돌고, 안쪽 원은 시계방향으로 돌면 됩니다.\n나머지는 원의 합집합과 동일합니다. 교점을 구하고 조각으로 나눈 다음 그린 정리를 써주되,\n테두리를 구할 때는 조각이 도넛의 안에 속하는지 판별하면 됩니다.\n참고로 전 안 풀었습니다.\n관련 문제\n\nBOJ 17804 Knocked Ink\nBOJ 10900 Lonely mdic\nCF 107E Darts\nojuz 색종이의 서브태스크 1\nBOJ 9598 Cleaning the Hallway\nBOJ 19368 Circular Sectors (왜 이런 문제를…)\nBOJ 11392 색종이\n(즉 위에 있는 ojuz 색종이의 서브태스크 2를 풀면 됩니다.)\n\n참고 자료\n\nArea of union of circles (Codeforces)\nBoolean operations on polygons (Wikipedia)\n\n\n\n\n이 정리를 만든 수학자 George Green을 따서 이름이 붙었습니다. ↩\n\n\n\n","path":null},{"url":"https://jh05013.github.io/blog/boj18796/","title":"BOJ 18796 이동하기 4","description":null,"body":"https://acmicpc.net/problem/18796\n\n예제 입력 1과 각 이동의 비용을 그림으로 나타내면 위와 같습니다.\n출력은 $10 + 20 + 20 + 20 + 70 = 140$입니다.\n문제의 재구성\n먼저, 생각하기 쉽도록 문제를 조금 변형해 봅시다.\n맨 처음에 경로 하나가 주어집니다. 이 경로는 아래로 쭉 이동한 다음 오른쪽으로 쭉 이동합니다.\n\n이 경로가 아래, 오른쪽 순서로 지나간 칸이 있으면\n이 칸을 오른쪽, 아래 순서로 지나가도록 경로를 변경할 수 있습니다.\n이때 경로의 비용도 변화하는데, 그 변화량은\n인접한 두 $B_c$ 값의 차와 인접한 두 $A_r$ 값의 차를 합하여 계산할 수 있습니다.\n\n이제 문제는 이렇게 바뀝니다.\n\n격자가 있습니다. 칸 $(x, y)$를 칠하는 비용은 $Cost[x,y] := R[x] + C[y]$입니다.\n몇 개의 칸을 색칠할 건데, 색칠한 칸은 첫 열부터 마지막 열까지 높이가 단조감소하는 히스토그램을 이루어야 합니다.\n비용을 최소화하세요.\n편의를 위해, 비용이 최소이더라도 칸을 더 칠하면서 비용을 유지시킬 수 있다면 최적해가 아니라고 간주합시다.\n\n이 최소 비용을 계산한 다음, 초기 경로의 비용에 더하면 원래 문제의 답을 얻습니다.\n\n예제 입력 1을 히스토그램 버전으로 재구성하면 위와 같이 됩니다.\n$R$은 (-70, 40), $C$는 (80, -10, -10)입니다.\n이 문제의 최적해는 아래 세 칸을 칠하는 것으로 -150의 비용이 들고,\n초기 경로의 비용은 $10 \\times 2 + 90 \\times 3 = 290$이므로 출력은 $290 - 150 = 140$입니다.\n몇 가지 관찰\n우선 첫 번째 열부터 봅시다. 최적해에서 첫 번째 열의 높이가 $i$라고 합시다.\n즉 $(1, 1), (2, 1), \\cdots, (i, 1)$을 칠했고 $(i+1, 1)$은 칠하지 않은 상태입니다.\n그러면 다음이 성립합니다.\n\n$Cost[i+1, 1] &gt; 0$. 안 그러면 $(i+1, 1)$을 칠하지 않을 이유가 없습니다.\n만약 두 번째 열이 $i$층을 칠하지 않았다면, $Cost[i, 1] \\leq 0 \\wedge Cost[i, 2] &gt; 0$.\n첫 번째 부등식이 성립하지 않으면 $(i, 1)$을 지우는 것이 더 좋고,\n두 번째 부등식이 성립하지 않으면 $(i, 2)$를 칠하는 것이 더 좋습니다.\n만약 두 번째 열도 $i$층을 칠했다면, $Cost[i+1,1] + Cost[i+1,2] &gt; 0$.\n안 그러면 $(i, 1)$과 $(i, 2)$를 칠하지 않는 것이 더 좋습니다.\n\n\n일반화\n이를 일반화해봅시다. 만약 1, 2, 3, …, $k$번째 열이 정확히 $i$층까지 칠했고 $k+1$번째 열이 $i$층을 칠하지 않았다면,\n\n$Cost[i, 1] + \\cdots + Cost[i, k] \\leq 0$.\n안 그러면 $(i, 1), \\cdots, (i, k)$를 지우는 것이 더 좋습니다.\n$Cost[i+1, 1] + \\cdots + Cost[i+1, k] &gt; 0$.\n안 그러면 $(i+1, 1), \\cdots, (i+1, k)$를 칠하는 것이 더 좋습니다.\n\n\n그러면 무엇을 알 수 있나요?\n두 부등식을 정리하면 $kR[i] + C[1] + \\cdots + C[k] \\leq 0 &lt; kR[i+1] + C[1] + \\cdots + C[k]$이므로,\n$R[i] &lt; R[i+1]$임을 알 수 있습니다.\n히스토그램을 어떻게 칠하든 위에서 제시한 $k$는 반드시 존재하므로,\n이는 **최적해의 첫 번째 열이 정확히 $i$층까지 칠했다면 $R[i] &lt; R[i+1]$**임을 의미합니다.\n그리고 이 관찰은 꼭 첫 번째 열에서만 적용되는 건 아닙니다.\n**최적해의 어느 열이 정확히 $i$층까지 칠했을 경우, $R[i] &lt; R[i+1]$**입니다.\n반대로 말하면, $R[i] \\geq R[i+1]$이면 $i$층에서 멈출 일이 없습니다.\n즉 어떤 열이든 i층을 칠하면 i+1층도 반드시 칠해야 합니다.\n그러므로 i층을 지웁시다\n$R[i] \\geq R[i+1]$이라면 $i$층과 $i+1$층을 아예 “합체“해줍시다. 즉\n\n기존의 $R$ 배열이 $[R[1], \\cdots, R[i], R[i+1], R[i+2], \\cdots, R[N]]$이었다면,\n새로운 $R$ 배열은 $[R[1], \\cdots, R[i] + R[i+1], R[i+2], \\cdots, R[N]]$이 됩니다.\n\n그런데 이렇게 그냥 합체해 버리면 칸을 칠하는 비용이 전과 맞지 않게 됩니다.\n왜냐하면 합체 전에 $(i, 1)$과 $(i+1, 1)$을 칠하는 비용은 $R[i] + R[i+1] + 2C[1]$이었는데,\n합체 후에 $(i, 1)$을 칠하는 비용은 $R[i] + R[i+1] + C[1]$이기 때문입니다.\n해결 방법\n이를 해결하기 위해, 각 층마다 높이 값을 도입합니다. $i$층의 높이를 $H[i]$라고 할 때,\n$Cost[i, j] := R[i] + H[i]C[j]$로 정의하고, 두 층을 합칠 때는 $R$과 $H$ 값을 모두 합치면 됩니다.\n\n몇 가지 관찰 v2\n이제 위에서 본 그리디 전략을 다시 적용해 봅시다.\n만약 1, 2, 3, …, $k$번째 열이 정확히 $i$층까지 칠했고 $k+1$번째 열이 $i$층을 칠하지 않았다면,\n\n$Cost[i, 1] + \\cdots + Cost[i, k] = kR[i] + H[i]\\mathscr{C} \\leq 0$ ($\\mathscr{C} := C[1] + \\cdots + C[k]$).\n$Cost[i+1, 1] + \\cdots + Cost[i+1, k] = kR[i+1] + H[i+1]\\mathscr{C} &gt; 0$.\n\n따라서 $k \\frac{R[i]}{H[i]} + \\mathscr{C} \\leq 0 &lt; k \\frac{R[i+1]}{H[i+1]} + \\mathscr{C}$이므로,\n$\\frac{R[i]}{H[i]} &lt; \\frac{R[i+1]}{H[i+1]}$입니다.\n같은 이유로, $\\frac{R[i]}{H[i]} \\geq \\frac{R[i+1]}{H[i+1]}$이면\n$i$층과 $i+1$층을 합체해줄 수 있습니다.\n어떻게 합체해야 하는가?\n이제 우리가 할 일은 $\\frac{R[i]}{H[i]} \\geq \\frac{R[i+1]}{H[i+1]}$인\n$i$를 찾아 합체하는 과정을 이러한 $i$가 존재하지 않을 때까지 반복하는 것입니다.\n그런데 이러한 $i$가 여러 개라면 무엇을 먼저 합체해야 할까요?\n그 답은… 상관없습니다. 어떤 순서로 합체를 하더라도 최종적으로는 똑같은 배열이 됩니다.\n왜일까요? $H$의 누적합을 $x$좌표, $R$의 누적합을 $y$좌표로 두고 점을 찍어봅시다.\n\n각각의 $H[i]$, $R[i]$ 쌍은 $i$번째와 $i+1$번째 점을 잇는 선분에 해당되고,\n어떤 $i$에 대해 $i$번째 선분의 기울기가 $i+1$번째 선분의 기울기보다 크거나 같으면\n$i+1$번째 점을 제거할 수 있습니다. 최종적으로는 선분들의 기울기가 단조증가하게 됩니다.\n따라서, 어떤 순서로 합체를 하더라도 결국에는 아래로 볼록한 볼록 껍질만 남습니다.\n합체 과정은 monotone chain 알고리즘처럼 스택으로 구현할 수 있습니다.\n\n이렇게 분수를 직선의 기울기로 생각하는 발상은 이 문제, 이 문제, 이 문제 등에서도 쓸 수 있습니다.\n열 합체\n지금까지의 논리를 $C$에도 적용할 수 있습니다.\n각 열마다 너비 $W[j]$ 값을 도입하고, $Cost[i, j] := R[i]W[j] + C[j]H[i]$로 정의한 뒤,\n$\\frac{C[j]}{W[j]}$ 값이 단조증가하도록 열을 합쳐 줍시다.\n거의 다 왔습니다!\n분해\n이제 아주 중요한 일이 일어납니다.\n볼록 껍질의 둘레를 따라 각 $x$좌표마다 다시 점을 찍어서 볼록 껍질을 다시 $N$개의 선분으로 분해해 봅시다.\n\n그러면 볼록 껍질은 바뀌지 않았기 때문에 최적해도 바뀌지 않습니다.\n선분들의 기울기는 여전히 단조증가합니다.\n그런데 이제 모든 $H[i]$가 1이기 때문에, 이는 $R[i]$가 단조증가함을 의미합니다.\n마찬가지로 모든 $W[j]$가 1이면서 $C[j]$도 단조증가하도록 바꿀 수 있습니다.\n답을 바꾸지 않으면서 $R$과 $C$가 단조증가한다는 매우 강력한 조건을 추가한 것입니다.\n마무리\n이제 나머지는 간단합니다. $Cost[i, j] &gt; 0$이라면\n$Cost[i+1, j]$와 $Cost[i, j+1]$도 모두 양수이기 때문에,\n$Cost[i, j] \\leq 0$인 모든 $(i, j)$는 높이가 단조감소하는 히스토그램의 형태를 갖습니다.\n따라서 그 히스토그램이 그냥 최적해입니다.\n히스토그램 및 비용은 투 포인터와 누적합으로 찾을 수 있습니다.\n","path":null},{"url":"https://jh05013.github.io/blog/boj5811/","title":"IOI 2012-1-2 낙하산 고리들","description":null,"body":"https://www.acmicpc.net/problem/5811\n서브태스크 1\n각각의 정점이 중요한 고리인지 O(N)에 확인하면 됩니다.\n즉, 해당 정점을 지웠을 때 나머지가 체인으로 구성되어 있는지 확인하면 됩니다.\n가장 간단한 방법은 다음 조건을 검사하는 것이라고 생각됩니다.\n\n포레스트여야 합니다. 즉, 사이클이 없어야 합니다.\n모든 정점의 차수가 2 이하여야 합니다.\n\n서브태스크 2, 3\nCountCritical이 호출될 때마다 모든 중요한 고리를 O(N)에 찾는 것이 목표입니다.\n관찰 1. 정점을 지우면 나머지 정점의 차수가 최대 1 감소합니다.\n따라서, 차수가 4 이상인 정점 v가 있으면 v만 중요한 고리가 될 수 있습니다.\nv가 아닌 정점을 지우면 v의 차수는 3 이상이라서 절대로 체인을 이룰 수 없기 때문입니다.\n차수가 4 이상인 정점이 있으면 그중 아무거나 하나를 잡고 중요한 고리인지 확인하면 됩니다.\n따라서 O(N)에 풀립니다.\n(그런 정점이 여러 개면 아무 것도 중요한 고리가 될 수 없지만, 그 경우를 따로 처리할 필요는 없습니다.)\n이제 그런 정점이 없다고 가정합시다.\n관찰 2. 차수가 3인 정점 v가 있으면 v 및 v에 인접한 정점만 중요한 고리가 될 수 있습니다.\n차수가 3인 정점이 있으면, 그중 아무거나 하나를 잡고 그 정점 및 그에 인접한 정점 3개를 확인하면 됩니다.\n후보가 4개이므로 O(N)에 풀립니다.\n이제 그런 정점도 없다고 가정합시다.\n모든 정점의 차수가 2 이하이면, 모든 연결 요소는 체인이거나 사이클입니다.\n관찰 3. 사이클이 있으면 그 사이클에 있는 정점만 중요한 고리가 될 수 있습니다.\n연결 요소 중 사이클이 없으면 답은 N, 하나이면 답은 그 사이클의 크기와 같고, 두 개 이상이면 답은 0입니다.\n따라서 직접 정점을 지워볼 필요 없이 답을 그래프의 구조만 보고 알아낼 수 있습니다.\n이번에도 O(N)에 풀립니다.\n서브태스크 4, 5\n간선을 추가하면서 위의 세 가지 관찰을 동적으로 관리하는 것이 목표입니다.\n관찰 3부터 시작해서 거꾸로 올라가는 것이 좋습니다.\n관찰 3 최적화\n차수가 3 이상인 정점이 생기지 않는다는 가정 하에 답을 동적으로 관리하려면 분리 집합을 사용하면 됩니다.\n분리 집합에 크기까지 추가로 저장해 둡시다. 이제 답은 두 단계에 걸쳐 바뀌는데,\n\n처음에는 답이 N입니다.\n이미 연결된 두 점이 연결될 경우 사이클이 하나 형성됩니다.\n사이클이 처음으로 형성될 경우, 답은 해당 연결 요소의 크기와 같습니다.\n이미 연결된 두 점이 또 연결될 경우 답은 0입니다.\n\n그러다가 차수가 3인 정점이 생기는 순간, 이 자료구조를 파기하고 아래의 “관찰 2 최적화”\n단락으로 넘어가면 됩니다. 정점의 차수는 그냥 배열로 관리하면 됩니다.\n관찰 2 최적화\n이제 새로운 자료구조를 생각해야 합니다.\n후보가 최대 4개니까, 각각의 후보에 대해 “이 후보를 지웠을 때 나머지가 체인을 이루는가“를\n판별할 수 있으면 좋을 것입니다. 즉 후보 v가 실제로 중요한 고리인지 확인하려면\n\nv와 연결된 간선을 모두 지우고,\n나머지가 포레스트를 이루면서 최대 차수가 2인지 확인하고,\n지운 간선을 모두 복원하면 됩니다.\n\n하지만 간선을 지우는 건 일반적으로 매우 어려운 작업입니다.\n이를 해결하려면 그 4개의 후보가 한 번 정해진 후로 바뀌지 않는다는 점을 활용하면 됩니다.\n(정확히는, 바꿀 필요가 없습니다.) 후보를 a, b, c, d라고 합시다.\n간선을 하나 추가할 때마다 a를 지우고 확인한 다음 도로 추가하지 말고,\n애초부터 a를 미리 지워놓고 간선이 추가될 때마다 확인해 줍시다. b, c, d도 마찬가지입니다.\n즉 다음과 같은 자료구조를 a, b, c, d 하나씩 총 4개 만들면 됩니다.\n\n이 자료구조는 특정 정점 v를 무시합니다.\n간선을 추가하려고 할 때, 간선의 양끝 점 중 하나가 v이면 무시합니다.\n그래프 전체가 체인으로 이루어져 있는지 검사합니다.\n이는 서브태스크 1에서 제시한 방법을 쓰면 분리 집합으로 구현할 수 있습니다.\n\n이 자료구조를 새로 만드는 순간, 지금까지 나왔던 Link 쿼리들을 전부 이 자료구조에 적용시켜야 합니다.\n관찰 3에서 쓴 자료구조에서 Link 쿼리들을 저장해 뒀다가, 관찰 2로 넘어갈 때 그대로 Link해주면 됩니다.\n관찰 1 최적화\n관찰 1은 구현할 필요도 없습니다. 차수가 4 이상인 정점이 있든 없든\n후보는 위에서 정한 a, b, c, d 중에 있다는 사실은 바뀌지 않습니다.\n서브태스크 2, 3에서 관찰 1이 필요했던 이유는\n차수가 매우 큰 정점에다가 그와 인접한 정점까지 다 확인하면 후보가 O(N)개나 되기 때문인데,\n이미 관찰 2를 최적화하면서 후보를 O(1)개로 좁혀 버렸기 때문에 관찰 1은 이제 필요가 없습니다.\n각 쿼리에 대한 시간 복잡도는 amortized O(logN)입니다.\n","path":null},{"url":"https://jh05013.github.io/blog/boj22906/","title":"BOJ 22906 장난감 오렌지 만들기","description":null,"body":"https://www.acmicpc.net/problem/22906\n서브태스크 1\n사실 이 문제는 그래프로 모델링할 수 있습니다.\n연결 고리의 색이 a, b인 블록은 정점 a와 b를 잇는 간선으로 보면,\n각 쿼리는 정확히 l번째부터 r번째까지의 간선만으로 만들어진 그래프를\n최소 개수의 회로(circuit)로 분할하는 문제가 됩니다.\n모든 정점의 번호가 1 이상 2N 이하라고 합시다. 아니라면 좌표 압축을 하면 됩니다.\nl번째부터 r번째까지의 간선만 이은 다음, 각각의 연결 요소에 대해 문제를 풀고 합치면 답을 구할 수 있습니다.\n연결 요소에 간선이 없다면 최소 회로는 0개입니다.\n차수가 홀수인 정점이 하나라도 있다면 회로로 분할할 수 없습니다.\n그렇지 않다면 오일러 회로를 만들 수 있기 때문에 최소 회로는 1개입니다.\n따라서, 쿼리의 답은 차수가 홀수인 정점이 하나라도 있다면 -1,\n아니면 간선이 최소 하나인 연결 요소의 개수와 같습니다.\n쿼리가 들어올 때마다 DFS를 하면 O(QN)이 됩니다. 실제로 오일러 회로를 만들 필요는 없습니다.\n서브태스크 2\n차수가 홀수인 정점이 존재하는지를 빠르게 알아내야 합니다.\n수열 a1, b1, a2, b2, ..., aN, bN을 생각해 봅시다.\n그러면 2l번째부터 2r+1번째까지 보았을 때, 정확히 홀수 개 들어있는 수가 존재하는지 판별하는 문제가 됩니다.\n“같은 수가 짝수 개“라는 키워드에서 XOR을 생각할 수 있습니다.\n각 정점마다 랜덤으로 64비트 정수 “레이블“을 부여한 다음,\n2l번째부터 2r+1번째까지 정점의 레이블 값을 XOR합시다.\n이 값이 0이라면, 1에  가까운 확률로 모든 수가 짝수 개씩 존재합니다.\n0이 아니라면, 무조건 홀수 개 들어있는 수가 적어도 하나 존재합니다.\n수열의 값이 중간에 바뀌지 않으므로, 구간 XOR은 누적 합으로 쿼리 당 O(1),\n총 O(N+Q)에 구할 수 있습니다.\n서브태스크 3\n서브태스크 2의 방법으로 답이 -1인지 아닌지는 알 수 있습니다.\n이제 답이 -1이 아니면 “간선이 최소 하나인 연결 요소의 개수“를 세야 되는데,\n일단 간선이 최소 하나라는 조건은 무시하고 그냥 연결 요소의 개수를 다 세어 봅시다.\n그런데 사실 이것도 어렵기 때문에, 이걸 또 두 서브태스크로 나눠서 생각해야 합니다.\n\nEasy 버전: 모든 쿼리의 l이 같습니다.\nHard 버전: 추가 제약 조건이 없습니다.\n\n연결 요소의 개수 (Easy)\n우선 모든 쿼리의 l이 같다고 합시다.\n그러면 모든 쿼리를 r에 대한 오름차순으로 정렬한 후 분리 집합으로 풀 수 있습니다.\nl번째 간선부터 차례대로, 간선이 두 연결 요소 사이를 이을 때마다, 그 둘을 합쳐 주고 개수를 1 줄이면 됩니다.\n사실 쿼리를 정렬할 필요도 없습니다. 실제로 연결 요소를 합치는 데 사용된 간선들을 모아 놓으면,\n[l, r]에 대한 답은 n - (번호가 r 이하인 간선의 개수)입니다.\n연결 요소의 개수 (Hard)\n실제로 연결 요소를 합치는 데 사용된 간선들은 스패닝 포레스트를 이룰 것입니다.\nl번째 간선에서부터 위 과정으로 만들어진 스패닝 포레스트를 F(l)이라고 합시다.\nF(l)이 있을 때, F(l-1)은 어떻게 구할 수 있을까요?\n우선 l-1번째 간선을 볼 때는 아무 간선도 없으므로, F(l)에다가 l-1번째 간선을 추가해 봅시다.\n만약 l-1번째 간선이 F(l)의 서로 다른 연결 요소를 이었다면, 이게 그냥 F(l-1)입니다.\nl-1번째 간선이 F(l)의 하나의 연결 요소 안에 놓여 있는 경우가 문제입니다.\nl-1번째 간선이 정점 a와 b를 잇는다고 합시다.\n그러면 F(l-1)을 만드는 과정은 F(l)과 거의 같은데, a와 b가 한 연결 요소로 모이는 시점이 앞당겨집니다.\n그리고 F(l)에서 a와 b 사이의 경로 중 가장 마지막으로 추가된 간선이 무시됩니다.\n나머지 간선은 변화가 없습니다.\n따라서 F(l-1)은, F(l)을 구한 다음,\na와 b 사이의 경로 중 번호가 가장 큰 간선을 제거하고 a와 b를 바로 이으면 구할 수 있습니다.\n링크-컷 트리로 모든 F(i)를 O(NlogN)에 구할 수 있습니다.\n쿼리 [l, r]에 대한 답은 n - (F(l)에서 번호가 r 이하인 간선의 개수)입니다.\n쿼리를 l에 대한 내림차순으로 정렬하고, F(n), F(n-1), …, F(1)을\n차례대로 구하면서 모든 쿼리의 답을 펜윅 트리로 O(Q+NlogN)에 구할 수 있습니다.\n간선이 있는 연결 요소의 개수\n실제 답은 (차수가 1 이상인 정점의 개수) - (F(l)에서 번호가 r 이하인 간선의 개수)이기 때문에,\n이제 차수가 1 이상인 정점의 개수를 구해야 합니다.\n이 값은 수열 a1, b1, a2, b2, ..., aN, bN의 2l번째부터 2r+1번째까지의 수 중\n서로 다른 수의 개수와 같습니다.\nBOJ 14897 서로 다른 수와 쿼리 1의\n풀이를 그대로 쓰면 됩니다. Mo’s algorithm 말고 오프라인 + 펜윅 트리를 권장합니다.\nBOJ14898 서로 다른 수와 쿼리 2의 풀이인\n온라인 + 머지 소트 트리를 써도 시간 내에 돌아갑니다.\n","path":null},{"url":"https://jh05013.github.io/blog/persistent/","title":"Persistent Data Structures","description":null,"body":"Persistent Introduction\n과거의 상태를 보존하는 자료구조를 persistent data structure라고 합니다.\n예를 들어, persistent array는 과거의 배열의 상태를 담고 있는 “버전“을 갖고 있습니다.\n여기에 “버전 $x$에서 $i$번째 원소를 $d$로 바꿔서 버전 $y$를 만들어라”,\n또는 “버전 $x$에서 $i$번째 원소의 값을 반환해라” 등의 연산을 적용할 수 있습니다.\nPersistent segment tree(PST)에 대한 자료는 인터넷에서 많이 찾아볼 수 있습니다.\n하지만 persistence라는 개념은 segment tree에만 적용되는 것이 아닙니다.\nPST는 persistence를 지원하는 일반적인 방법을 segment tree에 적용한 것일 뿐,\nsegment tree만을 위한 특별한 아이디어를 적용해서 만든 것이 아닙니다.\n이 글에서는 수많은 자료구조를\n기계적이고 간단한 방법을 통해 persistent data structure로 바꿀 수 있다는\n것을 보이고자 합니다.\nPersistent Stack\nLinked list로 구현한 평범한 스택을 생각해 봅시다.\n각각의 노드에는 고유의 값이 쓰여 있고, 다른 노드를 가리키는 포인터를 갖고 있습니다.\n\n일반적인 스택에서는 push나 pop을 하면 머리 노드가 바뀌고,\n기존의 머리 노드에 대한 정보는 사라집니다.\n이 정보를 버리지 말고, $i$번째 연산을 하기 직전의 머리 노드 $S_i$를 모두 저장해 봅시다.\n그러면 아래처럼 같은 $S_2$에 다른 원소를 push하여 $S_3$와 $S_4$를 만들 수도 있고,\n이전 버전인 $S_1$의 맨 앞 원소가 얼마인지도 알 수 있습니다.\n\n\n만약 “머리의 값을 $v$로 바꾼다“라는 연산을 지원하면 어떻게 될까요?\n기존의 스택이라면 그냥 바꾸면 되겠지만,\npersistent stack에서 그러면 이전 버전이 보존되지 않아서 안 됩니다.\n그 대신 머리를 그대로 복사한 다음, 그 복사본의 값을 $v$로 바꿔야 합니다.\n포인터는 복사한 그대로 남아있으므로 두 번째 노드를 가리키고 있을 것입니다.\n그리고 스택의 버전이 바뀌었으므로 이 연산에서 새로운 머리를 반환해줍시다.\n\n\n그 다음으로, “두 번째 노드의 값을 $v$로 바꾼다“라는 연산을 지원하면 어떻게 될까요?\n마찬가지로 두 번째 노드를 복사한 다음, 그 복사본의 값을 $v$로 바꾸면 됩니다.\n그런데 이 연산에서 반환해줄 새로운 머리가 없습니다.\n그렇다고 기존의 머리를 반환하면 안 됩니다. 그 머리는 이전 버전에 해당되고,\n새로운 노드가 아닌 과거의 노드를 가리키고 있기 때문입니다.\n따라서 머리도 새로 복사해 준 다음, 새 머리의 포인터도 바꿔주고 그 머리를 반환해야 합니다.\n\n\n마찬가지로, “$k$번째 노드의 값을 $v$로 바꾼다“라는 연산을 지원하려면\n머리부터 $k$번째 노드까지 모두 복사해 주면 됩니다. 코드는 생략합니다.\nPersistent Data Structures\n위의 예시를 일반화해 봅시다. 다음 조건이 성립하는 자료구조를 생각합시다.\n\n각 노드는 값과 포인터 필드로 이루어져 있습니다. (위의 Node::v와 Node::nxt)\n자료구조 자체도 값과 포인터 필드로 이루어져 있습니다. (위의 Stack::head)\n\n그러면 이 자료구조에서 일어나는 연산을 persistent하게 수행할 수 있습니다.\n\n연산이 노드 몇 개의 필드를 수정할 텐데, 그렇게 수정되는 노드의 집합을 $N$이라고 합시다.\n포인터를 통해 $N$의 노드 중 적어도 하나에 도달할 수 있는 노드의 집합을 $S$라고 합시다.\n$S$의 모든 노드를 복사하고, 자료구조 자체도 복사합니다. 노드 $x$를 복사한 것을 $x’$이라고 합시다.\n복사된 모든 노드에 대해, 포인터가 $S$ 중 한 노드인 $y$를 가리키면 $y’$으로 바꿉니다.\n복사된 자료구조에 대해서도, 포인터가 $S$ 중 한 노드를 가리키면 복사본으로 바꿉니다.\n복사된 자료구조에 대해 기존의 연산을 적용합니다.\n복사된 자료구조를 반환합니다.\n\n특히 포인터들이 트리의 형태를 이루고 있고 $N$의 크기가 1이라면, $S$는 하나의 경로를 이룰 것입니다.\n그래서 이 기법을 path copying이라고 부릅니다.\n물론 정확히 이 순서로 복사, 수정할 필요는 없고, 순서만 잘 맞으면 됩니다.\n예를 들어 특정 포인터 필드를 복사본으로 바꾸려면 먼저 그 복사본을 만들어야겠죠.\n시간 복잡도는 복사된 노드의 크기(필드의 개수)의 합에 비례합니다.\n위의 change_second를 예로 들어보면,\n\n$N$은 두 번째 노드 하나로 이루어져 있습니다.\n$S$는 첫 번째와 두 번째 노드로 이루어져 있습니다.\n$O(1)$ 크기의 노드 $O(1)$개를 복사했으므로, 시간 복잡도는 $O(1)$입니다.\n\nPersistent Tree\n트리를 persistent하게 바꿔봅시다. 만약 아래 그림에서 파란색 노드를 수정하려고 한다면,\n복사해야 하는 노드는 파란색과 빨간색 노드입니다.\n\n재귀 호출을 하면서 한 단계씩 내려가고,\n재귀 호출이 반환한 복사본을 현재 노드의 포인터 필드에 넣으면 구현하기 쉽습니다.\n아래 코드에 이 방식으로 binary search tree에 값을 추가하는 연산을 구현하였습니다.\n시간 복잡도는 트리의 높이에 비례합니다.\n\nPersistent Segment Tree\n세그먼트 트리는 balanced binary tree의 형태를 띠고 있습니다.\n그래서 persistent tree를 조금만 변형하면 persistent segment tree가 됩니다.\n다음 두 가지만 추가하면 됩니다.\n\n각 노드마다 그 서브트리의 크기를 저장합니다.\n재귀를 사용하여 점 업데이트 연산을 구현합니다.\n위의 persistent BST에서 봤던 대로, 왼쪽 또는 오른쪽 서브트리에 재귀 호출을 하고,\n포인터를 그 호출이 반환한 복사본으로 바꿔치면 됩니다.\n재귀를 사용하여 구간 쿼리 연산을 구현합니다.\n각 서브트리의 크기를 알고 있으므로 노드, $l$, $r$만 피연산자로 사용하면 됩니다.\n\nC++ 구현 Python 구현\nPersistent Array\n우리가 흔히 쓰는 형태의 배열을 그대로 persistent하게 만드는 건 의미가 없습니다.\n그냥 배열을 통째로 복사하는 거나 마찬가지니까요.\n하지만 persistent array를 다른 방법으로 구현할 수는 있습니다.\n그냥 persistent segment tree와 똑같이 구현하되, 구간 합 쿼리 대신 점 쿼리를 구현해 주고,\n업데이트 후에 값을 합체하는 과정을 없애면 됩니다.\n각 연산의 시간 복잡도는 $O(\\log N)$입니다.\n꼭 이진 트리일 필요는 없고, $K$진 트리를 만들어서 깊이를 줄이는 대신 노드의 크기를 늘릴 수도 있습니다.\nPersistent Queue\nLinked list 형태의 큐를 그대로 persistent하게 만드는 건 의미가 없습니다.\n$S$가 노드 전체의 집합이 되어 버리기 때문에, 큐를 통째로 복사하는 거나 마찬가지니까요.\n하지만 array 형태의 큐도 있죠? Array는 persistent하게 만들 수 있음을 위에서 보았으니,\n이걸 그대로 사용해서 persistent queue를 만들 수 있습니다.\n마찬가지로 각 연산의 시간 복잡도는 $O(\\log N)$입니다.\nPython 구현\nPersistent Union-find\nUnion-find를 배열 두 개로 구현할 수 있으므로,\npersistent union-find는 persistent array 두 개로 구현할 수 있습니다.\n주의할 점은 path compression을 쓰면 안 된다는 것입니다.\n왜냐하면 persistence를 추가하면 amortized analysis가 깨지기 때문입니다.\nAmortized 시간 복잡도는 같은 자료구조에서 연이어서 연산을 했을 때의 평균 시간 복잡도로,\n어떤 연산에서 $O(N)$이 걸리더라도 그 이후의 연산에서 계속 $O(1)$이 걸린다면\namortized 시간 복잡도는 더 낮아질 수 있습니다.\n하지만 persistent한 자료구조에서는 $O(N)$이 걸리는 바로 그 연산을 반복적으로\n수행할 수 있기 때문에, amortization이 더 이상 의미가 없습니다.\n따라서 union by rank를 써야 하고,\n이때 $O(\\log N)$ 시간 복잡도의 persistent array 연산을 $O(\\log N)$번 수행하므로\n시간 복잡도는 $O(\\log^2 N)$이 됩니다.\nPython 구현\nPersistent Next Steps\n한편, $S$의 크기에 관계 없이 $O(\\log N)$ 시간에 노드를 업데이트할 수 있으며, in-degree가 $O(1)$이라는 가정 하에 $O(1)$ 시간에도 노드를 업데이트할 수 있음이 알려져 있습니다. 관심 있으신 분은 다음 논문을 참조하세요: James R. Driscoll, Neil Sarnak, Daniel D. Sleator, Robert E. Tarjan, Making data structures persistent, Journal of Computer and System Sciences, Volume 38, Issue 1, 1989, Pages 86-124.\n","path":null},{"url":"https://jh05013.github.io/blog/boj20846/","title":"BOJ 20846 수열과 쿼리 40","description":null,"body":"https://acmicpc.net/problem/20846\n이게 무슨 쿼리야?\n각각의 쿼리는 수열 B의 접미사 배열을 만들었을 때 K번째 원소가 무엇인지 묻는 쿼리로 생각할 수 있습니다.\n수열 A의 접미사 배열을 만들고, 쿼리를 (d mod M)에 대한 오름차순으로 정렬합니다.\n이제 d를 하나씩 올려 가는데, 그럴 때마다 수열 A의 모든 원소를 하나씩 올린다고 생각하지 말고,\nA에 있는 원소 중 M-d가 “새로운 최솟값“이 된다고 합시다.\n이렇게 하면 원소가 바뀌는 횟수는 최대 N회입니다.\n이제 관건은 접미사 배열을 어떻게 동적으로 관리하는지입니다.\n자료구조\n정해가 이것일지는 모르겠으나, 저는 접미사 트리로 풀었습니다.\n접미사 트리는 여러 강력한 기능을 갖고 있는데, 그중 하나는\n트리를 DFS 순회하되 사전순으로 작은 자식부터 차례대로 방문하면\n(termination symbol은 -1이라고 합시다), 리프 노드를 방문한 순서가 곧 접미사 배열이 된다는 것입니다.\n따라서 수열 A의 접미사 트리를 만들고, 오일러 투어 트릭을 써서 일자로 편 다음,\n그걸 동적으로 관리함과 동시에 K번째 리프 노드를 찾을 수 있으면 됩니다.\n이제 원소 M-d가 “새로운 최솟값“이 된다고 합시다.\n그러면 모든 노드 p에 대해, label이 M-d로 시작하는 자식 v가 (존재하면) 현재 마지막 자식일 것이고,\n이 v가 첫 번째 자식으로 옮겨집니다.\n단, label이 termination symbol로 시작하는 자식이 있으면 대신 두 번째 자식으로 옮겨집니다.\n오일러 투어 트릭을 생각해 보면 이는 부분배열을 잡아서\nv의 서브트리의 크기 만큼 오른쪽으로 시프트하는 것이라고 생각할 수 있습니다.\n따라서 다음을 지원하는 자료구조를 사용하면 됩니다.\n\n접미사 트리의 노드가 주어졌을 때, 이것이 현재 오일러 투어에서 몇 번째에 위치하는지 찾기\n부분배열을 오른쪽으로 시프트하기\n현재 오일러 투어에서 K번째 리프 노드 찾기\n\n자료구조 하나 더\n스플레이 트리로 위 셋을 전부 구현할 수 있습니다.\n\n1번 연산은 접미사 트리의 노드 v에 대응되는 스플레이 트리의 노드 x를 찾고,\nx를 스플레이한 다음 x의 왼쪽 서브트리의 크기를 구하면 됩니다.\n2번 연산은 부분배열 뒤집기 연산 세 번으로 구현할 수 있습니다.\n3번 연산은 스플레이 트리의 각 노드마다\n“해당 (스플레이 트리) 노드의 서브트리에 있는 접미사 트리의 리프 노드 개수“를 저장해 두고,\n루트에서부터 하나씩 내려가면 됩니다.\n단, 그 전에 스플레이 트리가 균형이 잡혀 있음이 보장되어야 O(logN)이 됩니다.\n만약 그게 보장이 안 된다면, 스플레이 트리를 만든 직후에 아무 노드나 잡아서 스플레이하는 걸\n10,000번 정도 반복하면 됩니다.\n\n참고로 제 코드는 10799 바이트입니다.\n","path":null},{"url":"https://jh05013.github.io/blog/noncofe/","title":"제1회 논산 코드 페스티벌 풀이","description":null,"body":"https://www.acmicpc.net/category/detail/2206\n18857 집 떠나와 열차 타고\n선인장의 block-cut tree를 생각해 봤을 때, 정점 1과 N 사이에 있는 경로만 생각해도 충분합니다.\n그런 경로만 생각하면 그래프는 대충 이런 형태가 됩니다.\n\n이제 1번 정점에서 N번 정점으로 못 가게 하려면, 이 그래프의 BCC 중 하나를 완전히 끊어야 합니다. 완전히 안 끊고 예를 들어 사이클에서 하나의 간선만 제거한다거나 그러면 소용이 없습니다. 따라서, 각각의 BCC를 끊는 비용을 구하고, 그 중 최솟값을 구하면 됩니다.\n18858 훈련소로 가는 날\nDPu[i][j] = “길이 i, 마지막 정수 j이며, 마지막 두 수가 오름차순인 경우의 수”,\nDPd[i][j]는 거의 똑같은데 “오름차순이 아닌 경우의 수“로 두면 O(NM^2)가 나옵니다.\n이것만으로 시간 내에 돌아가지만, prefix sum을 적절히 사용하여 O(NM)으로 줄일 수도 있습니다.\n18859 부모님께 큰절 하고\n감소수열과 증가수열을 생각하지 말고,\n맨 첫 원소를 공유하는 두 개의 증가수열로 분해한다고 생각해 봅시다.\n\n맨 첫 원소는 수열의 최솟값이어야 합니다. 그 수를 m이라고 합시다.\n한 수열의 공차는 (m 제외 최솟값) - m이어야 합니다. 그 공차를 d라고 합시다. d = 0이면 답은 No입니다.\nm+d에서 시작해서 공차가 d인 등차수열을 적절히 제거했을 때, 남은 수들도 등차수열을 이루어야 합니다.\n\n3번은 어떻게 할까요? 수들을 정렬하고, 인접한 수들의 차를 모두 계산했을 때,\n그중 최솟값과 최댓값이 같아야만 등차수열을 이룰 수 있습니다.\n인접한 수의 차를 모두 저장하는 자료구조를 생각해 봅시다.\n여기서 수 x를 지우면, 이런 변화가 일어납니다.\n\nx 왼쪽과 오른쪽에 있는 수를 L, R이라고 합시다. L이나 R이 없을 수도 있습니다.\nL이 있으면, 자료구조에서 L-x가 제거됩니다. R이 있으면, 자료구조에서 x-R이 제거됩니다.\n그리고 L과 R이 모두 있으면, 자료구조에 R-L이 추가됩니다.\n\n따라서 수를 제거, 추가하고, 최솟값과 최댓값을 받아오는 자료구조를 쓰면 됩니다.\n가장 대표적인 것으로 multiset이 있고,\n임의의 원소 삭제가 가능한 힙을 만들 수도 있습니다.\n18860 대문 밖을 나설 때\n특정 펌프가 처음으로 작동을 시작한다고 하면, 전체 과정은 이렇게 생각할 수 있습니다.\n\n현재 작동 중인 펌프가 포함된 가장 작은 서브트리를 채웁니다.\n이제 석유가 넘쳐서 더 큰 서브트리로 흘러 가는데, 이 순간에 가능한 한 많은 펌프를 작동시켜야 합니다.\nx만큼의 석유가 넘치면 min(도달 가능한 펌프 개수, x)개의 펌프를 작동시킬 수 있습니다.\n그 다음 순간에는 도달 가능한 모든 펌프를 작동시킬 수 있습니다.\n1번으로 돌아갑니다.\n\n2번과 3번은 O(1)에 구현할 수 있습니다. 가장 시간이 오래 걸리는 부분은 1번인데,\n채워야 되는 서브트리의 크기를 미리 DP로 계산해 놓으면 이것도 O(1)에 구현할 수 있습니다.\n그리고 이 모든 과정은 O(logN)번 반복되므로,\n특정 펌프에서 시작할 때 다 채우는 데 걸리는 시간은 O(logN)만에 계산할 수 있습니다.\n모든 펌프에 대해 시간을 계산하면 됩니다.\n18861 가슴 속에 무엇인가\n만약 그래프가 포레스트임이 보장된다면, 간선 추가, 삭제, 경로 최솟값을 구하는 쿼리가 됩니다.\n포레스트가 아니라면 어떨까요? 트리에 간선 하나를 추가해 봅시다.\n그러면 사이클이 정확히 하나 만들어집니다. 그 사이클의 간선 중 가중치가 가장 작은 것을 봅시다.\n(여러 개면 아무거나 선택합니다.) 그러면 그 간선은 더 이상 쓸모가 없습니다.\n3번 쿼리의 경우 그 간선을 쓰는 대신 사이클 반대 방향으로 돌아서 가면 되며,\n2번 쿼리의 경우 사이클의 다른 간선들이 제거되기 전에 자신이 먼저 제거되기 때문입니다.\n따라서 새로운 간선을 추가하기 전에, 가중치가 가장 작은 그 간선을 먼저 제거하면,\n결과에 영향을 주지 않으면서 포레스트를 유지시킬 수 있습니다. 결국 이것도 경로 최솟값 쿼리가 됩니다.\n이 모든 것은 링크-컷 트리로 구현할 수 있습니다. 신난다!\n18862 아쉬움이 남지만\nEDIT(2022년):\n음… 사실 이 글을 네이버 블로그에 2년 전에 썼는데요, 이거랑 그 다음 두 문제는 풀이를 안 썼습니다.\n이 문제는 풀이가 정확히 기억나지 않아서 쓰려면 다시 풀어야 합니다…\n18863 풀 한 포기 친구 얼굴\n격자의 각 칸마다 (물론 도착점은 제외하고) 어떤 명령을 내릴 수 있는지 판별하면\n정점 NM개, 간선 10NM개 이하의 그래프가 만들어집니다.\n문제는 출발점에서 유한 개의 간선을 타고 도착점으로 오는 방법의 수를 구하는 것입니다.\n우선 특정 칸에서 특정 명령을 내릴 수 있는지 판별합시다.\n각 명령을 전처리하면서 “이 명령을 수행하는 동안,\n명령을 시작한 위치를 기준으로 이동하는 최소/최대 x/y좌표“를 구하면,\n특정 칸에서 이 명령을 내릴 때 격자를 벗어나는 경우가 존재하는지 O(1) 만에 판별할 수 있습니다.\n예를 들어 명령이 EWN이라면 최소/최대 x좌표는 0과 1, 최소/최대 y좌표는 -1과 0입니다.\n이제 그래프가 주어졌을 때, (1) 시작점에서 도달할 수 있으면서\n(2) 거기서부터 도착점으로 갈 수 있는 칸을 구합니다.\n이 두 조건 중 하나라도 만족하지 않는 칸은 욱제가 아예 도달할 수 없거나,\n욱제를 (N, M)으로 못 보내서 욱제의 훈련을 끝낼 수 없습니다.\n(1)은 그대로 그래프 순회를 돌리면 구할 수 있고,\n(2)는 모든 간선의 방향을 뒤집은 다음 도착점에서 그래프 순회를 돌리면 구할 수 있습니다.\n이렇게 정점을 쳐낸 후, 그래프에 사이클이 남아있으면 답은 -1이고,\n아니면 위상정렬 후 통상적인 DP로 답을 구할 수 있습니다.\n18864 모든 것이 새롭다\n예제 1은 불가능한 퍼즐로 알려진\n매우 유명한 퍼즐입니다. 왜 불가능할까요?\n퍼즐의 각 조각마다 그 조각이 (조각이 없을 경우, 빈 칸이) 원래 어디로 와야 되는지를 계산하면,\n퍼즐 전체를 하나의 순열로 나타낼 수 있습니다.\n조각 하나를 움직이는 것은 조각과 빈 칸을 서로 바꾸는 것이므로\n순열에 또 다른 순열 (a b)를 곱하는 것과 같습니다.\n(a b)는 홀순열이므로, 조각 하나를 움직일 때마다 순열의 홀짝성이 바뀝니다.\n그런데 빈 칸이 맨 처음 상태와 마지막 상태에서 위치가 같기 때문에 조각은 짝수 번 움직여야 하고,\n따라서 맨 처음 상태와 마지막 상태는 홀짝성이 같습니다.\n그런데 실제로는 맨 처음 상태가 홀순열이고, 마지막 상태가 짝순열이기 때문에 이 퍼즐은 맞출 수 없습니다.\n이를 일반화하면 문제를 풀 수 있습니다.\n일단 여섯 차원 중 다섯 개의 크기가 1이면 예외처리를 해야 합니다.\n이제 맨 처음 상태의 홀짝성을 확인합니다.\n마지막 상태는 무조건 짝순열입니다.\n따라서 (맨 처음 상태가 홀순열)과 (빈 칸이 홀수 번 움직여야 함)이 동치가 아니면 이 퍼즐은 맞출 수 없습니다.\n반대로 동치이면 이 퍼즐은 맞출 수 있는데, 이건 증명하기 조금 까다롭습니다.\n한번에 한 레이어씩 맞추면 되던 걸로 기억합니다.\n18865  이제 다시 시작이다\n한 스피커에 대해, 볼륨을 점차 증가시키면 훈련소 내부에서 소리가 들리는 영역이 다음과 같이 변합니다.\n\na초까지는 들리는 영역이 없습니다.\na초부터 b초까지는 한 변의 길이가 V-a인 직각이등변삼각형이 됩니다.\nb초부터 c초까지는 한 변의 길이가 V-a인 직각이등변삼각형에서, 위쪽 또는 오른쪽 일부분을 제거한 형태가 됩니다. 단, 둘 중 한 부분만 제거됩니다. b=c일 수도 있습니다.\nc초부터 d초까지는 위쪽과 오른쪽을 둘 다 제거한 형태가 됩니다.\nd초부터는 직사각형이 되고 영역이 더 이상 변하지 않습니다.\n\n\n이제 영역의 넓이가 어떻게 변하는지 생각해 봅시다.\n1번의 경우 따로 해야 될 일이 없습니다. 2번의 경우, a초부터 시작하는 이차함수를 만들 수 있습니다.\n3번의 경우, V-a 크기의 직각이등변삼각형의 넓이에서 제거된 부분의 넓이를 빼면 됩니다.\nV-a 삼각형의 넓이는 2번에서 이미 추가되었기 때문에 그대로 쓰면 되고,\n제거된 부분은 직각이등변삼각형이므로 이차함수로 나타낼 수 있습니다. 4번도 마찬가지입니다.\n5번의 경우 두 “제거된 부분“이 겹친 것이라고 생각할 수 있습니다.\n따라서 겹친 부분의 넓이를 다시 더해줘야 합니다.\n이 겹친 부분도 직각이등변삼각형이므로 이차함수로 나타낼 수 있습니다.\n이걸 구현하려면 이런 자료구조가 필요합니다.\n\n특정 시간 t부터 정의되는 이차함수를 추가한다.\n특정 시간 t에서 이차함수들의 합을 구한다.\n\n이건 펜윅 트리를 3개 만들어서 풀 수 있습니다.\n각 펜윅 트리는 이차함수의 이차항의 계수, 일차항의 계수, 상수항을 각각 저장하면 됩니다.\n18866 젊은 날의 생이여\n1~K년이 젊은 날이 될 수 있는지 판별해 봅시다.\n먼저, K년까지의 행복도 중 최솟값은 이후의 행복도 중 최댓값보다 커야 합니다.\n그걸 판별하려면 행복도 중 누락된 값을 아예 “없는 데이터“로 취급해도 무방합니다.\n어차피 K년까지의 행복도 중 누락된 값은 매우 크게 잡아야 하고,\n이후의 행복도 중 누락된 값은 매우 낮게 잡아야 하기 때문입니다.\n마찬가지로, K년까지의 피로도 중 최댓값이 이후의 피로도 중 최솟값보다 낮아야 합니다.\n따라서 “첫 x년의 최소 행복도”, “첫 x년의 최대 피로도”, “마지막 x년의 최대 행복도”,\n“마지막 x년의 최소 피로도“를 모두 구하면 됩니다. DP로 풀 수 있습니다.\n18867 편지 꼭 해다오\n제한이 많이 널널하기 때문에, 여러 가지 방법으로 풀 수 있습니다.\n가장 짧은 답안을 찾고 싶다면 냅색을 풀면 됩니다.\n[a-zA-Z0-9]에 있는 글자만 사용할 때는 5글자가 가장 짧습니다.\n","path":null},{"url":"https://jh05013.github.io/blog/fenwick-more/","title":"펜윅 트리 200% 활용하기","description":null,"body":"이 글은 BOJ 블로그에 있는 글과 동일합니다.\n흔히 lazy propagation을 사용하여 푸는 것으로 알려진 이 두 문제는 사실 펜윅 트리만으로 풀 수 있습니다.\n구간 덧셈, 포인트 쿼리\n다음 연산을 효율적으로 수행하는 자료구조를 만들어 봅시다. 이것으로 16975번 - 수열과 쿼리 21을 풀 수 있습니다.\n\n$A_L$, $A_{L+1}$, $\\cdots$, $A_R$에 각각 $x$씩 더한다.\n$A_k$를 출력한다.\n\n$B_1 = A_1$, $B_k = A_k - A_{k-1}$이라고 두면, 각각의 쿼리는 이렇게 변합니다.\n\n$B_L$에 $x$를 더하고, R이 마지막 인덱스가 아니면 $B_{R+1}$에서 $x$를 뺀다.\n$B_1 + \\cdots + B_k$를 출력한다.\n\n따라서 펜윅 트리로 구현할 수 있습니다.\n같은 원리로, 1번 쿼리만 계속 들어온 다음 2번 쿼리만 계속 들어옴이 보장되면, 단순 배열 연산으로 O(N+Q)에 풀 수 있습니다. 스위핑을 생각하시면 됩니다.\n연습 문제집\n구간 덧셈, 구간 합 쿼리\n세그먼트 트리 lazy propagation을 쓰는 대표적인 예시로 알려진 이 문제 역시 놀랍게도 펜윅 트리 두 개로 풀 수 있습니다.\n\n$L, L+1, \\cdots, R$번째 원소에 각각 $x$씩 더한다.\n$L, L+1, \\cdots, R$번째 원소의 합을 출력한다.\n\n우선, L과 R이 있는 것이 거슬리니까 이렇게 바꿉시다. 원래 있었던 쿼리는 밑의 쿼리 두 번으로 처리할 수 있습니다.\n\n$k, k+1, \\cdots, N$번째 원소에 각각 $x$씩 더한다.\n$1, 2, \\cdots, k$번째 원소의 합을 출력한다.\n\n$k, k+1, \\cdots, N$번째 원소에 각각 $x$씩 더할 때, 각 $m = 1, 2, \\cdots, N$에 대해 “$m$번째까지 원소의 합“이 얼마나 늘어나는지 생각해봅시다.\n\n$m &lt; k$라면, $m$번째까지 원소의 합은 변화하지 않습니다.\n$m \\geq k$라면, $m$번째까지 원소의 합은 $(m-k+1)x$ 늘어납니다.\n\n이것은 곧 $k$번째 칸에 일차함수 $f(m) = xm + (-k+1)x$를 집어넣는 펜윅 트리라고 볼 수 있습니다. 두 일차함수의 합은 여전히 일차함수이므로 각 칸마다 일차항의 계수를 저장하는 펜윅 트리를 만들고, 각 칸마다 상수항을 저장하는 펜윅 트리를 만들면 됩니다. 그렇게 만든 트리에서 첫 번째부터 $k$번째까지 원소(일차함수)의 합을 계산하여 또다른 일차함수를 얻고, 그 일차함수의 변수에 $k$를 집어넣어 계산한 값이 2번 쿼리의 답입니다.\n","path":null},{"url":"https://jh05013.github.io/blog/cpdp/","title":"Connection Profile DP","description":null,"body":"Connection Profile DP\n이 글은 비트마스크 DP를 배경지식으로 합니다.\n격자에서 비트마스크 DP를 돌리는 문제가 있습니다.\n예를 들어 BOJ 1648 (격자판 채우기) 문제에서는\n위에서 아래로, 왼쪽에서 오른쪽으로 훑으면서, 최근 M개의 칸의 상태를 비트마스크로 저장합니다.\n각 칸의 상태는 그 칸에 도미노가 채워졌으면 1, 아니면 0입니다. 그림으로 나타내면 이렇게 되겠죠.\n\nConnection Profile??\n이 문제를 풀어봅시다.\n격자에서 연결 요소를 만들되 비용의 합을 최소화하는 문제입니다.\n위에서 다룬 것처럼 비트마스크 DP를 하고 싶어집니다. 최근 M개의 칸의 상태를 비트마스크로 저장합니다.\n각 칸의 상태는 그 칸이 연결 요소에 포함되어 있으면 1, 아니면 0입니다.\n하지만 그러면 안 됩니다.\n최근 M개의 칸이 사용되었는지 아닌지만 따져서는 연결 요소가 생겼는지 알 수 없기 때문입니다.\n예를 들어, 아래 그림에서 최근 M개의 칸의 상태가 왼쪽과 같을 때,\n가운데처럼 모든 칸이 연결되었는지, 오른쪽처럼 모든 칸이 연결되지 않았는지 알 방법이 없습니다.\n\n그렇다고 지금까지 본 모든 칸의 상태를 다 저장하면 당연히 안 됩니다.\n그래서 우리는 어떤 칸들이 서로 연결되어 있는지를 저장할 겁니다.\n연결 요소에 번호를 붙였다고 해봅시다. 단, 선택되지 않은 칸은 0으로 채워넣습니다.\n\n이제 최근 M개의 칸의 상태만 저장해 놓으면 됩니다!\n\n상태 전이\n상태 전이를 분석해 봅시다.\n케이스 1: “현“을 선택하지 않는다.\n“현“을 선택하지 않으면, “현“의 위쪽 칸을 제외하여 최근 M-1개의 칸의 상태가 하나씩 밀리고,\n최근 칸의 상태는 0이 됩니다.\n단, 이 케이스를 따라가면 안 되는 경우가 하나 있습니다.\n“현“의 위쪽 칸이 선택되었고, 최근 M-1개의 칸 중 누구와도 연결되어 있지 않을 때입니다.\n\n이때는 “현“을 선택하지 않는 순간,\n\n만약에 최근 M-1개의 칸 중 선택된 칸이 존재한다면,\n위쪽 칸은 나머지 칸들과 하나의 연결 요소를 이루는데 실패하게 됩니다.\n만약에 최근 M-1개의 칸 중 선택된 칸이 없다면, 모든 칸이 하나의 연결 요소를 이루는 데에는 성공했으나,\n“이미 하나의 연결 요소가 있었다“는 정보가 소실됩니다.\n그래서 “현” 이후의 칸들을 선택해야 하는지 말아야 하는지를 결정할 수 없습니다.\n\n따라서 이 상황에서는 케이스 1을 건너뛰어야 합니다.\n케이스 2: “현“을 선택한다.\n이때는 “현“의 위쪽 칸과 왼쪽 칸의 상태에 따라 세 가지 경우가 생깁니다.\n(1) 위쪽 칸과 왼쪽 칸이 선택되지 않았다면, “현“은 그 자체로 새로운 연결 요소를 이루게 됩니다.\n따라서 최근 M개의 칸에서 사용하지 않은 연결 요소 번호를 새로 만들어 그 칸에 집어넣습니다.\n\n(2) 위쪽 칸과 왼쪽 칸 중 하나만 선택되었다면, 그 칸의 연결 요소의 번호를 “현“이 그대로 따라갑니다.\n\n(3) 위쪽 칸과 왼쪽 칸이 모두 선택되었다면, 두 칸의 연결 요소가 하나로 합쳐집니다.\n두 칸의 연결 요소 번호를 각각 x와 y라고 할 때, 최근 M-1개의 칸 중 번호가 y인 것들의 번호가 x로 바뀝니다\n(물론 x에서 y로 바꿀 수도 있습니다.)\n그리고 “현“은 그 번호를 그대로 따라갑니다.\n\n풀이의 마무리\n마지막으로, 선택된 칸들이 연결 요소를 이룰 때마다 정답을 갱신해 주면 됩니다.\n선택된 칸들이 연결 요소를 이루는지 판별하려면 서로 다른 양수가 1개 이하인지 검사하면 됩니다.\n아쉽게도, N=M=9인 입력을 아무거나 넣어 보면 너무 느리다는 것을 알 수 있습니다.\n최적화\n물론 연결된 칸끼리는 같은 번호를 가지니 DP 상태의 개수가 M^M개나 되지는 않겠지만,\n제가 구현한 바로는 칸 하나를 볼 때마다 7만 개의 상태가 생겼습니다.\n이를 최적화하려면 같은 상태들을 하나로 합쳐 줘야 합니다.\n예를 들어 다음 두 상태는 같습니다. 연결 요소들에 번호만 다시 붙여 주면 같아지기 때문입니다.\n상태 전이를 하면서 최근 M개의 칸의 상태를 “정규화“하는 과정이 필요합니다.\n\n간단한 방법으로 사전순으로 가장 앞선 상태로 정규화하는 방법이 있습니다.\n위쪽 칸에서부터 하나씩 보면서, 상태가 0이면 그대로 0으로 둡니다.\n양수이면서 이전에 만난 적 없는 번호면, 새로운 번호를 할당합니다.\n이전에 만난 적 있는 번호면, 그 번호가 할당받았던 새로운 번호를 그대로 줍니다.\n예를 들어 위 그림의 오른쪽 상태는 왼쪽 상태로 정규화됩니다.\n위에 언급했듯이 인접한 칸은 같은 번호를 가지므로 정확한 시간 복잡도를 분석하기는 어렵지만,\n적당한 상한은 잡아줄 수 있습니다.\n정규화를 했기 때문에, 최근 M개의 칸의 상태로 가능한 조합의 개수는\nM개의 칸을 몇 개의 집합으로 분할하는 방법의 수보다 작거나 같습니다.\n그 수는 bell number라고 하고, 0번째 bell number부터 차례대로 나열한 수열이\nOEIS에 번호 A000110으로 있습니다.\n9번째 bell number는 21,147입니다.\n적당한 상한만 잡은 건데도 위에서 보았던 7만 개보다 훨씬 적고,\n실제로 돌려 보면 나타나는 상태의 개수는 2천 개밖에 되지 않습니다.\n정규화 작업까지 해 주고 N=M=9인 입력을 넣어 보면 답이 순식간에 나오는 것을 확인할 수 있고,\n저의 구현은 0.1초 안에 맞았습니다!! 를 받았습니다.\n","path":null},{"url":"https://jh05013.github.io/images/","title":"Images","description":null,"body":"?\n","path":null}]