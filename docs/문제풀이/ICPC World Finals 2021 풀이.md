# ICPC World Finals 2021 풀이

# A
작성 예정

# B
시작점을 루트로 잡읍시다.

열쇠와 함정을 무시할 경우, 트리 순회를 하는데 가장 깊은 (루트에서 가장 먼) 점에서 멈추는 것이 최적입니다. 따라서 답은 `2*(간선 길이의 합) - (가장 깊은 점의 깊이)`입니다.

이제 함정과 열쇠가 있다고 합시다. 우선 함정이 열쇠의 조상이면 불가능입니다. 아닐 경우, 가장 마지막으로 방문하는 정점이 d라고 합시다. 가장 깊은 점이 아닐 수도 있습니다. 아래와 같이 열심히 케이스 분석을 해보면

![[Pasted image 20221119020304.png]]

함정과 열쇠의 LCA를 l, 열쇠와 d의 LCA를 z라고 하면 답은 `2*(간선 길이의 합) - (d의 깊이) + 2*(z에서 l까지 거리)`입니다. 모든 d에 대해 이걸 계산하고 최솟값을 찾으면 됩니다. 물론 이걸 빠르게 하는 것도 쉽지 않습니다.

쿼리를 같은 시작점들끼리 묶어, 각 시작점마다 전처리를 한 번씩 해줄 수 있다고 합시다. 그 후 각 쿼리를 O(n)에 수행하면 O(n^2 + qn)이고, 이는 약 4억이므로 시간 내에 돌아갑니다. 그런데 출제자는 이걸 막으려고 했다고 합니다(???).

저기서 시간이 걸리는 요인은 (1) LCA 계산, (2) 거리 계산입니다.

(1) LCA의 경우, 모든 정점과 열쇠의 LCA를 구하는 것이 문제입니다. LCA는 희소 배열 외에도 오일러 투어 + 구간 최솟값 쿼리로 풀 수 있음이 알려져 있습니다. 이 구간 최솟값도 범위의 한쪽 끝이 정해져 있기 때문에, 세그먼트 트리 같은 걸 쓸 필요 없이 그냥 범위를 하나씩 늘려 주면서 최솟값을 갱신하면 전체 O(n)에 됩니다.

(2) 거리 계산의 경우, z와 l은 조상 관계이기 때문에 두 정점의 깊이의 차를 구하면 됩니다.

# C
무한급수 계산을 열심히 해보면 비는 `q^(n-1) : q^(n-2)(q-p) : q^(n-3)(q-p)^2 : ... : (q-p)^(n-1)`가 나옵니다. 따라서 저 수들의 합이 m의 약수여야 합니다.

그러려면 일단 `q^(n-1) <= m`여야 되는데, n이 6 이상이기 때문에 `q <= 4000`만 보면 됩니다. 오버플로우를 막으려면 저 n개 항을 통째로 합하는 게 아니라, 하나하나 더하면서 m을 넘을 때 바로 끊어줘야 합니다.

# D
우선 조각상이 보이는 영역을 알아냅니다. 조각상에서 각 꼭짓점으로 반직선을 그어, 양쪽 반평면을 미술관 공간에 따라 알맞게 자르면 됩니다.

이제 그 영역으로 가는 최단거리를 계산합니다. 우선 출발점 및 각 꼭짓점만 써서 그래프를 만들고, 두 점을 잇는 선분이 미술관에 완전히 포함되는 경우에만 두 점을 이은 다음, 데이크스트라를 돌려 주면 됩니다.

마지막으로 각 점에서 목표 영역의 각 변으로 가는 직선 거리를 계산합니다. 물론 그 이동 경로가 미술관에 완전히 포함되는 경우만 계산합니다.

풀지 마세요.

# E
작성 예정

# F
θ에 대해 이분탐색을 합니다. (안 하는 풀이도 있지만, 하는 쪽이 계산하기 좀 더 편한 것 같습니다.)

θ를 정하면 각 사다리꼴 영역이 정해집니다. 비행기의 높이가 h이면 밑변의 길이는 `2htanθ`이고, 방향은 비행 경로를 90도씩 회전시켜서 구할 수 있습니다. 사다리꼴은 볼록다각형이기 때문에 섬이 사다리꼴 안에 있는지 판별하려면 섬의 모든 꼭짓점만 보면 됩니다.

# G
패턴과 격자의 높이가 1일 경우, [와일드카드 문자열 매칭](https://infossm.github.io/blog/2021/08/20/wildcard-string-matching/)으로 풀 수 있습니다. 이 문제에서는 격자에 와일드카드가 없으므로 `T_j`는 안 곱해도 됩니다. 계수가 꽤 큰 편이므로 주의하세요.

높이가 2 이상일 수 있을 경우, 그냥 격자를 일렬로 펴고 패턴에 와일드카드 패딩을 붙이면 높이 1 문제로 환원됩니다. 예를 들어 예제는 이렇게 될 겁니다. 물론 몇몇 인덱스는 격자에 안 맞기 때문에 매칭이 되어도 출력하지 말아야 합니다.

```
패턴: 1 0 0 0 0 1
격자: 1 2 1 2 2 1 1 1 2 2 1 3
```

# H
[AtCoder Beginner Contest 167F](https://atcoder.jp/contests/abc167/tasks/abc167_f)입니다. 사실 저기서 최초로 낸 것도 아닐 겁니다. [풀이는 이 링크에 있습니다.](https://img.atcoder.jp/abc167/editorial.pdf)

서너 번씩 나온 문제를 왜 월파에 내냐고 코드포스에서 말이 많았던 문제입니다.

# I
안쪽에서 바깥쪽으로 가면서 각 가닥으로부터 s번째 가닥까지 가는 게 아니라, 거꾸로 바깥쪽에서 안쪽으로 가면서 s번째 가닥으로부터 각 가닥까지 간다고 생각합시다.

`DP[i][j]`를, 첫 i개의 다리만 고려하고 나머지 다리를 자유롭게 그을 수 있을 때 j번째 가닥에 오는 최소 비용이라고 합시다. `DP[0][..]`은 s를 시작으로 양옆으로 하나씩 늘어나는 형태일 것입니다.

우선 `DP[i][..]`은 이웃한 DP 값들의 차이가 1 이하임을 염두에 둡시다. 이웃한 DP 값이 2 이상 차이가 날 경우, 낮은 쪽에서 높은 쪽으로 다리를 이어주면 더 좋은 해가 나오기 때문입니다.

`DP[i][..]`가 계산되었을 때 `DP[i+1][..]`을 계산하려면,

- `i`번째 다리가 a와 a+1을 잇는다고 합시다.
- `DP[i+1][a+1]`과 `DP[i+1][a]`에 각각 `DP[i][a]`와 `DP[i][a+1]`을 넣고, 나머지 `DP[i+1][..]` 값들은 `DP[i][..]`를 그대로 따라갑니다.
- 두 DP 값이 교환되면서 이웃한 DP 값의 차이가 2가 될 수 있습니다. 이 경우 높은 쪽을 하나 낮춰줍시다.
- 이제 `DP[i+1][a] = v`라고 할 때, 각 `DP[i+1][b]`를 다시 계산합니다. 현재 값과 `v + (a에서 b까지의 거리)` 중 최솟값을 잡으면 됩니다.
- `DP[i+1][a+1] = v'`도 마찬가지로 써서 각 `DP[i+1][b]`를 다시 계산합니다.

`v + (a에서 b까지의 거리)`는 절댓값 함수이기 때문에, 기울기가 1 또는 -1인 일차함수 여러 개로 표현할 수 있습니다. 따라서 `DP[i+1][b]`들을 다시 계산하는 과정은 세그먼트 트리 lazy propagation으로 최적화할 수 있습니다. Lazy 값을 `(p, q)`로 둬서 `min(현재 값, x+p, -x+q)`을 표현하면 됩니다.

# J
작성 예정

# K
각 노드마다 최종 밈으로 가능한 모든 벡터를 저장해 둔다고 합시다. 이는 다음과 같이 계산할 수 있습니다.

벡터의 집합 S와 T에 대해, S의 모든 벡터를 180도 뒤집은 걸 -S, 두 집합 S와 T에서 하나씩 뽑아 더해서 나오는 모든 벡터의 집합을 S+T라고 합시다. 노드 x가 주어졌을 때, 모든 자식 노드 y에 대해 벡터 집합 Sy를 계산합니다. 이제 각 자식 노드 y에 대해, y 빼고 나머지 S들을 모두 -S로 바꾸고 전부 더한 다음, Sy도 더해줍니다. 이걸 Zy라고 했을 때 모든 Zy의 합집합을 구하면 됩니다. 참 쉽죠?

아쉽게도 밈이 무려 9,000개를 넘는데, 이러면 절대로 문제를 풀 수가 없습니다. 하지만 우리는 결코 이 문제를 포기하지도, 실망시키지도, 마음 바꿔 버리고 떠나지도 않을 겁니다.

강력한 최적화를 도입합니다. S를 다 들고 있을 필요가 없고, 각 벡터를 점으로 생각했을 때 볼록 껍질을 이루는 애들만 들고 있으면 됩니다. 볼록 껍질 두 개의 합, 즉 두 볼록다각형의 민코프스키 합은 선형 시간에 계산할 수 있습니다. 시간 복잡도 분석이 쉽지 않지만, 좌표 범위가 X일 때 볼록 껍질의 크기는 O(X^(2/3))인 점을 활용하여 대충 어림잡으면 [연산량이 7억 이하](https://codeforces.com/blog/entry/108890?#comment-971464)가 나오고, 실제로는 훨씬 적게 나온다고 합니다.

해치웠나? 싶었던 저는 의문의 RTE를 받았습니다. 맞왜틀? X를 눌러 조의를 표하십시오. 하지만 풀이 하나는 기억해주세요. 진심을 다해 전합니다.

이 풀이에 언급된 밈을 가장 먼저 전부 찾으시는 분께는 여기에 특별 언급을 해드리겠습니다. 안녕히 계세요 여러분!

# L
작성 예정

~~각 시작점에서 출발했을 때 각 마커를 언제 방문하는지 계산합니다. [이 문제](https://www.acmicpc.net/problem/25294)를 풀어보시면 좋습니다. 사실 O((NM)^2)에 시뮬레이션 돌려서 계산해도 잘 짜면 시간 내에 돈다고 합니다.~~

~~각 시작점마다 그 방문 시각들을 정렬합니다. 그 후 그 목록들을 다시 한 번 사전순으로 정렬합니다. 예를 들면 이런 식으로 나올 겁니다. (정확한 수는 아니고 그냥 아무거나 쓴 겁니다.)~~

```
[0, 1, 5, 10]: (1, 3)
[0, 1, 6, 7]: (2, 4)
[1, 5, 7, 12]: (3, 3)
[1, 5, 6, 13]: (4, 1)
[1, 7, 10, 12]: (2, 1)
[1, 9, 12, 15]: (4, 4)
...
```

# 체감 티어
```
A Platinum 3
B Diamond 5
C Platinum 4
D Ruby 4
E Diamond 1
F Platinum 4
G Diamond 4
H Platinum 5
I Diamond 3
J Gold 2
K Diamond 1
L Platinum 3
```

H가 왜 가장 많이 풀린 거지...
