<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>jh05013</title>
    <link rel="self" type="application/atom+xml" href="https://jh05013.github.io/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://jh05013.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-03-30T00:00:00+00:00</updated>
    <id>https://jh05013.github.io/atom.xml</id>
    <entry xml:lang="en">
        <title>재귀의 본질</title>
        <published>2025-03-30T00:00:00+00:00</published>
        <updated>2025-03-30T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              jh05013
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://jh05013.github.io/blog/recursion/"/>
        <id>https://jh05013.github.io/blog/recursion/</id>
        
        <content type="html" xml:base="https://jh05013.github.io/blog/recursion/">&lt;blockquote class=&quot;note&quot;&gt;
	&lt;p class=&quot;alert-title&quot;&gt;
		&lt;i class=&quot;icon&quot;&gt;&lt;&#x2F;i&gt;Note&lt;&#x2F;p&gt;
	&lt;p&gt;재귀를 처음 배우신다면 맨 아래에 첨부한 링크를 같이 참조하는 것이 좋습니다.&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;재귀를 배웁니다. 재귀 함수는 자기 자신을 호출하는 함수입니다. 좋습니다.&lt;&#x2F;p&gt;
&lt;p&gt;재귀로 팩토리얼을 구현합니다. 잘 돌아갑니다. &lt;code&gt;factorial(5)&lt;&#x2F;code&gt;는 &lt;code&gt;factorial(4)&lt;&#x2F;code&gt;를 부르고, 이건 다시 &lt;code&gt;factorial(3)&lt;&#x2F;code&gt;을 부르고… &lt;code&gt;factorial(0)&lt;&#x2F;code&gt;을 부르고, 이건 1을 반환하고, &lt;code&gt;factorial(1)&lt;&#x2F;code&gt;이 여기에 1을 곱해서 1을 반환하고… &lt;code&gt;factorial(5)&lt;&#x2F;code&gt;가 여기에 5를 곱해서 120을 반환합니다. 그럴싸합니다.&lt;&#x2F;p&gt;
&lt;p&gt;재귀로 피보나치를 구현합니다. 잘 돌아갑니다. 강좌에 두 갈래로 마구 뻗는 함수 호출 과정이 그림으로 등장합니다. 구체적으로 뭐가 어떤 순서로 호출되는 건지는 안 나와있지만 넘어갑니다.&lt;&#x2F;p&gt;
&lt;p&gt;문제는 하노이 탑입니다. 풀이가 있지만 이게 왜 동작하는지, 이걸 어떻게 생각해 내는 건지는 알 수 없습니다. 원판 n-1개를 1에서 2로 옮긴다고 했지만 함수 호출이 어떻게 일어나서 그렇게 되는지 추적할 수 없습니다. 원판을 일곱 번 옮기는 그림이 있지만 도움이 되지 않습니다. 며칠째 호출 과정을 추적하다가 결국 포기하고 풀이를 암기하기로 합니다.&lt;&#x2F;p&gt;
&lt;p&gt;제 경험이 그랬다는 건 아니지만, 위와 같은 일을 겪는 사례를 심심찮게 찾아볼 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;재귀가 원래 이렇게 이상한 존재일까요? 그렇지 않습니다. 재귀의 본질은 이 복잡한 호출 과정을 따라가는 데서 나오지 않습니다. &lt;em&gt;오히려 따라가지 않는 데서 나옵니다.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;jaegwireul-puneun-bangbeob&quot;&gt;재귀를 푸는 방법&lt;&#x2F;h1&gt;
&lt;p&gt;재귀로 문제를 푸는 규칙은 이렇습니다.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;입력 크기가 가장 작을 때 (0, 1 등) 문제를 풉니다.&lt;&#x2F;li&gt;
&lt;li&gt;입력 크기가 N보다 작을 때 문제를 풀 수 있다고 가정합니다. &lt;strong&gt;구체적으로 어떻게 풀었는지는 생각하지 않습니다.&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;이제 입력 크기가 N일 때 문제를 풉니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;재귀의 장벽을 깨뜨리는 첫걸음은 2번입니다. &lt;em&gt;“구체적으로 어떻게 풀었는지는 생각하지 않습니다.”&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;사실 생각해 보면 프로그램의 동작 과정을 바닥까지 다 따라갈 필요가 없습니다. 예를 들어 &lt;code&gt;print&lt;&#x2F;code&gt; (&lt;code&gt;printf&lt;&#x2F;code&gt;, &lt;code&gt;cout&lt;&#x2F;code&gt;, …)도 내부적으로 뭔가를 호출할 텐데, 우리는 &lt;code&gt;print&lt;&#x2F;code&gt;를 처음 배울 때 내부를 굳이 뜯어보지 않습니다. &lt;code&gt;print&lt;&#x2F;code&gt;가 뭔가를 출력하는 함수라고 &lt;em&gt;믿고&lt;&#x2F;em&gt; 그냥 씁니다. 재귀도 마찬가지입니다. 단지 내부가 자기 자신이 될 뿐입니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;paegtorieol&quot;&gt;팩토리얼&lt;&#x2F;h2&gt;
&lt;p&gt;위 규칙으로 팩토리얼을 풀어봅시다. 먼저 &lt;code&gt;N == 0&lt;&#x2F;code&gt;이라면 1을 반환합니다.&lt;&#x2F;p&gt;
&lt;p&gt;이제 입력 크기가 &lt;code&gt;N&lt;&#x2F;code&gt;보다 작을 때 문제를 풀 수 있다고 가정합니다. 즉 &lt;code&gt;factorial(N-1)&lt;&#x2F;code&gt;은 $(N-1)!$을 반환합니다. &lt;strong&gt;구체적으로 &lt;code&gt;factorial(N-1)&lt;&#x2F;code&gt;이 어떻게 동작하는지는 생각하지 않습니다.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;이제 $N! = (N-1)! \times N$이고 $(N-1)!$은 &lt;code&gt;factorial(N-1)&lt;&#x2F;code&gt;이니까, &lt;code&gt;factorial(N-1) * N&lt;&#x2F;code&gt;을 반환하면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;이를 재귀로 구현했을 때 왜 제대로 동작하는지를 이해하려면, 마찬가지로 입력 크기가 N보다 작을 때 제대로 동작한다고 가정합니다. 이번에도 구체적으로 왜 그런지는 생각하지 않습니다. &lt;code&gt;factorial(5)&lt;&#x2F;code&gt;를 계산하려고 한번에 다섯 단계까지 깊이 들어갈 필요가 없습니다. &lt;code&gt;factorial(4) = 4!&lt;&#x2F;code&gt;임을 이미 아는 상태라고 가정하고 거기서 바로 끝내면 됩니다. 이걸 일일이 풀어 계산하는 건 컴퓨터의 몫입니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hanoi-tab&quot;&gt;하노이 탑&lt;&#x2F;h2&gt;
&lt;p&gt;우선 하노이 탑을 풀이할 때 “재귀를 사용해 보자“가 먼저 나오면 안 됩니다. 문제에 대해 아직 아무것도 알아낸 게 없는 상태에서는 재귀를 떠올릴 수 없습니다.&lt;&#x2F;p&gt;
&lt;p&gt;하노이 탑을 손으로 풀려고 시도해 보면, 원판이 클수록 그 위에 있을 수 있는 다른 원판이 많아지기 때문에 옮기기 어렵다는 것을 알 수 있습니다. 특히 맨 밑에 있는 N번째 원판은 매우 제한적인 상황에서만 옮길 수 있습니다. 그럼에도 N번째 원판을 어떻게든 기둥 1에서 3으로 옮겨야 합니다.&lt;&#x2F;p&gt;
&lt;p&gt;N번째 원판을 기둥 1에서 3으로 옮길 수 있는 상황은 어떤 상황일까요?&lt;&#x2F;p&gt;
&lt;details&gt;
  &lt;summary&gt;해답&lt;&#x2F;summary&gt;
  (1) N번째 원판 위에 있는 다른 모든 원판을 어떻게든 치워야 하고, (2) 기둥 3에 아무 원판도 있지 않아야 합니다.
&lt;p&gt;그런 상황은 하나 밖에 없습니다. 기둥 1에 N번째 원판 하나, 기둥 2에 다른 모든 원판이 있고, 기둥 3은 비어있을 때입니다.&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;p&gt;그래서 맨 처음 해야 되는 일은…&lt;&#x2F;p&gt;
&lt;details&gt;
  &lt;summary&gt;해답&lt;&#x2F;summary&gt;
  어떻게든 &quot;다른 모든 원판&quot;을 전부 기둥 1에서 2로 옮기는 것입니다.
&lt;p&gt;그런데 이건 하노이 탑 문제와 동일합니다. 원판이 하나 줄었고 도착지가 바뀌었을 뿐입니다.&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;p&gt;그러면 그 문제는 어떻게 풀어야 할까요?&lt;&#x2F;p&gt;
&lt;details&gt;
  &lt;summary&gt;해답&lt;&#x2F;summary&gt;
  같은 문제가 다시 등장했으니 재귀를 사용합니다.
&lt;p&gt;재귀의 규칙에 따라, 원판 N-1개를 다 옮길 수 있다고 가정하고 &lt;strong&gt;구체적으로 어떻게 옮기는지는 생각하지 않습니다.&lt;&#x2F;strong&gt; 도착점 이슈는 번호를 다시 붙이면 같은 문제가 되기 때문에 걱정할 필요가 없습니다. 그렇게 가정하고… 가정에 따라 그냥 옮기면 됩니다.&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;p&gt;나머지 과정은 비슷합니다. N번째 원판을 1에서 3으로 옮기고, 2에 있었던 “다른 모든 원판“을 전부 3으로 옮깁니다. 이번에도 구체적으로 어떻게 옮기는지는 생각하지 않습니다.&lt;&#x2F;p&gt;
&lt;p&gt;이를 정리하면,&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;재귀적으로 원판 N-1개짜리 하노이 탑을 풀어서 1에서 2로 옮긴다.&lt;&#x2F;li&gt;
&lt;li&gt;N번째 원판을 1에서 3으로 옮긴다.&lt;&#x2F;li&gt;
&lt;li&gt;재귀적으로 원판 N-1개짜리 하노이 탑을 풀어서 2에서 3으로 옮긴다.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;가 됩니다. 이제 위 과정을 그대로 코드로 옮기면 끝입니다. (물론 원판이 1개일 때는 따로 처리합시다.) 재귀의 규칙을 잘 따랐기 때문에 올바르게 동작합니다.&lt;&#x2F;p&gt;
&lt;p&gt;그래도 조금 의심된다면 풀이를 검토해 봅시다.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;1번 과정이 끝나면 원판 1부터 N-1까지가 기둥 1에서 2로 옮겨집니다. 재귀의 규칙에 따라, &lt;strong&gt;그게 왜 되는지는 생각하지 않습니다.&lt;&#x2F;strong&gt; 그냥 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;그 상태에서는 N번째 원판을 1에서 3으로 옮길 수 있습니다.&lt;&#x2F;li&gt;
&lt;li&gt;3번 과정이 끝나면 원판 1부터 N-1까지가 기둥 2에서 3으로 옮겨집니다. 이번에도 그게 왜 되는지는 생각하지 않습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h1 id=&quot;ige-jinjja-dwaeyo&quot;&gt;이게 진짜 돼요?&lt;&#x2F;h1&gt;
&lt;p&gt;얼핏 보면 뭔가 사기인 것 같지만, 이 논리가 통하는 이유는 다음과 같습니다.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;factorial(0) = 1&lt;&#x2F;code&gt;입니다. 재귀 함수에서 이 경우를 따로 처리했을 것입니다.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;factorial(1) = 1 * factorial(0)&lt;&#x2F;code&gt;입니다. 바로 위에서 &lt;code&gt;factorial(0) = 1&lt;&#x2F;code&gt;임을 이미 파악했습니다. 따라서 &lt;code&gt;factorial(1) = 1 * 1 = 1&lt;&#x2F;code&gt;입니다.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;factorial(2) = 2 * factorial(1)&lt;&#x2F;code&gt;입니다. 바로 위에서 &lt;code&gt;factorial(1) = 1&lt;&#x2F;code&gt;임을 이미 파악했습니다. 따라서 &lt;code&gt;factorial(2) = 2 * 1 = 2&lt;&#x2F;code&gt;입니다.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;factorial(3) = 3 * factorial(2)&lt;&#x2F;code&gt;입니다. 바로 위에서 &lt;code&gt;factorial(2) = 2&lt;&#x2F;code&gt;임을 이미 파악했습니다. 따라서 &lt;code&gt;factorial(3) = 3 * 2 = 6&lt;&#x2F;code&gt;입니다.&lt;&#x2F;li&gt;
&lt;li&gt;…&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;factorial(N) = N * factorial(N-1)&lt;&#x2F;code&gt;입니다. 바로 위에서 &lt;code&gt;factorial(N-1) = (N-1)!&lt;&#x2F;code&gt;임을 이미 파악했습니다. 따라서 &lt;code&gt;factorial(N) = N * (N-1)! = N!&lt;&#x2F;code&gt;입니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;하노이 탑도 마찬가지입니다.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;원판이 1개일 때 잘 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;원판이 1개일 때 잘 된다고 가정하면, 재귀의 규칙에 따라 원판이 2개일 때도 잘 됩니다. 원판이 1개일 때 잘 된다는 것을 바로 위에서 파악했습니다. 따라서 원판이 2개일 때도 잘 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;원판이 2개일 때 잘 된다고 가정하면, 재귀의 규칙에 따라 원판이 3개일 때도 잘 됩니다. 원판이 2개일 때 잘 된다는 것을 바로 위에서 파악했습니다. 따라서 원판이 3개일 때도 잘 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;…&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;수학적 배경이 있으시다면 사실 이게 수학적 귀납법과 같은 이치임을 눈치채셨을 수도 있겠습니다. 이것이 바로 재귀의 본질입니다.&lt;&#x2F;p&gt;
&lt;details&gt;
  &lt;summary&gt;수학적 귀납법이란?&lt;&#x2F;summary&gt;
  자연수 $N$에 대한 명제 $P$를 증명할 때 다음 두 사실을 증명하는 테크닉을 수학적 귀납법이라고 합니다.
&lt;p&gt;(1) $P(0)$은 참이다. &lt;small&gt;0도 자연수라고 합시다.&lt;&#x2F;small&gt;&lt;&#x2F;p&gt;
&lt;p&gt;(2) 모든 자연수 $k$에 대해, $P(k)$가 참이라면 $P(k+1)$도 참이다.&lt;&#x2F;p&gt;
&lt;p&gt;그러면 $P(0)$이 참이고, $P(0)$이 참이니까 $P(1)$이 참이고, 그래서 $P(2)$도 참이고, … 어떤 $N$을 보더라도 $P(N)$이 참이기 때문에, 명제 $P$는 참입니다.&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;p&gt;이처럼 재귀의 규칙을 수학이 정당화해 주기 때문에, 우리는 재귀의 규칙을 따르는 것에만 신경 쓰면 됩니다. 심지어 저 “$P(1)$이 참이고 그래서 $P(2)$가 참이고…“에도 신경 쓸 필요가 없습니다. 컴퓨터와 수학이 알아서 처리해 줄 것입니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;biseushan-geul&quot;&gt;비슷한 글&lt;&#x2F;h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.encrypted.gg&#x2F;943&quot;&gt;BaaaaaaaarkingDog, 실전 알고리즘 0x0B강 - 재귀&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;velog.io&#x2F;@eddy_song&#x2F;you-can-solve-recursion#3%EB%8B%A8%EA%B3%84-%EB%B6%84%ED%95%B4-1&quot;&gt;Eddy, 야, 너두 재귀할 수 있어: 재귀가 풀리는 4단계 접근법&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;infossm.github.io&#x2F;blog&#x2F;2021&#x2F;07&#x2F;09&#x2F;recursion&#x2F;&quot;&gt;djm03178, 재귀 함수에 대한 이해&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Porgy My Beloved</title>
        <published>2025-01-30T00:00:00+00:00</published>
        <updated>2025-01-30T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              jh05013
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://jh05013.github.io/blog/ufo50-porgy/"/>
        <id>https://jh05013.github.io/blog/ufo50-porgy/</id>
        
        <content type="html" xml:base="https://jh05013.github.io/blog/ufo50-porgy/">&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;ufo1.jpeg&quot; alt=&quot;game selection screen of UFO 50, indicating that I obtained the cherry disk on Porgy, and additionally played Block Koala and Pilot Quest.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I heard of &lt;a href=&quot;https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;1147860&#x2F;UFO_50&#x2F;&quot;&gt;this UFO 50 thing&lt;&#x2F;a&gt;
while participating in Galactic Puzzle Hunt 2024.
The idea of 50 fully-fleshed games was something I could not ignore -
it’s too good to be true! So December last year, I went ahead and grabbed it.&lt;&#x2F;p&gt;
&lt;p&gt;My first pick was Porgy because the fish looked cute.
It also ended up being my first gold and cherry, before golding anything else.
I’ll just say, I loved every moment of the 7 hours I spent on this game!
And I’m not even a fan of Metroid-vania. Porgy just clicked well despite that.
&lt;small&gt;&lt;small&gt;Granted, I did look up the map on the internet for a tiny bit.&lt;&#x2F;small&gt;&lt;&#x2F;small&gt;&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;tip&quot;&gt;
	&lt;p class=&quot;alert-title&quot;&gt;
		&lt;i class=&quot;icon&quot;&gt;&lt;&#x2F;i&gt;Tip&lt;&#x2F;p&gt;
	&lt;p&gt;The Porgy experience gets tremendously better once you realize:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Your fuel bar is &lt;em&gt;not&lt;&#x2F;em&gt; a timer. It’s actually an odometer.
You don’t use fuel by staying in place. Feel free to take it slow!&lt;&#x2F;li&gt;
&lt;li&gt;You don’t use fuel by firing torpedo either. Spam torpedo.&lt;&#x2F;li&gt;
&lt;li&gt;You can hold B to keep firing torpedo, and lock your direction
(e.g. move left while shooting to the right).&lt;&#x2F;li&gt;
&lt;li&gt;When you return to the base without dying, you save your progress;
this includes upgrades, destroyed 2x2 big rocks, and &lt;strong&gt;damage dealt to bosses&lt;&#x2F;strong&gt;.
Seriously, 2nd layer bosses are pretty much impossible without realizing this.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;

&lt;&#x2F;blockquote&gt;
&lt;p&gt;A common complaint with Porgy seems to be that there are too few equipment slots,
but I think it was fine?
I saw a main challenge of this game as establishing and mastering your
exploration strategies under various limitations.
Equipment choice especially was a fun puzzle and I think
it made the gameplay a bit more interesting for me, in spite of
having to run back and forth a lot.
I mentally named a few of those sets as “Observer Porgy”, “Excavator Porgy”,
“Combatant Porgy”, “Treasure Hunter Porgy”, and so on.&lt;&#x2F;p&gt;
&lt;p&gt;My only wish is that the buster upgrade could have been permanent
because it’s almost always necessary.
All in all, the first experience with UFO 50 was a delight
and I can’t wait for the other 49 games.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Test test test</title>
        <published>2025-01-27T00:00:00+00:00</published>
        <updated>2025-01-27T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              jh05013
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://jh05013.github.io/blog/first/"/>
        <id>https://jh05013.github.io/blog/first/</id>
        
        <content type="html" xml:base="https://jh05013.github.io/blog/first/">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.getzola.org&#x2F;&quot;&gt;Zola&lt;&#x2F;a&gt; 라는 블로그 도구를 써보고 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;✨&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;This quote contains:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;bold&lt;&#x2F;strong&gt; &lt;em&gt;italic&lt;&#x2F;em&gt; &lt;del&gt;strikethrough&lt;&#x2F;del&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Items
&lt;ul&gt;
&lt;li&gt;Sub-items&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Items&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
Checkboxes&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot; checked=&quot;&quot;&#x2F;&gt;
No, you can’t click on them&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Also:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;numbered item&lt;&#x2F;li&gt;
&lt;li&gt;ok!&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&quot;&gt;link&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Footnote&lt;sup class=&quot;footnote-reference&quot; id=&quot;fr-1-1&quot;&gt;&lt;a href=&quot;#fn-1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; was here. Proof: let $\epsilon &amp;lt; 0$, then&lt;&#x2F;p&gt;
&lt;p&gt;$$
\int_0^1 x dx = \infty
$$
&lt;del&gt;Contradiction&lt;&#x2F;del&gt; &lt;ins&gt;QED&lt;&#x2F;ins&gt;&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;caution&quot;&gt;
	&lt;p class=&quot;alert-title&quot;&gt;
		&lt;i class=&quot;icon&quot;&gt;&lt;&#x2F;i&gt;Caution&lt;&#x2F;p&gt;
	&lt;p&gt;The proof above has
&lt;span class=&quot;spoiler solid&quot;&gt;an error&lt;&#x2F;span&gt;.
&lt;small&gt;Or does it?&lt;&#x2F;small&gt;
Can you find it?&lt;&#x2F;p&gt;
&lt;details&gt;
  &lt;summary&gt;Answer&lt;&#x2F;summary&gt;
  Yes, you can find it.
&lt;&#x2F;details&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;abbr title=&quot;Alternative Branching Cubes&quot;&gt;ABC&lt;&#x2F;abbr&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;h1&quot;&gt;H1&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;h2&quot;&gt;H2&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;h3&quot;&gt;H3&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;h4&quot;&gt;H4&lt;&#x2F;h4&gt;
&lt;h5 id=&quot;h5&quot;&gt;H5&lt;&#x2F;h5&gt;
&lt;h6 id=&quot;h6&quot;&gt;H6&lt;&#x2F;h6&gt;
&lt;p&gt;&lt;code&gt;code&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust z-code&quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span class=&quot;z-source z-rust&quot;&gt;&lt;span class=&quot;z-meta z-function z-rust&quot;&gt;&lt;span class=&quot;z-meta z-function z-rust&quot;&gt;&lt;span class=&quot;z-storage z-type z-function z-rust&quot;&gt;fn&lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;span class=&quot;z-entity z-name z-function z-rust&quot;&gt;main&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function z-rust&quot;&gt;&lt;span class=&quot;z-meta z-function z-parameters z-rust&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-parameters z-begin z-rust&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function z-rust&quot;&gt;&lt;span class=&quot;z-meta z-function z-parameters z-rust&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-parameters z-end z-rust&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function z-rust&quot;&gt; &lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function z-rust&quot;&gt;&lt;span class=&quot;z-meta z-block z-rust&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-rust&quot;&gt;{&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-rust&quot;&gt;&lt;span class=&quot;z-meta z-function z-rust&quot;&gt;&lt;span class=&quot;z-meta z-block z-rust&quot;&gt;  &lt;span class=&quot;z-support z-macro z-rust&quot;&gt;println!&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-rust&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-rust&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-rust&quot;&gt;&lt;span class=&quot;z-string z-quoted z-double z-rust&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-string z-begin z-rust&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;block of code&lt;span class=&quot;z-punctuation z-definition z-string z-end z-rust&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-rust&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-rust&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-rust&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-rust&quot;&gt;&lt;span class=&quot;z-meta z-function z-rust&quot;&gt;&lt;span class=&quot;z-meta z-block z-rust&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-block z-rust&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-rust&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;hr &#x2F;&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;z&lt;&#x2F;th&gt;&lt;th&gt;x&lt;&#x2F;th&gt;&lt;th&gt;c&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;asd&lt;&#x2F;td&gt;&lt;td&gt;sdf&lt;&#x2F;td&gt;&lt;td&gt;dfg&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;asd&lt;&#x2F;td&gt;&lt;td&gt;sdf&lt;&#x2F;td&gt;&lt;td&gt;dfg&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h1 id=&quot;media&quot;&gt;Media&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;upload.wikimedia.org&#x2F;wikipedia&#x2F;commons&#x2F;thumb&#x2F;2&#x2F;24&#x2F;Male_mallard_duck_2.jpg&#x2F;800px-Male_mallard_duck_2.jpg&quot; alt=&quot;Title text&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;fviewunc&quot; alt=&quot;Title text when image is not available&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;iframe
	class=&quot;youtube-embed&quot;
	src=&quot;https:&#x2F;&#x2F;www.youtube-nocookie.com&#x2F;embed&#x2F;dQw4w9WgXcQ&quot;
	allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot;
	referrerpolicy=&quot;strict-origin-when-cross-origin&quot; allowfullscreen&gt;
&lt;&#x2F;iframe&gt;
&lt;aside&gt;
asdf
&lt;&#x2F;aside&gt;
&lt;p&gt;Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum
Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum
Lorem ipsum Lorem ipsum Lorem ipsvm Lorem ipsum Lorem ipsum
Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum
Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum
Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum
Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum&lt;&#x2F;p&gt;
&lt;div class=&quot;buttons&quot;&gt;
  &lt;a href=&quot;#top&quot;&gt;Go to Top&lt;&#x2F;a&gt;
  &lt;a class=&quot;colored external&quot; href=&quot;https:&#x2F;&#x2F;example.org&quot;&gt;Example&lt;&#x2F;a&gt;
&lt;&#x2F;div&gt;
&lt;h1 id=&quot;forms&quot;&gt;Forms&lt;&#x2F;h1&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;input type=&quot;checkbox&quot; &#x2F;&gt;
    &lt;label&gt;&amp;nbsp;Ok you *can* click on these&lt;&#x2F;label&gt;
  &lt;&#x2F;li&gt;
  &lt;li&gt;
    &lt;input type=&quot;checkbox&quot; checked &#x2F;&gt;
    &lt;label&gt;&amp;nbsp;Here I clicked them for u&lt;&#x2F;label&gt;
  &lt;&#x2F;li&gt;
  &lt;li&gt;
    &lt;input type=&quot;checkbox&quot; disabled &#x2F;&gt;
    &lt;label&gt;&amp;nbsp;Except this one&lt;&#x2F;label&gt;
  &lt;&#x2F;li&gt;
  &lt;li&gt;
    &lt;input type=&quot;checkbox&quot; class=&quot;switch&quot; &#x2F;&gt;
    &lt;label&gt;&amp;nbsp;??&lt;&#x2F;label&gt;
  &lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;input type=&quot;radio&quot; name=&quot;test&quot; &#x2F;&gt;
    &lt;label&gt;&amp;nbsp;Milk&lt;&#x2F;label&gt;
  &lt;&#x2F;li&gt;
  &lt;li&gt;
    &lt;input type=&quot;radio&quot; name=&quot;test&quot; &#x2F;&gt;
    &lt;label&gt;&amp;nbsp;Eggs&lt;&#x2F;label&gt;
  &lt;&#x2F;li&gt;
  &lt;li&gt;
    &lt;input type=&quot;radio&quot; name=&quot;test&quot; &#x2F;&gt;
    &lt;label&gt;&amp;nbsp;Flour&lt;&#x2F;label&gt;
  &lt;&#x2F;li&gt;
  &lt;li&gt;
    &lt;input type=&quot;radio&quot; name=&quot;test&quot; checked &#x2F;&gt;
    &lt;label&gt;&amp;nbsp;Coffee&lt;&#x2F;label&gt;
  &lt;&#x2F;li&gt;
  &lt;li&gt;
    &lt;input type=&quot;radio&quot; name=&quot;test&quot; disabled &#x2F;&gt;
    &lt;label&gt;&amp;nbsp;Combustible lemons&lt;&#x2F;label&gt;
  &lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;label&gt;Color:&lt;&#x2F;label&gt;
&lt;input type=&quot;color&quot; value=&quot;#000000&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;input type=&quot;range&quot; max=&quot;100&quot; value=&quot;33&quot; id=&quot;range&quot;&gt;
&lt;footer class=&quot;footnotes&quot;&gt;
&lt;ol class=&quot;footnotes-list&quot;&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;footnote, yes. &lt;a href=&quot;#fr-1-1&quot;&gt;↩&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;footer&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>우연히 2018 정올 예선 문제들의 출처를 찾아버렸습니다.</title>
        <published>2025-01-01T00:00:00+00:00</published>
        <updated>2025-01-01T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              jh05013
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://jh05013.github.io/blog/koi2018-source/"/>
        <id>https://jh05013.github.io/blog/koi2018-source/</id>
        
        <content type="html" xml:base="https://jh05013.github.io/blog/koi2018-source/">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Henry_Dudeney&quot;&gt;헨리 듀드니(Henry Dudeney)&lt;&#x2F;a&gt;는
샘 로이드, 마틴 가드너 등과 함께 19-20세기의 수학 퍼즐 시대를 풍미하던 수학자였습니다.&lt;&#x2F;p&gt;
&lt;p&gt;그의 활동기로부터 100년 가량 지난 때에 열린
2018년 정보올림피아드 예선은 검수를 했는지 의심될 정도로 수많은 문제점이 터져 나온 대회였습니다.
말하면 끝도 없지만, 이 글의 초점은 아닙니다.
이 대회를 7년이 지난 지금 다시 이야기하고 있는 이유는, 수학 퍼즐을 수집하다가 2018 정올 예선의
일부가 헨리 듀드니의 퍼즐을 그대로 가져온 것이라는 사실을 우연히 알게 되었기 때문입니다…&lt;&#x2F;p&gt;
&lt;h1 id=&quot;1&quot;&gt;1&lt;&#x2F;h1&gt;
&lt;blockquote&gt;
&lt;p&gt;동네의 어려운 아이들에게 매주 조금씩 용돈을 나눠주는 것을 즐기는 마음씨 좋은 할아버지가 있었다. 하루는 이 할아버지가 다음 주에 네 명이 더 오게 된다면 용돈을 천원씩 덜 줄 수 밖에 없겠구나 라고 얘기했다. 그랬더니 다음 주에는 더 어려운 친구들에게 용돈을 주라며 그 지난주 보다 다섯 명이 덜 오게 되었다. 그래서 모인 아이들은 이천원씩을 더 받아가게 되었다. 한 명이 받아간 돈은? 단, 할아버지가 매주 아이들에게 나누어 주는 용돈의 총합은 같다.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;이 문제는 헨리 듀드니의 Generous Gifts 문제입니다.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;A generous man set aside a certain sum of money for equal distribution weekly to the needy of his acquaintance. One day he remarked: “If there are five fewer applicants next week, you will each receive 2 shillings more.” Unfortunately, instead of there being fewer there were actually four more persons applying for the gift. “This means,” he pointed out, “that you will each receive one shilling less.” Now, how much did each person receive at that last distribution?&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;5명 덜 오는 것과 4명 더 오는 것이 뒤바뀐 점만 제외하면 동일한 문제입니다.
안타깝게도 번역에 몇 가지 문제점이 있었는데요…&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;가장 치명적인 오류로, “equal distribution“은 각 아이한테 똑같이 나눠준다는 뜻인데
매주 나눠주는 총합이 같다는 것으로 오역해서 정답이 없는 문제가 되었습니다.&lt;&#x2F;li&gt;
&lt;li&gt;그런데 “총합“이 어디서 온 걸까요? 바로 “sum of money“입니다.
하지만 이건 돈의 총합이라는 뜻이 아니라 그냥 액수를 의미합니다.
Sum이라고 다 합을 뜻하는 게 아니에요…&lt;&#x2F;li&gt;
&lt;li&gt;큰따옴표가 사라져서 끔찍한 비문이 되었습니다. 할아버지가 네 명이 더 온다고요?&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;2&quot;&gt;2&lt;&#x2F;h1&gt;
&lt;blockquote&gt;
&lt;p&gt;한 농부가 시장에 가서 백마리의 동물을 구매하는데 총 일천만원이 들었다. 송아지 한마리에 오십만원, 새끼양 한마리에 일십만원, 그리고 토끼는 한마리에 오천원이 들었다면, 농부가 구매한 토끼는 몇 마리인가?&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;헨리 듀드니의 Market Transactions 문제입니다.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;A farmer goes to market and buys 100 animals at a total cost of £100. The price of cows being £5 each, sheep £1 each, and rabbits 1s. each, how many of each kind does he buy? Most people will solve this, if they succeed at all, by more or less laborious trial, but there are several direct ways of getting the solution.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;풀이에서 각 동물을 한 마리는 샀다는 걸 가정하는데 왜인지는 잘 모르겠습니다.
원래는 심심풀이 퍼즐로 낸 문제라서 어느 정도의 모호성은 이해가 되지만,
대회 문제로 그대로 옮기진 말았어야 할 것 같습니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;3&quot;&gt;3&lt;&#x2F;h1&gt;
&lt;blockquote&gt;
&lt;p&gt;어떤 사람이 바람 방향으로 자전거를 타고 1 km를 가는데 3분이 걸렸다. 바람의 세기가 동일한 상태에서 돌아오는 길은 4분이 걸렸다면, 바람이 불지 않을 때는 1 km를 가는데 얼마나 걸릴까? 단, 자전거 페달을 밟는 힘은 항상 일정하다.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;이것도 헨리 듀드니의 Riding in the Wind 문제입니다.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;A man on a bicycle rode a mile in 3 minutes with the wind at his back, but it took him 4 minutes to return against the wind. How long would it take him to ride a mile if there was no wind?&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;문제를 푸는 데 필요한 기본적인 가정이 다 빠져있는 이유는 바로
원본이 심심풀이 퍼즐로 낸 문제였기 때문이 아니었을까요?
아무튼 이것도 대회 문제로 그대로 옮기진 말았어야 할 것 같습니다.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>빅-O, 빅-Ω, 빅-Ө는 최악, 최선, 평균을 의미하지 않습니다.</title>
        <published>2024-12-18T00:00:00+00:00</published>
        <updated>2024-12-18T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              jh05013
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://jh05013.github.io/blog/big-o/"/>
        <id>https://jh05013.github.io/blog/big-o/</id>
        
        <content type="html" xml:base="https://jh05013.github.io/blog/big-o/">&lt;p&gt;&lt;em&gt;이 글은 &lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;blog&#x2F;view&#x2F;136&quot;&gt;BOJ 블로그에 있는 글&lt;&#x2F;a&gt;과 동일합니다.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;알고리즘 공부를 시작할 때 맨 처음 만나는 개념 중 시간, 공간 복잡도가 있습니다.
안타깝게도, 이는 오개념이 가장 많이 퍼진 주제이기도 합니다.
여러 오개념이 있지만 이 글에서는…&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;“빅-Ω 표기법은 최선의 경우를 다룰 때 사용한다. 빅-Ө 표기법은 평균의 경우를 다룰 때 사용한다. 빅-O 표기법은 최악의 경우를 다룰 때 사용한다.”&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;…라는 오개념을 다룹니다. 이 주장은 각종 블로그 글은 물론, 이름 있는 출처에도 가끔씩 나오며
&lt;a href=&quot;https:&#x2F;&#x2F;hanbit.co.kr&#x2F;channel&#x2F;category&#x2F;category_view.html?cms_code=CMS7965376216&quot;&gt;심지어 책으로도 나왔습니다&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;잘못된 말입니다. 빅-O, 빅-Ω, 빅-Ө 표기법은 그 자체로 최선, 최악 등의 경우를 가정하지 않으며,
&lt;strong&gt;세 표기법 모두를 최선, 최악, 평균의 경우에 모두 사용할 수 있습니다.&lt;&#x2F;strong&gt;
단지 최악의 경우 및 빅-O 표기법을 가장 많이 쓸 뿐입니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;olbareun-yongrye&quot;&gt;올바른 용례&lt;&#x2F;h1&gt;
&lt;p&gt;“길이가 n인 정수 리스트 L에 정수 target이 있는지 판별하세요“라는 문제를
다음과 같은 의사코드로 풀었다고 해봅시다.&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;function find(L, target):
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  for x in L:
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    if x == target: return true
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  return false
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;최악의 경우는 L에 target이 없어서 L 전부를 훑어볼 때이고,
최선의 경우는 맨 첫 수가 target과 같을 때입니다. 따라서&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;이 알고리즘의 최선의 경우 시간 복잡도는 O(1)이자, Ω(1)이자, Ө(1)입니다.&lt;&#x2F;li&gt;
&lt;li&gt;이 알고리즘의 최악의 경우 시간 복잡도는 O(n)이자, Ω(n)이자, Ө(n)입니다.&lt;&#x2F;li&gt;
&lt;li&gt;평균 시간 복잡도는 정의하기 조금 어렵지만, 직관적으로 생각할 수 있는 평균의 기준을 따른다면 시간 복잡도는 O(n)이자, Ω(n)이자, Ө(n)일 것입니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;시간 복잡도가 O(f(n))이라는 것은 수행 시간이 최대 f(n)만큼 커진다는 뜻입니다.
그것뿐입니다. 정확히 무슨 수행 시간인지는 맥락에 따라 다릅니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;sanghaneun-coeageul-yimihaji-anhseubnida&quot;&gt;상한은 최악을 의미하지 않습니다&lt;&#x2F;h1&gt;
&lt;p&gt;“빅-O 표기법은 수행 시간의 상한을 표현한다“는 맞는 말입니다.
최악의 경우에서 빅-O 표기법을 쓰면 최악의 수행 시간의 상한이 되고,
최선의 경우에서 빅-O 표기법을 쓰면 최선의 수행 시간의 상한이 됩니다.
딱 보면 뭔가 말이 안 되는 것 같은데요.&lt;&#x2F;p&gt;
&lt;p&gt;쉬운 이해를 위해, 알고리즘 중간고사를 봤다고 생각해 봅시다.
시험이 막 끝나서 정확한 점수는 모르지만, 어느 정도 예상은 할 수 있습니다.
최악의 경우(실수를 꽤 했을 때)와 최선의 경우(시도한 문제들의 풀이가 완벽할 때)
얼마나 받을지 예상을 해봅니다.&lt;&#x2F;p&gt;
&lt;p&gt;이제 친구가 여러분에게 물어봅니다. “몇 점 받을 것 같아?”&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;“못 봐도 80점은 나오지 않을까?“라고 답한다면,
“못 봐도“는 최악의 경우, “80점“은 예상 점수의 하한입니다.
아무리 실수를 많이 해서 마구 틀리더라도 적어도 80점은 될 것 같다는 뜻입니다.&lt;&#x2F;li&gt;
&lt;li&gt;“잘 보면 90점도 나올 것 같아!“라고 답한다면,
“잘 보면“은 최선의 경우, “90점“은 예상 점수의 하한입니다.
정말 잘 봐서 시도한 모든 풀이가 완벽하면 적어도 90점은 될 것 같다는 뜻입니다.&lt;&#x2F;li&gt;
&lt;li&gt;“못 보면 70점 밑으로도 갈 것 같아…“라고 답한다면,
“못 보면“은 최악의 경우, “70점“은 예상 점수의 상한입니다.&lt;&#x2F;li&gt;
&lt;li&gt;“잘 봐도 60점 안 될 거야……“라고 답한다면,
“잘 봐도“는 최선의 경우, “60점“은 예상 점수의 상한입니다.
괜찮습니다. 기말고사를 잘 보면 되죠.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;이처럼 최선과 최악의 케이스에서 모두 예상 점수의 하한과 상한을 논할 수 있습니다.
중요한 것은 하한, 상한이 그 자체로 최선, 최악을 의미하는 것이 아니라,
단순히 &lt;em&gt;특정 시나리오&lt;&#x2F;em&gt;에서 예상 점수의 범위를 표현할 때 쓰인다는 것입니다.&lt;&#x2F;p&gt;
&lt;p&gt;알고리즘도 마찬가지입니다. 최선과 최악의 케이스에서 모두 수행 시간의 하한과 상한을 논할 수 있습니다.
하한, 상한은 단순히 &lt;em&gt;특정 시나리오&lt;&#x2F;em&gt;에서 수행 시간의 범위를 표현합니다. 그래서,&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;“최악의 시간 복잡도가 O(n)“이라는 것은, 최악의 경우에 정확한 연산 횟수는 세보지 않았지만
그래도 선형 시간 안에는 돈다는 뜻입니다. 이때 n은 &lt;em&gt;최악의 경우&lt;&#x2F;em&gt;에 대한 상한입니다.&lt;&#x2F;li&gt;
&lt;li&gt;“최선의 시간 복잡도가 O(n)“이라는 것은, 최선의 경우에 정확한 연산 횟수는 세보지 않았지만
그래도 선형 시간 안에는 돈다는 뜻입니다. 이때 n은 &lt;em&gt;최선의 경우&lt;&#x2F;em&gt;에 대한 상한입니다.&lt;&#x2F;li&gt;
&lt;li&gt;“최악의 시간 복잡도가 Ω(n)“이라는 것은, 최악의 …중략…
그래도 선형 시간보다 빠르지는 않다는 뜻입니다.&lt;&#x2F;li&gt;
&lt;li&gt;“최악의 시간 복잡도가 Ө(n)“이라는 것은, 최악의 …중략…
그래도 딱 선형 시간이 걸린다는 뜻입니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;그러고 보니 Ө도 하나 얘기를 해야 되는데요…&lt;&#x2F;p&gt;
&lt;h1 id=&quot;big-oneun-jungganeul-yimihajido-anhseubnida&quot;&gt;빅-Ө는 중간을 의미하지도 않습니다&lt;&#x2F;h1&gt;
&lt;p&gt;비슷한 오개념으로 “빅-Ө는 빅-O와 빅-Ω의 중간을 의미한다“라는 것이 있습니다.
n과 n^2의 중간은 어디일까요?&lt;&#x2F;p&gt;
&lt;p&gt;시간 복잡도가 Ө(f(n))이라는 것은 O(f(n))인 동시에 Ω(f(n))이라는 뜻입니다.
알고 있는 Ω(하한)과 O(상한)이 다르다면, Ө는 아마도 중간 어딘가이긴 하겠지만,
정확히는 Ө를 논할 수 없다고 말해야 옳습니다.
O와 Ω가 한 함수에서 딱 만나야 Ө가 생기는 것입니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;ohaega-peojin-iyu&quot;&gt;오해가 퍼진 이유&lt;&#x2F;h1&gt;
&lt;p&gt;“빅-O가 최악의 경우를 의미한다“라는 오개념이 퍼진 이유는 여러 가지가 있겠지만,
이런 이유를 들 수 있을 것 같습니다.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;빅-O와 최악의 경우가 대개 자주 엮입니다.
아무 입력이나 들어올 수 있는 온라인 저지 환경에서는 최악의 경우에서도 빠른 알고리즘이 선호됩니다.
그리고 수행 시간이 얼마 이하임을 알아야 알고리즘이 정당하다고 할 수 있는데,
그 상한의 역할을 하는 게 빅-O 표기법입니다.
그래서 알고리즘 문제 풀이에서는 빅-O로 최악의 시간 복잡도를 구하는 경우가 많습니다.&lt;&#x2F;li&gt;
&lt;li&gt;“상한“과 “최악의 경우“가 의미상으로 비슷해 보입니다.
그도 그럴 게, 최악의 시간 복잡도가 O(f(n))인 알고리즘은 모든 경우에서 O(f(n))의 시간에 돕니다.
최악의 시간 복잡도는 어떻게 보면 모든 입력의 시간 복잡도에 대한 상한인 셈입니다.
하지만 다시 정리하자면 빅-O에서 얘기하는 상한은 최선, 최악 관계없이
&lt;em&gt;특정 경우&lt;&#x2F;em&gt;에서 함수의 상한을 얘기하는 것으로, 꼭 모든 경우에 대한 상한일 필요는 없습니다.&lt;&#x2F;li&gt;
&lt;li&gt;Ө를 쓸 수 있는 상황에서도 O를 쓰는 경우가 많습니다.
물론 잘못된 것은 아니지만, 최악과 빅-O가 더 깊게 엮이는 효과를 어느 정도 불렀을 것 같습니다.
(사실 저도 씁니다. 셋 중에 아스키 문자가 O밖에 없어서요…)&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;빅-O가 최악의 경우를 뜻한다고 잘못 생각한다면,
반대로 빅-Ω가 최선의 경우라고 잘못 생각하는 것도 자연스러워 보입니다.
그리고 최악과 최선을 빼고 남은 게 평균이라서
빅-Ө가 평균이라는 오개념까지 완성된 게 아닐까 추정해 봅니다.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>ICPC World Finals 2022&#x2F;23 풀이</title>
        <published>2024-06-26T00:00:00+00:00</published>
        <updated>2024-06-26T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              jh05013
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://jh05013.github.io/blog/wf2022/"/>
        <id>https://jh05013.github.io/blog/wf2022/</id>
        
        <content type="html" xml:base="https://jh05013.github.io/blog/wf2022/">&lt;p&gt;구현하지 않은 게 있어서 틀린 내용이 있을 수도 있습니다.
제가 구현해서 정답 받은 건 ✅로 표시했습니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;46p-47g-turning-red&quot;&gt;46P&#x2F;47G. Turning Red&lt;&#x2F;h1&gt;
&lt;p&gt;스위치 $i$를 누른 횟수를 $x_i$라고 합시다. $x_i$는 0, 1, 2 중 하나여야 최적입니다.&lt;&#x2F;p&gt;
&lt;p&gt;각 전구가 최대 두 스위치에 연결되어 있다는 점에 주목합시다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;전구가 아무 스위치에도 연결되지 않았다면, 그 전구가 붉은색이면 무시합니다. 아니라면 impossible입니다.&lt;&#x2F;li&gt;
&lt;li&gt;전구가 스위치 1개 $i$에만 연결되었다면, $x_i$의 값이 하나로 고정됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;전구가 스위치 2개 $i, j$에 연결되었다면, $x_i + x_j$ mod 3의 값이 하나로 고정됩니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;스위치 1개짜리 전구로 $x_i$ 값들을 고정한 다음, 스위치 2개짜리 전구를 간선 $(i, j)$로 나타내고, 가중치를 그 고정된 $x_i + x_j$ mod 3값으로 둡시다. 이제 이분그래프 판별과 비슷한 방법으로 모든 조건에 맞는 해가 있는지 판별할 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;조건에 맞는 해가 있다면, 연결 요소마다 가능한 해가 최대 3개입니다. 3개의 후보 중 최적인 것을 골라서 모두 합하면 됩니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;white-check-mark-46q-doing-the-container-shuffle&quot;&gt;✅ 46Q. Doing the Container Shuffle&lt;&#x2F;h1&gt;
&lt;p&gt;기댓값의 선형성에 의해&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;1을 뽑는 데 필요한 행동 수의 기댓값&lt;&#x2F;li&gt;
&lt;li&gt;모든 $x$에 대해, $x$를 막 뽑은 상태에서 $x+1$을 뽑는 데 필요한 행동 수의 기댓값&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;의 합을 구하면 됩니다. 편의상 스택에서 트럭으로 옮기는 건 제외하고, 최종 답에 $n$을 더해서 출력합시다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;1을 뽑는 데 필요한 행동 수의 기댓값&lt;&#x2F;strong&gt;은 맨 처음에 1 위에 쌓인 물건 개수의 기댓값과 같습니다. 다시 기댓값의 선형성에 의해 이 값은 (순열에서 1 뒤에 있는 물건의 개수) &#x2F; 2입니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;$x$를 막 뽑은 상태에서 $x+1$을 뽑는 데 필요한 행동 수의 기댓값&lt;&#x2F;strong&gt;은 좀 더 복잡합니다. 일반성을 잃지 않고 $x$가 맨 처음에 왼쪽 스택에 들어갔다고 합시다.&lt;&#x2F;p&gt;
&lt;p&gt;우선 순열에서 $x+1$이 $x$보다 먼저 등장하는 경우를 생각해 봅시다. 순열을 &lt;code&gt;A x+1 B x C&lt;&#x2F;code&gt; 로 나타내면 스택의 맨 처음 상태로는 다음 두 경우가 가능하고, 각각이 나올 확률은 1&#x2F;2입니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;wf221.png&quot; alt=&quot;.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;$x$를 막 뽑은 상태에서 스택의 모습은 다음과 같습니다. $C_L$이 거꾸로 써진 것은 순서가 뒤집혀 있음을 나타냅니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;wf223.png&quot; alt=&quot;.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;$A_L$의 크기를 $|A_L|$, 그 크기의 기댓값을 $E[|A_L|]$이라고 합시다. 그러면 $E[|A_L|] = \frac{|A|}{2}$입니다. $A_R$, $B_L$, $B_R$, $C_L$, $C_R$도 마찬가지입니다. 단, $|A|$를 구할 때는 $x$보다 큰 수만 세어야 합니다. 그보다 작은 수는 이미 제거되었기 때문입니다. 이제 왼쪽의 기댓값은 $\frac{|B|}{2}$, 오른쪽은 $\frac{|B|}{2} + |C|$이므로, 전체 기댓값은 둘의 평균인 $\frac{|B| + |C|}{2}$입니다.&lt;&#x2F;p&gt;
&lt;p&gt;순열에서 $x+1$이 $x$보다 나중에 나오는 경우도 비슷하게 풀어보면&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;wf224.png&quot; alt=&quot;.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;이번에도 $\frac{|B| + |C|}{2}$가 나옵니다.&lt;&#x2F;p&gt;
&lt;p&gt;이를 종합해 보면, 순열에서 $x$와 $x+1$중 먼저 나오는 쪽을 찾고, 그의 오른쪽에 있으면서 $x+1$보다 큰 수의 개수를 구해 2로 나누면 됩니다. 이 값은 펜윅 트리로 구할 수 있습니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;46r-zoo-management&quot;&gt;46R. Zoo Management&lt;&#x2F;h1&gt;
&lt;p&gt;한 번의 행동에서 사용한 간선은 vertex-disjoint cycle들을 이뤄야 합니다. 편의상 한번에 한 사이클만 고른다고 합시다. 그러면 각 행동은 “사이클을 하나 골라서 한 칸 아무 방향으로 회전시킨다“라고 할 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;아무 사이클에도 속하지 않는 간선, 즉 단절선은 영원히 사용할 수 없으므로 그래프에서 지워버릴 수 있습니다. 그러면 biconnected component 여러 개가 남고, 각각을 독립적으로 풀면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;Biconnected component가 정확히 사이클 1개라면 그냥 회전만 할 수 있습니다. KMP나 해싱 등 아무 방법으로 한 수열이 다른 수열의 회전인지 판별하면 됩니다. 예를 들어 KMP를 쓴다면, “다른 수열“을 복제하고 이어 붙여서 두 배로 늘리고, 거기서 “한 수열“을 찾으면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;Biconnected component가 사이클 2개 이상으로 이루어져 있다면, 모든 순열이 가능할 것처럼 생겼습니다. 하지만 정확히 그렇진 않습니다. 결론부터 말하면, component에 &lt;strong&gt;짝수&lt;&#x2F;strong&gt; 길이 사이클이 없으면 짝순열만 만들 수 있고, 아니면 모든 순열을 만들 수 있습니다. 증명은 생략하나, 사각형 두 개가 정점 하나를 공유하고 있는 그래프를 생각해보면 감이 올 수도 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;홀수 길이 사이클은 이분 그래프 판별로 풀 수 있다는 점이 잘 알려져 있는데, 짝수 길이 사이클은 어떻게 찾을까요? 짝수 길이 사이클이 없으면 component 전체가 선인장입니다. 간선을 공유하는 사이클이 2개 있다면 거기서 짝수 길이 사이클을 찾을 수 있기 때문입니다. 따라서 선인장인지 판별하고, 선인장의 각 블록 중 하나라도 짝수 길이 사이클인지 보면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;짝순열을 써서 우리가 원하는 동물 배치를 할 수 있다는 사실은 어떻게 알 수 있을까요? 동물 번호가 중복될 수도 있어서 곤란해 보입니다. 다행히도 생각보다 간단합니다. 중복되는 동물이 있다면, 두 배치가 그냥 순열 관계인지만 확인하면 됩니다. 중복되는 동물 한 쌍을 교환하면 순열의 홀짝성이 바뀌지만 배치는 그대로니까, 어떤 배치를 만들든 홀순열과 짝순열이 모두 가능하기 때문입니다. 중복되는 동물이 없다면 평소에 하던 대로 하면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;혹시나 해서 첨언하자면 순열의 홀짝성을 판별할 때 세그트리&#x2F;펜윅트리를 쓸 필요가 전혀 없습니다. 그냥 순열을 사이클로 분할했을 때 짝수 사이클의 개수의 홀짝성이 답입니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;white-check-mark-46s-47j-bridging-the-gap&quot;&gt;✅ 46S&#x2F;47J. Bridging the Gap&lt;&#x2F;h1&gt;
&lt;p&gt;$N &amp;lt; C$이면 그냥 입력된 수의 최댓값이 답입니다. ($N = C$여도 그렇지만, 상관없습니다.) 이제 $N \geq C$라고 가정합니다. 또한 건너는 시간이 오름차순으로 정렬되어 있다고 가정합니다. 즉 $i &amp;lt; j$이면 사람 $i$가 $j$보다 빠르거나 같습니다.&lt;&#x2F;p&gt;
&lt;p&gt;$C = 2$의 경우 &lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;4381&quot;&gt;이미 BOJ에 있는 문제&lt;&#x2F;a&gt;고, &lt;a href=&quot;https:&#x2F;&#x2F;page.mi.fu-berlin.de&#x2F;rote&#x2F;Papers&#x2F;pdf&#x2F;Crossing+the+bridge+at+night.pdf&quot;&gt;이런 논문&lt;&#x2F;a&gt;이 있습니다. 그 경우의 풀이를 찾고 더 큰 $C$에 대해 일반화하면 &lt;a href=&quot;https:&#x2F;&#x2F;www.sciencedirect.com&#x2F;science&#x2F;article&#x2F;pii&#x2F;S0167642315000118&quot;&gt;다른 논문&lt;&#x2F;a&gt; 및 이 문제의 풀이를 얻습니다. 이 글에서는 $C = 2$일 때의 증명과 일반적인 $C$에서의 결론만 소개하고, 일반적인 $C$에서의 증명은 생략합니다.&lt;&#x2F;p&gt;
&lt;p&gt;$C = 2$라고 가정합니다. 다리를 건너가는 것을 앞 횡단, 다시 건너 돌아오는 것을 뒤 횡단, 둘을 묶어서 횡단이라고 부릅시다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;정리 1.&lt;&#x2F;strong&gt; 모든 앞 횡단의 크기가 2명, 모든 뒤 횡단의 크기가 1명인 최적해가 존재합니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;증명.&lt;&#x2F;strong&gt; 그렇지 않은 횡단이 있다면, 그중 첫 횡단을 잡아 “문제의 횡단“이라고 합시다. 그럼 다음 4가지 케이스가 있고, 각각 더 좋은 해를 만들 수 있습니다. &lt;code&gt;&quot;&quot;&lt;&#x2F;code&gt; 로 감싼 것이 문제의 횡단입니다.&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Case 1: &amp;quot;앞[x]&amp;quot; 뒤[x] ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  -&amp;gt; ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Case 2: ... 앞[y,z] ...&amp;lt;x와 y는 안 움직임&amp;gt;... 뒤[y] &amp;quot;앞[x]&amp;quot; ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  -&amp;gt; ... 앞[x,z] ...&amp;lt;x와 y는 안 움직임&amp;gt;... ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Case 3: ... 뒤[x] ...&amp;lt;x와 y는 안 움직임&amp;gt;... 뒤[y] &amp;quot;앞[x]&amp;quot; ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  -&amp;gt; ... 뒤[y] ...&amp;lt;x와 y는 안 움직임&amp;gt;... ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Case 4: ... 앞[x,z] ...&amp;lt;x는 안 움직임&amp;gt;... &amp;quot;뒤[x,y]&amp;quot; ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  -&amp;gt; ... 앞[z] ...&amp;lt;x는 안 움직임&amp;gt;... 뒤[y] ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;■&lt;&#x2F;p&gt;
&lt;p&gt;그러한 최적해에서 앞 횡단은 $N-1$개, 뒤 횡단은 $N-2$개입니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;정리 2.&lt;&#x2F;strong&gt; 횡단에 소요되는 전체 시간은 (모든 앞 횡단에 대해, 더 느린 사람의 시간의 합) + (모든 사람에 대해, (그 사람이 건너는 시간) &lt;code&gt;*&lt;&#x2F;code&gt; (그 사람이 앞으로 횡단한 횟수 - 1)의 합)입니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;증명.&lt;&#x2F;strong&gt; 앞 항은 모든 앞 횡단의 시간의 합입니다. (앞으로 횡단한 횟수 - 1)은 (뒤로 횡단한 횟수)와 같고, 정리 1에 의해 모든 뒤 횡단의 크기는 1이므로, 뒤 항은 모든 뒤 횡단의 시간의 합입니다. ■&lt;&#x2F;p&gt;
&lt;p&gt;정리 2는 앞 횡단만 가지고 전체 횡단 시간을 계산할 수 있음을 의미합니다. 그렇다면 아예 뒤 횡단을 버리고, 특정 조건이 성립하는 앞 횡단만 잘 정해서 최적해를 탐색할 수 있으면 좋을 것 같습니다. 실제로 그런 데다가, 앞 횡단의 순서도 중요하지 않습니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;정리 3.&lt;&#x2F;strong&gt; 두 명짜리 앞 횡단 $p_1q_1, \cdots, p_{N-1}q_{N-1}$이 있을 때, 각 사람이 앞 횡단 중 적어도 하나에 포함된다면, 앞 횡단의 순서가 $p_1q_1, \cdots, p_{N-1}q_{N-1}$ 의 어떤 한 순열인 올바른 횡단 순서가 존재합니다.&lt;&#x2F;p&gt;
&lt;p&gt;앞 횡단을 $pq$로 표기했는데, 이때 $p$와 $q$ 사이 대소관계는 정해두지 않았습니다. $p &amp;lt; q$일 수도 있고 $p &amp;gt; q$일 수도 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;증명.&lt;&#x2F;strong&gt; 앞 횡단을 한 번만 하는 사람을 “정착민”, 그렇지 않은 사람을 “유목민“이라고 합시다.&lt;&#x2F;p&gt;
&lt;p&gt;$N$에 대한 귀납법을 사용합니다. $N = 2$면 자명합니다.&lt;&#x2F;p&gt;
&lt;p&gt;$N \geq 3$이라고 합시다. 각 사람의 앞 횡단 횟수의 평균은 $1 &amp;lt; \frac{2N-2}{N} &amp;lt; 2$이므로, 정착민과 유목민이 적어도 한 명씩은 존재합니다. 이제&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;정착민 $x$와 유목민 $y$로 이루어진 앞 횡단 $xy$가 있다면, $xy$를 제거하고 귀납법으로 $N-1$명짜리 횡단 순서를 얻어낸 다음, 뒤 횡단 $x$, 앞 횡단 $xy$를 덧붙이면 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;그렇지 않다면 $N \geq 4$이고, 정착민 2명짜리 앞 횡단 $xy$와 유목민 2명짜리 앞 횡단 $zw$가 있습니다. 둘 다 제거하고 귀납법으로 $N-2$명짜리 횡단 순서를 얻어낸 다음, 뒤 횡단 $z$, 앞 횡단 $xy$, 뒤 횡단 $w$, 앞 횡단 $zw$를 덧붙이면 됩니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;■&lt;&#x2F;p&gt;
&lt;p&gt;이제 뒤 횡단을 볼 필요가 없으니, 앞 횡단을 줄여서 그냥 “횡단“이라고 부르겠습니다. 횡단의 순서는 중요하지 않고, 조합만 찾으면 됩니다. 그중에서 구체적으로 어떤 형태가 최적인지 살펴봅시다.&lt;&#x2F;p&gt;
&lt;p&gt;직관적으로 생각해 보면, 우선 가장 빠른 사람들이 유목민 역할을 해야 할 것 같습니다. 또한 가장 오래 걸리는 사람들끼리 짝지어서 횡단해야 할 것 같고, 횡단 개수를 맞추려면 유목민을 중간에 섞어야 하는데, 유목민과 정착민이 같이 횡단해야 한다면 빠른 정착민들이랑 유목민 1이 같이 가야 할 것 같습니다. 이 성질들을 엄밀하게 정리하면 다음과 같습니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;정리 4.&lt;&#x2F;strong&gt; 다음을 모두 만족시키는 최적해가 존재합니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;(1) 유목민 $x, y$에 대해 횡단 $xy$가 있을 때, 그 횡단은 $12$입니다.&lt;&#x2F;li&gt;
&lt;li&gt;(2) 유목민 $x$와 정착민 $y$에 대해 횡단 $xy$가 있을 때, $x = 1$입니다.&lt;&#x2F;li&gt;
&lt;li&gt;(3) 정착민 $x, y, z$에 대해 횡단 $1x$와 $yz$가 있을 때, $x &amp;lt; y$, $x &amp;lt; z$입니다.&lt;&#x2F;li&gt;
&lt;li&gt;(4) 정착민 $x, y$에 대해 횡단 $xy$가 있을 때, $|x - y| = 1$입니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;다른 말로 하면 $12, 12, \cdots, 12, 13, 14, \cdots, 1k, [k+1][k+2], [k+3][k+4], \cdots, [N-1]N$ 꼴의 최적해가 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;증명.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;(1) 그렇지 않다면 $12$로 바꿔도 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;(2) 그렇지 않다면 $1y$로 바꿔도 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;(3) 일반성을 잃지 않고 $y &amp;lt; z$라고 합시다. $x &amp;gt; y$라면 $1y$와 $xz$로 바꿔도 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;(4) 위의 (1)(2)(3)에 의해, 정착민 2명짜리 횡단에 참여하는 사람들은 특정 $k$에 대해 $k, k+1, \cdots, N$입니다. $k$에 대한 귀납법을 거꾸로 사용합니다. $k &amp;gt; N$이라면 자명합니다. 횡단 $k[k+1]$이 없다면, 정착민 $x, y &amp;gt; k+1$에 대해 횡단 $kx$와 $ky$가 있습니다. 이를 $k[k+1]$과 $xy$로 바꿔도 됩니다. 귀납법에 의해 $k+2$ 또는 그 이후의 정착민에 대해서도 (4)가 성립합니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;■&lt;&#x2F;p&gt;
&lt;p&gt;후보가 대략 $\frac{N}{2}$개이므로 각각의 시간을 계산하여 $O(N^2)$에 풀 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;위 정리들은 더 큰 $C$에 대해 다음과 같이 일반화됩니다. 증명은 생략합니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;정리 1+.&lt;&#x2F;strong&gt; 모든 앞 횡단의 크기가 2명 이상, 모든 뒤 횡단의 크기가 1명인 최적해가 존재합니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;정리 2+&lt;&#x2F;strong&gt; 와 &lt;strong&gt;3+&lt;&#x2F;strong&gt; 는 정리 2, 3과 거의 같습니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;정리 4+.&lt;&#x2F;strong&gt; 다음을 모두 만족시키는 최적해가 존재합니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;(1&amp;amp;2) 횡단에 유목민이 $k$명 있을 때, 그 유목민은 $1, \cdots, k$입니다.&lt;&#x2F;li&gt;
&lt;li&gt;(4) 각 횡단에서 정착민의 번호는 연속합니다.&lt;&#x2F;li&gt;
&lt;li&gt;(3) 정착민이 있는 횡단을 가장 느린 사람의 시간에 대한 오름차순으로 정렬하면 유목민의 명수는 내림차순입니다.&lt;&#x2F;li&gt;
&lt;li&gt;(보너스) 정착민이 있는 횡단 중 크기가 $C$보다 작은 것은 최대 하나이며, 그 횡단은 $1, \cdots, (횡단\ 크기)$입니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;이제 알고리즘을 설계할 준비가 되었습니다. 맨 처음에 모든 사람들이 “색칠되지 않았다“고 하고, 추가로 횡단의 개수 조건을 맞추는 데 사용할 “빚“이라는 정수를 초기값 0으로 관리합시다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;(1) $C$명 이하가 색칠되지 않은 상태로 남을 때까지,
&lt;ul&gt;
&lt;li&gt;0 이상 $C-1$ 이하의 정수 $k$를 정합니다. $k$는 단조증가해야 합니다.   - 색칠되지 않은 맨 마지막 사람을 x라고 할 때, 유목민 $1, \cdots, k$와 정착민 $x-(C-k)+1, \cdots, x$를 횡단시키고, 빚에 $1-k$를 더합니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;(2) 빚이 0 미만이면 실패입니다. 아니라면 색칠되지 않은 사람들을 모두 횡단시킵니다.&lt;&#x2F;li&gt;
&lt;li&gt;(3) 빚이 0이 될 때까지,
&lt;ul&gt;
&lt;li&gt;2 이상 $C$ 이하의 정수 $k$를 정합니다.&lt;&#x2F;li&gt;
&lt;li&gt;유목민 $1, \cdots, k$를 횡단시키고, 빚에서 $k-1$을 뺍니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;(1)(3)에서 $k$를 잘 정하는 게 목표입니다. DP 식을 세워보면 (색칠되지 않은 사람 수, 빚, (1)에서 마지막으로 정한 $k$값)으로 $O(N^3)$개의 상태가 생길 것처럼 생겼습니다. 하지만&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;빚이 음수인 상태는 고려할 필요가 없습니다. 빚이 감소하려면 $k&amp;gt;1$이어야 하는데, 그러면 단조증가 조건에 의해 빚이 매번 감소해서 0으로 못 돌아오기 때문입니다.&lt;&#x2F;li&gt;
&lt;li&gt;빚은 $[\frac{N}{C}]$ 이하입니다. 빚이 증가하려면 $k=0$이어야 하는데, 그럴 때마다 빚이 1 증가하고 $C$명이 색칠되기 때문입니다.&lt;&#x2F;li&gt;
&lt;li&gt;빚이 항상 0이상이라는 조건이 있는 한 $k$가 단조증가해야 한다는 조건은 필요가 없고, 따라서 마지막으로 정한 $k$ 값도 볼 필요가 없습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;그러므로 상태 $O(\frac{N^2}{C})$개에 상태 당 전이 $C$개로 총 $O(N^2)$에 문제를 풀 수 있습니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;white-check-mark-46t-47d-carl-s-vacation&quot;&gt;✅ 46T&#x2F;47D. Carl’s Vacation&lt;&#x2F;h1&gt;
&lt;p&gt;최적의 경로는 (1) 출발 사각뿔의 한 면을 타고 직선을 따라 바닥에 내려가고, (2) 바닥에서 도착 사각뿔의 바닥으로 직선을 따라 이동하고, (3) 도착 사각뿔의 한 면을 타고 직선을 따라 꼭대기로 올라가야 합니다.&lt;&#x2F;p&gt;
&lt;p&gt;(2)의 시작점과 도착점은 정사각형의 한 변 위에 있습니다. 변을 하나씩 선택하고, 각 변 위의 정확히 어느 지점에서 출발하고 도착할 건지를 변수 $a$와 $b$로 나타내면, (1), (2), (3)의 길이는 모두 $a$와 $b$에 대한 볼록함수입니다. 볼록함수의 합 역시 볼록함수이므로, 전체 길이도 볼록함수입니다. 따라서 삼분탐색을 이중으로 중첩해서 쓰면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;물론 (2)에서 밑면을 뚫고 지나가면서 조건을 어기는 경우도 있겠지만, 그런 경우는 애초에 최적이 아닙니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;white-check-mark-46u-toy-train-tracks&quot;&gt;✅ 46U. Toy Train Tracks&lt;&#x2F;h1&gt;
&lt;p&gt;우선 직선 조각 $S$개, 커브 조각 $C$개를 &lt;strong&gt;다&lt;&#x2F;strong&gt; 써서 루프를 만들 수 있는지 판별해 봅시다. $S$와 $C$가 작은 경우부터 하나씩 손으로 풀어보면 규칙을 찾을 수 있습니다. 결론부터 말하면,&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$S$는 짝수여야 합니다.&lt;&#x2F;li&gt;
&lt;li&gt;$C$는 4 이상의 짝수여야 합니다.&lt;&#x2F;li&gt;
&lt;li&gt;$C \equiv 2 (mod\ 4)$이거나 $C = 8$일 경우, $S$는 2 이상이어야 합니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;나머지 경우가 불가능한 이유는 후술합니다.&lt;&#x2F;p&gt;
&lt;p&gt;가능한 경우는 $C = 4$, $C = 6$, $C = 8$, $C \equiv 2 (mod\ 4)$, $C \equiv 0 (mod\ 4)$로 케이스워크를 하면 됩니다.&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;r---q
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;L---J
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;r----q
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;|r---J
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;LJ
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;rq
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;|L---q
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;|r---J
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;LJ
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; rq
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;rJLq
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Lq Lq
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; Lq L---q
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  Lqr---J
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   LJ
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;r-q
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;| Lq
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Lq Lq
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; Lq L---q
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  Lqr---J
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   LJ
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;이제 본 문제를 풀어봅시다. 위 가능한 경우들을 정리해 보면 직선 조각을 1개 이하, 커브 조각을 7개 이하로 남기는 해가 존재하므로, $(S, C)$에 따라 최대 16개의 후보를 만들고 그중 가장 긴 것을 출력하면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;불가능한 경우 증명:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;S가 홀수이면 불가능&lt;&#x2F;strong&gt;: 격자를 체스판으로 색칠하고, 루프를 탔을 때 각 칸에 들어오는 방향을 생각해 봅시다. 커브 조각만 사용하면 검은 칸은 항상 가로로, 흰 칸은 항상 세로로 들어옵니다. (물론 그 반대여도 됩니다.) 직선 조각을 하나 타는 순간 두 색의 역할이 바뀝니다. 즉 검은 칸은 세로로, 흰 칸은 가로로 들어오게 됩니다. 루프를 한 바퀴 돌면 두 색의 역할이 유지되어야 하므로 직선 조각은 짝수 번 타야 합니다.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;C가 홀수이면 불가능&lt;&#x2F;strong&gt;: 커브 조각을 탈 때마다 이동 방향이 가로에서 세로로, 세로에서 가로로 바뀝니다. 루프를 한 바퀴 돌면 이동 방향이 유지되어야 하므로 커브 조각은 짝수 번 타야 합니다.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;S가 0, C가 4k+2 꼴이면 불가능&lt;&#x2F;strong&gt;: 한 칸에서 커브 조각을 두 번 타면 그 칸과 대각선 방향으로 인접한 칸으로 가게 됩니다. 커브 조각 4k+2개 대신 대각선 조각 2k+1개가 있다고 생각하고 위의 &lt;em&gt;C가 홀수이면 불가능&lt;&#x2F;em&gt; 논리를 쓰면 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;S가 0, C가 8이면 불가능&lt;&#x2F;strong&gt;: 직접 해보면 됩니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;white-check-mark-46v-47c-three-kinds-of-dice&quot;&gt;✅ 46V&#x2F;47C. Three Kinds of Dice&lt;&#x2F;h1&gt;
&lt;p&gt;편의상 1점, 0.5점이 아니라 2점, 1점씩 얻는다고 하고, 맨 마지막에 출력할 때 2로 나눕시다.&lt;&#x2F;p&gt;
&lt;p&gt;D3를 굴려서 x가 나왔을 때 내(D3)가 얻는 점수의 기댓값을 f(x)라고 하면, f는 같은 값으로 이루어진 $2n+1$개 이하의 구간으로 이루어집니다. 예를 들어 예시의 &lt;code&gt;1 1 6 6 8 8&lt;&#x2F;code&gt;과 &lt;code&gt;2 4 9&lt;&#x2F;code&gt;는&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;x   첫줄 다음줄
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;1   1&#x2F;3  0
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;2   2&#x2F;3  1&#x2F;3
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;3   2&#x2F;3  2&#x2F;3
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;4   2&#x2F;3  1
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;5   2&#x2F;3  4&#x2F;3
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;6   1    4&#x2F;3
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;7   4&#x2F;3  4&#x2F;3
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;8   5&#x2F;3  4&#x2F;3
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;9   2    5&#x2F;3
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;10  2    2
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;11  2    2
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;D3의 면마다 대응되는 f 값의 평균이 1 이상이면, D3는 그 주사위를 이기거나 비깁니다. 예를 들어 &lt;code&gt;(2&#x2F;3 + 2&#x2F;3 + 2)&#x2F;3 = 1.111...&lt;&#x2F;code&gt; 이므로 두 번째 주사위가 첫 번째 주사위를 이깁니다. 이것으로 둘 중 어느 쪽이 D1이고 어느 쪽이 D2인지 알아낼 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;이제 우리가 D3를 만들어야 합니다. 면의 개수를 마음대로 정할 수 있으므로, 각 x에 임의의 음이 아닌 유리수 가중치를 부여할 수 있습니다. 그 대신 가중치의 합은 1이라고 합시다. 또한 x의 값 말고 (D1의 f 값, D2의 f 값) 순서쌍이 중요하고, 서로 다른 순서쌍이 $4n+1$개 이하이므로, 가중치를 부여할 대상은 그 $4n+1$개뿐입니다. 이제 우리가 구할 값은&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;D1의 f 값에 대한 (가중치를 고려한) 평균이 1 이상일 때, D2의 f 값에 대한 평균의 최솟값&lt;&#x2F;li&gt;
&lt;li&gt;D2의 f 값에 대한 평균이 1 이하일 때, D1의 f 값에 대한 평균의 최댓값&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;입니다.&lt;&#x2F;p&gt;
&lt;p&gt;$(x, y)$ 순서쌍 여러 개에 음이 아닌 가중치를 뒀을 때 ($x$의 평균, $y$의 평균)으로 가능한 값의 영역은, $(x, y)$들을 좌표평면에 놓았을 때 볼록 껍질의 둘레 및 내부입니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;wf225.png&quot; alt=&quot;.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;따라서 답은 그 볼록 껍질과 직선 $x = 1$의 교점, 그리고 볼록 껍질과 직선 $y = 1$의 교점입니다. 가중치에 유리수 조건이 있지만, 교점의 좌표도 유리수이므로 적절한 유리수 가중치가 항상 존재함을 알 수 있습니다. 구체적으로 어느 교점을 출력해야 되는지는 $x$, $y$ 중 어느 쪽이 D1, D2인지에 따라 적절히 정하면 됩니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;white-check-mark-46w-47a-riddle-of-the-sphinx&quot;&gt;✅ 46W&#x2F;47A. Riddle of the Sphinx&lt;&#x2F;h1&gt;
&lt;ul&gt;
&lt;li&gt;1 0 0을 물어봅니다. 대답을 $a$라고 합시다.&lt;&#x2F;li&gt;
&lt;li&gt;0 1 0을 물어봅니다. 대답을 $b$라고 합시다.&lt;&#x2F;li&gt;
&lt;li&gt;0 0 1을 물어봅니다. 대답을 $c$라고 합시다.&lt;&#x2F;li&gt;
&lt;li&gt;1 1 1을 물어봅니다. 대답을 $d$라고 합시다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;만약 $a+b+c = d$라면, 스핑크스는 지금까지 참말만 했습니다. 아무거나 물어보고 대답을 들은 다음 $a$ $b$ $c$를 출력하면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;아니라면, 스핑크스는 한 번 거짓말을 했습니다. 이 시점에서 답의 후보는&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$(a, b, c)$&lt;&#x2F;li&gt;
&lt;li&gt;$(d-b-c, b, c)$&lt;&#x2F;li&gt;
&lt;li&gt;$(a, d-a-c, c)$&lt;&#x2F;li&gt;
&lt;li&gt;$(a, b, d-a-b)$&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;이고, 서로 다른 후보를 모두 구별하는 질의가 존재함을 증명할 수 있습니다. 스핑크스가 다음 질의에서는 참말을 할 것이므로 그걸 물어보면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;사실 경우를 나눌 것도 없이 그냥 1 2 3을 물어봐도 됩니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;46x-quartets&quot;&gt;46X. Quartets&lt;&#x2F;h1&gt;
&lt;p&gt;답이 yes인지 판별할 수 있으면, no일 경우 언제부터 반칙의 존재가 확실한지도 어렵지 않게 구할 수 있습니다. 그러니 답이 yes인지 판별하는 것에 집중합시다.&lt;&#x2F;p&gt;
&lt;p&gt;예제 2를 따라가면서 풀이를 설명하면 좋을 것 같습니다. 맨 처음에 각 플레이어가 8장씩 나눠갖지만 각각이 무슨 카드인지 모르니, 다음과 같이 표기합시다. 정체를 알 수 없는 카드는 “모르는 카드”, 아니면 “아는 카드“라고 지칭합시다.&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P1 [!1 !2 !3 !4 !5 !6 !7 !8]
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P2 [@1 @2 @3 @4 @5 @6 @7 @8]
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P3 [#1 #2 #3 #4 #5 #6 #7 #8]
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P4 [$1 $2 $3 $4 $5 $6 $7 $8]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;첫 기록은 &lt;code&gt;1 A 2 3C no&lt;&#x2F;code&gt; 입니다. &lt;code&gt;p A q ks no&lt;&#x2F;code&gt; 형태의 기록은 다음과 같은 정보를 제공합니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;플레이어 &lt;code&gt;p&lt;&#x2F;code&gt;의 손에 &lt;code&gt;k*&lt;&#x2F;code&gt; 꼴의 카드가 있습니다. &lt;code&gt;p&lt;&#x2F;code&gt;의 손에 있는 아는 카드 중 &lt;code&gt;k*&lt;&#x2F;code&gt; 꼴이 있다면, 이는 아무 정보도 주지 않습니다. 없다면, &lt;code&gt;p&lt;&#x2F;code&gt;의 손에 있는 모르는 카드 중 하나가 &lt;code&gt;k*&lt;&#x2F;code&gt; 꼴입니다. 모르는 카드가 없다면 반칙의 존재가 확실합니다.&lt;&#x2F;li&gt;
&lt;li&gt;플레이어 &lt;code&gt;q&lt;&#x2F;code&gt;의 손에 &lt;code&gt;ks&lt;&#x2F;code&gt; 카드가 없습니다. &lt;code&gt;q&lt;&#x2F;code&gt;의 손에 있는 아는 카드 중에 &lt;code&gt;ks&lt;&#x2F;code&gt;가 있다면 반칙의 존재가 확실합니다. 없다면, &lt;code&gt;q&lt;&#x2F;code&gt;의 손에 있는 모르는 카드 중 아무것도 &lt;code&gt;ks&lt;&#x2F;code&gt;가 아닙니다. 모르는 카드가 없다면 아무 정보도 주지 않습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;다른 사람의 손으로 옮겨진 카드는 무조건 아는 카드가 되기 때문에, &lt;code&gt;!1..8 + @1..3 has 3*&lt;&#x2F;code&gt; 같이 여러 플레이어에 걸쳐서 주어지는 정보는 없습니다.&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P1 [!1 !2 !3 !4 !5 !6 !7 !8] -- !1..8 has 3*
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P2 [@1 @2 @3 @4 @5 @6 @7 @8] -- @1..8 hasn&amp;#39;t 3C
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P3 [#1 #2 #3 #4 #5 #6 #7 #8]
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P4 [$1 $2 $3 $4 $5 $6 $7 $8]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;다음 기록은 &lt;code&gt;2 A 3 3A yes&lt;&#x2F;code&gt; 입니다. &lt;code&gt;p A q ks yes&lt;&#x2F;code&gt; 형태의 기록은 다음과 같은 정보를 제공합니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;플레이어 &lt;code&gt;p&lt;&#x2F;code&gt;의 손에 &lt;code&gt;k*&lt;&#x2F;code&gt; 꼴의 카드가 있습니다. 위와 같습니다.&lt;&#x2F;li&gt;
&lt;li&gt;플레이어 &lt;code&gt;q&lt;&#x2F;code&gt;의 손에 &lt;code&gt;ks&lt;&#x2F;code&gt; 카드가 있습니다. &lt;code&gt;q&lt;&#x2F;code&gt;의 손에 있는 아는 카드 중에 &lt;code&gt;ks&lt;&#x2F;code&gt;가 있다면 아무 정보도 주지 않습니다. 없다면, &lt;code&gt;q&lt;&#x2F;code&gt;의 손에 있는 모르는 카드 중 하나가 &lt;code&gt;ks&lt;&#x2F;code&gt;입니다. 일반성을 잃지 않고 맨 마지막 카드가 &lt;code&gt;ks&lt;&#x2F;code&gt;라고 할 수 있습니다. 모르는 카드가 없다면 반칙의 존재가 확실한데, 그런 경우가 실제로 발생할 수 있는지는 잘 모르겠습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P1 [!1 !2 !3 !4 !5 !6 !7 !8] -- !1..8 has 3*
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P2 [@1 @2 @3 @4 @5 @6 @7 @8 #8=3A] -- @1..8 hasn&amp;#39;t 3C, @1..8 has 3*
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P3 [#1 #2 #3 #4 #5 #6 #7]
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P4 [$1 $2 $3 $4 $5 $6 $7 $8]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;다음 기록은 &lt;code&gt;2 A 4 3D yes&lt;&#x2F;code&gt; 입니다. 같은 방식으로 처리합니다. 손에 이미 3A가 있으니 “&lt;code&gt;3*&lt;&#x2F;code&gt; 꼴의 카드가 있음“은 아무 정보도 주지 않습니다.&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P1 [!1 !2 !3 !4 !5 !6 !7 !8] -- !1..8 has 3*
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P2 [@1 @2 @3 @4 @5 @6 @7 @8 #8=3A $8=3D] -- @1..8 hasn&amp;#39;t 3C, @1..8 has 3*
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P3 [#1 #2 #3 #4 #5 #6 #7]
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P4 [$1 $2 $3 $4 $5 $6 $7]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;다음 기록은 &lt;code&gt;2 A 1 3B no&lt;&#x2F;code&gt; 입니다.&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P1 [!1 !2 !3 !4 !5 !6 !7 !8] -- !1..8 has 3*, !1..8 hasn&amp;#39;t 3B
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P2 [@1 @2 @3 @4 @5 @6 @7 @8 #8=3A $8=3D] -- @1..8 hasn&amp;#39;t 3C, @1..8 has 3*
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P3 [#1 #2 #3 #4 #5 #6 #7]
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P4 [$1 $2 $3 $4 $5 $6 $7]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;다음 기록은 &lt;code&gt;1 A 4 5B yes&lt;&#x2F;code&gt; 입니다.&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P1 [!1 !2 !3 !4 !5 !6 !7 !8 $7=5B] -- !1..8 has 3*, !1..8 hasn&amp;#39;t 3B, !1..8 has 5*
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P2 [@1 @2 @3 @4 @5 @6 @7 @8 #8=3A $8=3D] -- @1..8 hasn&amp;#39;t 3C, @1..8 has 3*
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P3 [#1 #2 #3 #4 #5 #6 #7]
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P4 [$1 $2 $3 $4 $5 $6]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;다음 기록은 &lt;code&gt;1 Q 5&lt;&#x2F;code&gt; 입니다. &lt;code&gt;p Q k&lt;&#x2F;code&gt; 형태의 기록은 플레이어 &lt;code&gt;p&lt;&#x2F;code&gt;의 손에 &lt;code&gt;kA&lt;&#x2F;code&gt;, &lt;code&gt;kB&lt;&#x2F;code&gt;, &lt;code&gt;kC&lt;&#x2F;code&gt;, &lt;code&gt;kD&lt;&#x2F;code&gt; 카드가 있다는 정보를 제공합니다. 그런데 이 플레이어의 모르는 카드에 대한 정보가 이미 있었으니, 카드를 공개하면서 이 정보도 업데이트해야 합니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;!1..z has k*&lt;&#x2F;code&gt; 정보가 있는 상태에서 &lt;code&gt;!z&lt;&#x2F;code&gt; 가 &lt;code&gt;ks&lt;&#x2F;code&gt; 라는 정보를 얻었으면, 앞의 정보는 더 이상 의미가 없으므로 제거합니다. 다른 세트의 카드라는 정보를 얻었으면, &lt;code&gt;!1..(z-1) has k*&lt;&#x2F;code&gt; 로 수정합니다.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;!1..z hasn&#x27;t ks&lt;&#x2F;code&gt; 정보가 있는 상태에서 &lt;code&gt;!z&lt;&#x2F;code&gt; 가 &lt;code&gt;ks&lt;&#x2F;code&gt; 라는 정보를 얻었으면 반칙의 존재가 확실합니다. 아니라면 &lt;code&gt;!1..(z-1) hasn&#x27;t ks&lt;&#x2F;code&gt; 로 수정합니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P1 [!1 !2 !3 !4 !5] -- !1..5 has 3*, !1..5 hasn&amp;#39;t 3B
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P2 [@1 @2 @3 @4 @5 @6 @7 @8 #8=3A $8=3D] -- @1..8 hasn&amp;#39;t 3C, @1..8 has 3*
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P3 [#1 #2 #3 #4 #5 #6 #7]
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;P4 [$1 $2 $3 $4 $5 $6]
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;quartet: (!6=5A $7=5B !7=5C !8=5D)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;이제 아직 행방이 밝혀지지 않은 카드들을 모르는 카드에 잘 배정해서 모든 정보와 일치시킬 수 있는지 확인해야 합니다. 뭔가 매칭 문제를 닮았으니, 플로우 모델링을 시도해보면 다음 LR-flow 모델이 만들어집니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;source, sink, P1, P2, P3, P4 정점을 만듭니다.&lt;&#x2F;li&gt;
&lt;li&gt;각 플레이어 &lt;code&gt;p&lt;&#x2F;code&gt; 와 세트 &lt;code&gt;k&lt;&#x2F;code&gt; 의 쌍을 나타내는 &lt;code&gt;pk&lt;&#x2F;code&gt; 정점을 만듭니다. &lt;code&gt;Pp&lt;&#x2F;code&gt; 에서 &lt;code&gt;pk&lt;&#x2F;code&gt; 로 간선을 긋습니다. 용량은 4, 최소 유량은 &lt;code&gt;p&lt;&#x2F;code&gt; 에 “&lt;code&gt;has k*&lt;&#x2F;code&gt;” 정보가 있다면 1, 아니면 0으로 둡니다.&lt;&#x2F;li&gt;
&lt;li&gt;행방이 밝혀지지 않은 카드를 나타내는 &lt;code&gt;ks&lt;&#x2F;code&gt; 정점을 만듭니다. &lt;code&gt;p&lt;&#x2F;code&gt; 에 “&lt;code&gt;hasn&#x27;t ks&lt;&#x2F;code&gt;” 정보가 없다면 &lt;code&gt;pk&lt;&#x2F;code&gt; 에서 &lt;code&gt;ks&lt;&#x2F;code&gt; 로 간선을 긋습니다. 용량은 1, 최소 유량은 0으로 둡니다.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;ks&lt;&#x2F;code&gt; 에서 sink로 간선을 긋습니다. 용량과 최소 유량은 1로 둡니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;이제 LR-flow 를 돌려서 해가 있는지 확인하면 됩니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;white-check-mark-46y-compression&quot;&gt;✅ 46Y. Compression&lt;&#x2F;h1&gt;
&lt;p&gt;다음 그리디 전략을 생각해볼 수 있습니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;우선 연속된 같은 글자들을 하나로 합칩니다.&lt;&#x2F;li&gt;
&lt;li&gt;그러면 1과 0이 번갈아서 나오는 형태가 되는데, 연속된 10이나 01들을 하나로 합칩니다. 마지막에는 0, 1, 01, 10, 010, 101 중 하나가 남습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;이 전략은 최적입니다. 왜냐?&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;정답의 길이가 1일 필요충분조건은 “한 종류의 글자로만 이루어져 있음“입니다. 0이 하나라도 있다면 0을 전부 지울 수 없고, 1도 마찬가지이기 때문에, 0과 1이 모두 있는 문자열은 길이를 2보다 짧게 줄일 수 없습니다.&lt;&#x2F;li&gt;
&lt;li&gt;첫 글자를 바꿀 수 없습니다. 첫 글자를 바꾸려면 지워야 되는데, 그러면 문자열이 &lt;code&gt;[abcde]abcdefgh&lt;&#x2F;code&gt; 꼴이므로 지운 후에도 첫 글자가 유지됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;마찬가지로 마지막 글자도 바꿀 수 없습니다.&lt;&#x2F;li&gt;
&lt;li&gt;01, 10, 010, 101은 (첫 글자, 마지막 글자)가 모두 다르고, 가능한 4가지 경우를 모두 커버하기 때문에, 0과 1이 모두 있는 문자열의 최종 결과는 넷 중에 정확히 하나로 정해져 있습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;46z-archaeological-recovery&quot;&gt;46Z. Archaeological Recovery&lt;&#x2F;h1&gt;
&lt;p&gt;TODO&lt;&#x2F;p&gt;
&lt;h1 id=&quot;white-check-mark-47b-schedule&quot;&gt;✅ 47B. Schedule&lt;&#x2F;h1&gt;
&lt;p&gt;먼저 주어진 $n$과 $w$에 대해 답이 유한인지 판별해 봅시다. 그러려면 길이 $n$의 이진 문자열 (편의상 1, 2가 아니라 0, 1이라고 합시다) $w$개를 만들어서 다음 조건을 만족시켜야 합니다.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;인덱스 $i$에 대해, $j$번째 문자열의 $i$번째 문자가 &lt;code&gt;1&lt;&#x2F;code&gt; 인 모든 $j$의 집합을 $S_j$라고 하자. 모든 서로 다른 인덱스 $i$, $j$에 대해, (1) $S_i \cup S_j$에 없는 원소가 존재하고, (2) $S_i$와 $S_j$는 서로 부분집합 관계가 아니며, (3) $S_i \cap S_j$는 공집합이 아니어야 한다.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;(1) (2) (3)은 해당 인덱스 쌍에 &lt;code&gt;00&lt;&#x2F;code&gt;, &lt;code&gt;01&lt;&#x2F;code&gt;, &lt;code&gt;10&lt;&#x2F;code&gt;, &lt;code&gt;11&lt;&#x2F;code&gt;이 모두 존재함과 동치입니다.&lt;&#x2F;p&gt;
&lt;p&gt;일반성을 잃지 않고 첫 번째 문자열이 &lt;code&gt;00...00&lt;&#x2F;code&gt; 이라고 하면 (1)은 저절로 해결됩니다. (2)와 (3)이 문제인데, 방향을 바꿔서 ${1, \cdots, w}$의 부분집합 $n$개를 만든다고 합시다. 일단 (2)만 있다고 하면 &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sperner%27s_theorem&quot;&gt;슈페르너의 정리&lt;&#x2F;a&gt;에 의해 가능한 $n$의 최댓값은 $\binom{w-1}{[\frac{w-1}{2}]}$ 입니다. 실제 해는 ${2, \cdots, w}$의 모든 $[\frac{w-1}{2}]$ 크기 부분집합을 쓰면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;(3)이 들어가도 결론은 비슷합니다. &lt;a href=&quot;https:&#x2F;&#x2F;citeseerx.ist.psu.edu&#x2F;document?repid=rep1&amp;amp;type=pdf&amp;amp;doi=4f85bedf628d70dc0d7b67f87c289966dfa46a90&quot;&gt;이 논문&lt;&#x2F;a&gt;에 따르면 가능한 $n$의 최댓값은 $\binom{w-1}{[\frac{w-1}{2}]+1}$ 입니다. 실제 해는 ${2, \cdots, w}$의 모든 $[\frac{w-1}{2}]+1$ 크기 부분집합을 쓰면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;이제 본 문제로 돌아갑시다. 주어진 $n$에 대해, 가능한 $n$의 최댓값이 그 이상이 되는 가장 작은 $w’$을 찾습니다. $w’ &amp;gt; w$라면 답은 무한입니다. $w’ \leq w$라면 답은 $w’$입니다. $w$ 대신 $w’$가 주어져도 답이 $w’$이니, 그보다 큰 $w$를 줘도 $w’$보다 작은 답을 만들 수 없기 때문입니다. 실제 해는 위에서 만든 이진 문자열 $w’$개를 돌아가면서 계속 출력하면 됩니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;47e-a-recurring-problem&quot;&gt;47E. A Recurring Problem&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;codeforces.com&#x2F;blog&#x2F;entry&#x2F;128559?#comment-1141729&quot;&gt;Benq 코멘트&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;For each continuation of length 4 up to a certain bound, count the number of recurrences with that continuation. This allows us to find the first four values of the continuation. Then, given the first four values of the continuation, we can enumerate all recurrences with that continuation, which turns out to be bounded by 4836557 for the given constraints. Though I had to spend several hours to fix the MLE &#x2F; TLE &#x2F; WA verdicts (the memory usage is barely under 2TB) …&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;codeforces.com&#x2F;blog&#x2F;entry&#x2F;128559?#comment-1141850&quot;&gt;arknave 코멘트&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;That looks largely correct. The main idea to speed up the solution and reduce its memory consumption is: for each continuation, instead of just counting the number of recurrences that begin with that continuation, compute all possible next values to this continuation, along with their frequencies. This lets you prune out a bunch of useless continuations since the values get very sparse after the first few values in the sequence.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h1 id=&quot;47f-tilting-tiles&quot;&gt;47F. Tilting Tiles&lt;&#x2F;h1&gt;
&lt;p&gt;사실 이 퍼즐에서 할 수 있는 행동은 거의 없습니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;같은 방향으로 두 번 밀 이유가 없습니다. 이 퍼즐은 2048 게임이 아닙니다.&lt;&#x2F;li&gt;
&lt;li&gt;한 번 밀고 나서 바로 반대 방향으로 밀 이유가 없습니다. 그럼 바로 전 밀기가 의미가 없어집니다. 그래서 매번 바로 전 밀기 방향에 수직인 방향으로 밀어야 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;처음에 x 방향으로 밀고, 다음에 x와 수직인 y 방향으로 밀었다면, 그 다음에는 x의 반대 방향으로 밀어야 합니다. y에 수직이어야 되는데 다시 x 방향으로 미는 건 효과가 없기 때문입니다.&lt;&#x2F;li&gt;
&lt;li&gt;따라서 실제로 의미가 있는 행동은 소용돌이처럼 시계나 반시계 방향으로 돌아가면서 미는 것뿐입니다. 맨 처음 방향과 소용돌이의 회전 방향에 따라 총 8개의 후보가 있습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;이제 한 소용돌이를 잡고, 그 전략으로 우리가 원하는 배치를 만들 수 있는지 판별해 봅시다. 시작 방향과 관계없이 네 방향으로 한 번씩 미는 것을 “소용돌이 한 바퀴 돌기“라고 부릅시다.&lt;&#x2F;p&gt;
&lt;p&gt;첫 소용돌이를 돌고 나면 이후로 소용돌이 한 바퀴마다 공백의 위치가 같아짐을 증명할 수 있습니다. 예를 들어 5번 민 상태와 9번 민 상태는 각 칸에 적힌 글자는 다를 수 있어도, 각 칸이 공백인지 아닌지 여부는 같습니다.&lt;&#x2F;p&gt;
&lt;p&gt;따라서 우리가 할 일은&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;하나의 소용돌이로 치지 않고 따로 밀 횟수 $s$를 설정합니다. $0 \leq s \leq 5$ 입니다. (5도 고려해야 후술할 전략으로 모든 경우가 커버됩니다.)&lt;&#x2F;li&gt;
&lt;li&gt;소용돌이 방향으로 $s$번 밉니다. 공백의 위치가 우리가 원하는 배치와 다르면 실패입니다.&lt;&#x2F;li&gt;
&lt;li&gt;이제 공백은 됐고, 글자가 모두 맞을 때까지 소용돌이를 한 바퀴 단위로 돌립니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;여기서 끝나면 좋겠지만, 필요한 소용돌이 횟수가 너무 커서 시간 안에 안 돌 것입니다.&lt;&#x2F;p&gt;
&lt;p&gt;소용돌이 1회는 공백이 아닌 글자들을 특정 순열에 따라 이동시키는 것으로 볼 수 있습니다. 그 순열을 얻어내려면 공백이 아닌 위치에 1, 2, 3, …을 차례대로 써넣고 소용돌이를 한 바퀴 돌리면 됩니다. 결국 우리가 풀어야 되는 문제는 다음과 같습니다.&lt;&#x2F;p&gt;
&lt;p&gt;“시작 문자열, 끝 문자열, 순열이 주어졌을 때, 순열을 반복 적용시켜 시작 문자열을 끝 문자열로 만들 수 있는가?”&lt;&#x2F;p&gt;
&lt;p&gt;순열을 사이클로 분할합니다. 그중 한 사이클의 시점에서 문제를 바라보면,&lt;&#x2F;p&gt;
&lt;p&gt;“시작 문자열, 끝 문자열이 주어졌을 때, 시작 문자열을 회전시켜 끝 문자열로 만들 수 있는가?”&lt;&#x2F;p&gt;
&lt;p&gt;단, 여기서의 시작과 끝 문자열은 그 사이클이 갖고 있는 문자들만 그 사이클 순서대로 뽑아서 만들어야 합니다. 이건 KMP나 해싱 등을 써서 풀 수 있습니다. 예를 들어 KMP를 쓴다면, 끝 문자열을 복제하고 이어 붙여서 두 배로 늘리고, 거기서 시작 문자열을 찾으면 됩니다. (어디서 들어본 말 같죠? 물론 서로 다른 대회에서 나왔습니다.)&lt;&#x2F;p&gt;
&lt;p&gt;한 사이클이라도 위 질문에 대한 답이 “아니오“라면 실패입니다. 여기서 끝나면 좋겠지만, 모든 답이 “예“여도 전체가 성공이란 보장은 없습니다. 예를 들어&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;abcd --&amp;gt; cdab
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;ef --&amp;gt; fe
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;위 두 경우 각각은 “예“이지만, 첫 번째 경우는 4k+2번, 두 번째 경우는 홀수 번 회전시켜야 되기 때문에, 순열을 아무리 적용해도 두 경우가 동시에 만족될 수는 없습니다. 따라서 단순히 “만들 수 있는가?“가 아니라 다음 문제를 풀어야 합니다.&lt;&#x2F;p&gt;
&lt;p&gt;“시작 문자열, 끝 문자열이 주어졌을 때, 시작 문자열을 x칸 오른쪽으로 회전시켰을 때 끝 문자열이 될 필요충분조건이 $x \equiv a (mod\ m)$이라고 하자. $a$와 $m$은 얼마인가?”&lt;&#x2F;p&gt;
&lt;p&gt;다행히도 “만들 수 있는가?“를 풀 수 있다면 위 문제도 쉽게 풀 수 있습니다. 이제 모든 사이클에 대해 모듈로 방정식 $x \equiv a (mod\ m)$을 모으고, 그 연립방정식의 해가 존재하면 성공, 아니면 실패입니다. 이제 중국인의 나머지 정리를 쓰면 됩니다. $m$의 최소공배수가 너무 클 수 있어서 정확한 해를 구하기는 어렵지만, 확장 유클리드로 해를 구하는 과정을 들여다 보면 사실 해의 존재성만 판별하는 건 gcd 하나로 충분함을 알 수 있습니다. “확장“도 지우고 그냥 유클리드 알고리즘을 쓰면 됩니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;white-check-mark-47h-jet-lag&quot;&gt;✅ 47H. Jet Lag&lt;&#x2F;h1&gt;
&lt;p&gt;$k$초 동안 자고 일어났을 때 다음 $k$초 동안은 잘 수 없다는 조건이 거슬립니다. 이 조건이 없었다면 가능한 한 일찍 자고 늦게 일어나는 그리디 전략이 통했을 것입니다. 구체적으로,&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;첫 이벤트 이전 기간, 또는 인접한 두 이벤트 사이의 빈 기간을 “공백기“라고 합시다. 즉 타임라인은 공백기와 이벤트가 번갈아서 나열되어 있습니다.&lt;&#x2F;li&gt;
&lt;li&gt;첫 공백기 내내 잡니다. $k$초 동안 자면 다음 $2k$초 동안 깨어있을 수 있습니다.&lt;&#x2F;li&gt;
&lt;li&gt;그 다음 공백기부터는, 잤을 때 더 늦게까지 깨어있을 수 있다면 내내 자고, 아니면 건너뜁니다.&lt;&#x2F;li&gt;
&lt;li&gt;한 번이라도 이벤트가 끝날 때까지 깨어있을 수 없다면 불가능합니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;다행히도 “다음 $k$초 동안은 잘 수 없다는 조건“이 들어가도 위에서 만든 전략을 조금 수정해서 재활용할 수 있습니다. 인접한 잠 스케줄이 새로운 조건에 위배되면, 둘 중 앞쪽의 스케줄을 앞당겨서 더 일찍 일어나게 바꾸면 됩니다. $k$초 동안 잘 수 없다는 조건이 없었을 때 해가 존재하지 않는다면, 조건을 추가했을 때 해도 당연히 존재하지 않습니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;white-check-mark-47i-waterworld&quot;&gt;✅ 47I. Waterworld&lt;&#x2F;h1&gt;
&lt;p&gt;$nm$개 조각 각각의 겉넓이를 구하고, 그 조각에 배정된 값과 곱하여 모두 합해야 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;같은 경도에 있는 조각의 겉넓이는 같습니다. 회전축을 기준으로 한 칸 만큼 돌리면 완전히 똑같은 모양이 나오기 때문입니다. 그러므로 특정 경도에 있는 조각의 겉넓이를 구하려면, 그 경도 범위로 구를 잘랐을 때 그 부분의 겉넓이를 구하고 $m$으로 나누면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;이를 구하려면 회전체의 겉넓이 공식을 쓰면 됩니다. $t$에 대한 매개변수 곡선 $(x(t), y(t)), t \in [a, b]$를 $x$축을 중심으로 돌렸을 때 나오는 회전체의 겉넓이는 다음과 같습니다.&lt;&#x2F;p&gt;
&lt;p&gt;$2 \pi \int_a^b y(t) \sqrt{(\frac{dx}{dt})^2 + (\frac{dy}{dt})^2} dt$&lt;&#x2F;p&gt;
&lt;p&gt;구체적으로, 구 $x^2 + y^2 + z^2 = r^2$를 $t_1 \leq x \leq t_2$ 범위로 잘랐을 때 그 부분의 겉넓이를 구해 봅시다. 우리가 원하는 호의 매개변수 곡선은 $(r \cos t, r \sin t), t \in [cos^{-1} \frac{x_2}{r}, cos^{-1} \frac{x_1}{r}]$입니다. 위 공식에 대입해 보면 $\sqrt{(\frac{dx}{dt})^2 + (\frac{dy}{dt})^2} = r$이므로, $A = 2 \pi r^2 \int_{t_1}^{t_2} \sin t \ dt = 2 \pi r^2 [\cos t]_{t_1}^{t_2} = 2 \pi r (x_2-x_1)$ 입니다.&lt;&#x2F;p&gt;
&lt;p&gt;그러니까, 어느 경도 범위로 자르느냐에 관계 없이 범위의 길이가 같으면 겉넓이도 같습니다. 결론적으로 모든 조각의 겉넓이가 같으므로, 그냥 입력된 수들의 평균을 출력하면 됩니다…&lt;&#x2F;p&gt;
&lt;h1 id=&quot;47k-alea-iacta-est&quot;&gt;47K. Alea Iacta Est&lt;&#x2F;h1&gt;
&lt;p&gt;$6^d$개의 상태가 있는 그래프를 생각합시다. 정점마다 어느 주사위를 고정할지를 잘 정해서, 랜덤 워크를 했을 때 도착점 중 하나에 도달하는 데 필요한 걷기 횟수의 기댓값을 최소화해야 합니다. 연립방정식을 세워서 가우스 소거 같은 걸 하기에는 어림도 없는 크기입니다.&lt;&#x2F;p&gt;
&lt;p&gt;기댓값의 근사값을 구해도 충분하고, 그 값도 작은 편이기 때문에, 모든 정점의 기댓값을 특정 초기값으로 잡고 수렴할 때까지 계산을 돌려도 될 것처럼 생겼습니다. (아마?? 월파 라이브 방송에서 들은 거긴 한데 확실하진 않습니다… TODO) 아쉽게도 이 그래프는 간선이 너무 많아서 시간 안에 수렴은 커녕 한 번 돌리기도 어렵습니다. 사실상 완전그래프입니다! 모델링을 조금 수정해서, 정점이 좀 더 많아지더라도 간선이 선형 수준으로 떨어지도록 합시다.&lt;&#x2F;p&gt;
&lt;p&gt;첫 번째 최적화는 전략과 굴리기를 분리하는 것입니다. 주사위마다 글자 6개뿐만 아니라 “곧 다시 굴릴 예정“을 의미하는 &lt;code&gt;?&lt;&#x2F;code&gt;를 추가해 총 $7^d$개의 상태를 만듭니다. &lt;code&gt;?&lt;&#x2F;code&gt;이 없는 상태에서는 일부 주사위를 &lt;code&gt;?&lt;&#x2F;code&gt;로 만드는 총 $2^d$개의 간선을 추가합니다. 이 간선은 우리가 전략을 세워서 정점마다 하나씩 선택해야 합니다. 또한 &lt;code&gt;?&lt;&#x2F;code&gt;이 있는 상태에서는 &lt;code&gt;?&lt;&#x2F;code&gt;를 다시 굴리는 총 $6^{\text{?의 개수}}$개의 간선을 추가합니다. 이 간선은 매번 균일한 확률로 무작위로 선택됩니다. 이렇게 해도 두 번째 종류의 간선이 너무 많습니다.&lt;&#x2F;p&gt;
&lt;p&gt;두 번째 최적화는 한 번에 한 주사위만 &lt;code&gt;?&lt;&#x2F;code&gt;로 바꾸거나 굴리는 것입니다. 즉 다음과 같이 상태를 만듭니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;(1) 주사위가 모두 굴려진 상태&lt;&#x2F;li&gt;
&lt;li&gt;(2) 모두 굴려진 후, 첫 $i$개의 주사위를 &lt;code&gt;?&lt;&#x2F;code&gt;로 바꾸거나 바꾸지 않은 상태&lt;&#x2F;li&gt;
&lt;li&gt;(3) &lt;code&gt;?&lt;&#x2F;code&gt;를 모두 결정한 후, 첫 $i$개의 주사위가 굴려진 상태&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;상태 개수는 어림잡아서 백만 단위로 나옵니다. 이제 (1)-&amp;gt;(2)와 (2)-&amp;gt;(2) 방향 전이의 개수는 상태 당 2개, (2)-&amp;gt;(3) 방향 전이의 개수는 상태 당 $d$개로 상한이 잡히기 때문에, 충분히 계산을 돌릴 수 있을 만큼 간선 개수가 줄었습니다.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>삼각형 찾기</title>
        <published>2023-10-02T00:00:00+00:00</published>
        <updated>2023-10-02T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              jh05013
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://jh05013.github.io/blog/enumerating-triangles/"/>
        <id>https://jh05013.github.io/blog/enumerating-triangles/</id>
        
        <content type="html" xml:base="https://jh05013.github.io/blog/enumerating-triangles/">&lt;p&gt;단순 그래프의 정점의 개수를 $n$, 간선의 개수를 $m$이라고 합시다. 이 그래프에 있는 삼각형, 즉 길이 3의 사이클을 모두 찾을 수 있을까요?&lt;&#x2F;p&gt;
&lt;h1 id=&quot;o-frac-nm-w&quot;&gt;$O(\frac{nm}{w})$&lt;&#x2F;h1&gt;
&lt;p&gt;간선 하나 $uv$를 고정하고, 그 간선을 포함하는 삼각형을 찾아봅시다.&lt;&#x2F;p&gt;
&lt;p&gt;인접 행렬을 만듭니다. 그러면 $u$와 $v$에 인접한 모든 정점 $a$에 대해 삼각형 $uva$를 찾을 수 있습니다. 인접 행렬의 $u$행과 $v$행에서 둘 다 인접 표시가 된 열을 찾으면 됩니다. 시간 복잡도는 $O(nm)$입니다.&lt;&#x2F;p&gt;
&lt;p&gt;이 과정을 비트셋의 교집합 연산으로 최적화하면 시간 복잡도 $O(\frac{nm}{w})$에 모든 삼각형을 찾을 수 있습니다. 64비트 컴퓨터에서 $w = 64$입니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yeonseubmunje&quot;&gt;연습문제&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;20501&quot;&gt;BOJ 20501 Facebook&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;atcoder.jp&#x2F;contests&#x2F;abc258&#x2F;tasks&#x2F;abc258_g&quot;&gt;ABC258 Triangle&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;8907&quot;&gt;BOJ 8907 네온 사인&lt;&#x2F;a&gt; &#x2F; &lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;8096&quot;&gt;BOJ 8096 Monochromatic Triangles&lt;&#x2F;a&gt;를 말그대로 붉은색, 파란색 삼각형을 직접 세서 풀 수 있습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;o-m-sqrt-m&quot;&gt;$O(m \sqrt m)$&lt;&#x2F;h1&gt;
&lt;p&gt;정점 $v$의 차수를 $\deg(v)$라고 할 때, 다음 식을 생각해 봅시다.&lt;&#x2F;p&gt;
&lt;p&gt;$$\sum_{uv \in E} \min(\deg(u), \deg(v))$$&lt;&#x2F;p&gt;
&lt;p&gt;이 값은 $O(m \sqrt m)$입니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;증명.&lt;&#x2F;strong&gt; $\sum_{v \in V} \deg(v) = 2m$이므로, $\deg(v) \geq \sqrt m$인 정점은 많아야 $O(\sqrt m)$개입니다. 그래프가 단순하므로, $\min(\deg(u), \deg(v)) \geq \sqrt m$인 간선은 많아야 $O(m)$개입니다. 나머지 간선은 $\min(\deg(u), \deg(v)) \leq \sqrt m$입니다. ■&lt;&#x2F;p&gt;
&lt;p&gt;이제 정점을 차수 순으로, 동점일 경우 번호 순으로 정렬해서 위에서 아래로 늘어놓읍시다. 위 $v$에서 아래 $p$로 가는 간선을 $v \downarrow p$라고 합시다.&lt;&#x2F;p&gt;
&lt;p&gt;모든 간선 $v \downarrow p$에 대해 간선 $pq$(위아래 상관없음)를 모두 찾을 수 있습니다. 예를 들면 아래와 같은 경우가 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;triangle_downpq.png&quot; alt=&quot;TODO: add subtitle&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;그러한 $(v, p, q)$ 쌍은 $O(\sum_{v \rightarrow p \in E} \deg(p)) = O(m \sqrt m)$개 존재합니다. $\min(\deg(v), \deg(p)) = \deg(p)$이기 때문입니다.&lt;&#x2F;p&gt;
&lt;p&gt;따라서, 위에서 아래로 가는 $v \downarrow p \downarrow q$ 꼴의 경로도 당연히 모두 찾을 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;이제 각 $v \downarrow p \downarrow q$에 대해 $q$와 $v$가 인접한지 확인하면 됩니다. 간단하게는 해시셋으로 구현할 수 있지만 이는 너무 무겁고, 다음과 같은 방법으로 진행할 수 있습니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;우선 크기 $n$의 배열 $A$를 초기화합니다.&lt;&#x2F;li&gt;
&lt;li&gt;각 $v$에 대해…
&lt;ul&gt;
&lt;li&gt;각 간선 $v \downarrow p$에 대해 $A[p]$를 마킹합니다. 즉 $A[p]$는 “$p$가 $v$의 아래에 있으면서 인접하다“라는 뜻입니다.&lt;&#x2F;li&gt;
&lt;li&gt;다시 각 간선 $v \downarrow p$에 대해, 간선 $p \downarrow q$들을 순회합니다. $A[q]$가 마킹되어 있다면 삼각형 $vpq$를 찾았습니다.&lt;&#x2F;li&gt;
&lt;li&gt;다시 각 간선 $v \downarrow p$에 대해 $A[p]$의 마킹을 지웁니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;각 삼각형은 $a \downarrow b \downarrow c$ 꼴의 경로를 정확히 하나씩 갖고 있으므로, 각 삼각형이 정확히 한 번씩 세어집니다. 총 시간 복잡도는 $O(m \sqrt m)$입니다. 같은 방법으로 그래프에는 삼각형이 최대 $O(m \sqrt m)$개 있음을 증명할 수 있습니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yeonseubmunje-1&quot;&gt;연습문제&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;judge.yosupo.jp&#x2F;problem&#x2F;enumerate_triangles&quot;&gt;LC Enumerate Triangles&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;1762&quot;&gt;BOJ 1762 평면그래프와 삼각형&lt;&#x2F;a&gt;을 평면그래프 조건 없이 풀 수 있습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;cuga-yeonseubmunje&quot;&gt;추가 연습문제&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;boj-14571-moraesigye-in-o-m-sqrt-m&quot;&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;14571&quot;&gt;BOJ 14571 모래시계&lt;&#x2F;a&gt; in $O(m \sqrt m)$&lt;&#x2F;h3&gt;
&lt;p&gt;모든 삼각형을 $O(m \sqrt m)$에 찾습니다. 각 정점 $v$에 대해, $v$를 포함하는 삼각형 $vpq$에 대해 간선 $pq$의 목록을 저장해 둡니다.&lt;&#x2F;p&gt;
&lt;p&gt;모래시계의 중심 $v$를 고정하고, $v$에 대한 간선 $pq$로 이루어진 부분그래프를 생각해 봅시다. 이 부분그래프의 간선 $e$개 중 두 개를 고르되 겹치는 정점이 없도록 하는 경우의 수를 구하면 됩니다. 첫 번째 간선 $ab$를 고르고, 나머지 간선 중 $a$ 또는 $b$와 이어지는 것을 모두 제외하면, 남은 간선의 개수는 $e - \deg(a) - \deg(b) + 1$입니다. 이때 $\deg$는 부분그래프 기준입니다.&lt;&#x2F;p&gt;
&lt;p&gt;부분그래프에서 차수를 관리하는 것은 위의 $A$ 배열과 같은 방식으로 진행할 수 있습니다.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;sagaghyeongyi-gaesu&quot;&gt;&lt;a href=&quot;https:&#x2F;&#x2F;judge.yosupo.jp&#x2F;problem&#x2F;counting_c4&quot;&gt;사각형의 개수&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;삼각형뿐만 아니라 사각형도 셀 수 있습니다! 사각형은 최대 $O(m^2)$개 있을 수 있지만, 개수는 $O(m \sqrt m)$에 구할 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;메인 아이디어는 아래 그림과 같습니다. 사각형을 $v \downarrow p \rightarrow q$ 꼴의 경로 두 개로 분할할 수 있으니, 그런 형태의 경로를 세는 것입니다. 각 $v \downarrow p$에 대해, $v$의 아래에 있으면서 $v$와 $p$에 인접한 정점 $q$의 개수를 $k_{vp}$라고 하면, 모든 $\frac{k_{vq}(k_{vq}-1)}{2}$의 합을 구하면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;count_4cycles.png&quot; alt=&quot;graph with directed edges v-&amp;gt;p1, v-&amp;gt;p2, v-&amp;gt;p3, p1-&amp;gt;q, and p3-&amp;gt;q going downwards, and p2-&amp;gt;q going upwards.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;앞에서 보았듯이 $k_{vq} &amp;gt; 0$인 $(v, q)$는 $O(m \sqrt m)$개이고, 0보다 큰 모든 $k_{vq}$를 $O(m \sqrt m)$에 구할 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;위 과정을 조금 변형하면 각 정점을 포함하는 사각형의 개수도 셀 수 있습니다.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;boj-2390&quot;&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;2390&quot;&gt;BOJ 2390 ⎐&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;제가 이 알고리즘을 배운 계기가 된 문제입니다. 검수하면서 풀이를 고민하다가 “사각형을 $O(M^2)$보다 빠르게 셀 수 없는데 어떻게 ⎐를 셀 수 있지?“라고 생각했는데, 사각형을 $O(M \sqrt M)$에 셀 수 있더라고요…&lt;&#x2F;p&gt;
&lt;p&gt;바로 위에서 보았듯이, 각 정점 $v$에 대해 $v$를 포함하는 사각형의 개수를 셉니다. 이제 ⎐에서 차수가 4인 정점을 “⎐의 중심“이라고 하면, 각 정점 $v$에 대해 $v$가 중심인 ⎐의 개수를 셉니다. 사각형의 개수에 $deg(v)-2$를 곱하면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;모든 $v$에 대해 위 값을 구하고 합하면, 놀랍게도 크기 5의 완전 그래프에서 출력이 60이 나옵니다. 왜냐하면 다음 🪁 모양 케이스를 제외하지 않았기 때문입니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;kite2390.png&quot; alt=&quot;undirected graph formed by joining two triangles with a common edge, one endpoint being labeled v and having one more edge sprout out of v.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;🪁를 세기 위해, 각 간선 $pq$에 대해 $pq$를 포함하는 삼각형의 개수를 셉니다. 그 후 각 간선 $pq$에 대해 $pq$가 사각형의 대각선인 🪁의 개수를 세줍니다. 삼각형의 개수를 $k$라고 할 때 $\binom{k}{2} (deg(p)-3) (deg(q)-3)$이 답입니다.&lt;&#x2F;p&gt;
&lt;p&gt;참고로 이 ⎐ 문양의 정체는 &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Open_collector&quot;&gt;NPN open collector&lt;&#x2F;a&gt;로, 전기회로에서 사용하는 문양입니다.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;boj-28200-4&quot;&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;28200&quot;&gt;BOJ 28200 4&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;모든 삼각형을 찾습니다. 각 정점 $v$에 대해, $v$를 포함하는 삼각형 $vpq$에 대해 간선 $pq$의 목록을 저장해 둡니다.&lt;&#x2F;p&gt;
&lt;p&gt;한 점 $v$를 고정하고, $v$에 대한 간선 $pq$로 이루어진 부분그래프를 생각해 봅시다. 이 부분그래프에서 삼각형의 개수를 세면 되는데, 대부분의 정점에 대해서는 부분그래프가 작을 것이기 때문에 비트셋으로 풀 수 있습니다. 자세한 내용은 &lt;a href=&quot;https:&#x2F;&#x2F;qoj.ac&#x2F;download.php?type=attachments&amp;amp;id=1212&amp;amp;r=2&quot;&gt;에디토리얼&lt;&#x2F;a&gt;을 참조하세요.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;camjo&quot;&gt;참조&lt;&#x2F;h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2303.06090&quot;&gt;Paul Burkhardt, David G. Harris, Simple and efficient four-cycle counting on sparse graphs&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>ICPC World Finals 2021 풀이</title>
        <published>2022-12-03T00:00:00+00:00</published>
        <updated>2022-12-03T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              jh05013
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://jh05013.github.io/blog/wf2021/"/>
        <id>https://jh05013.github.io/blog/wf2021/</id>
        
        <content type="html" xml:base="https://jh05013.github.io/blog/wf2021/">&lt;p&gt;11월에 ICPC World Finals 2021에 참가했습니다.
이후 11월 말까지 한 문제를 제외한 나머지를 모두 풀었고, 이 글에서 모든 문제의 풀이를 정리합니다.&lt;&#x2F;p&gt;
&lt;p&gt;최근 3년과 달리 상대적으로 쉬운 (플래 하급 이하) 문제가 좀 더 많이 나왔는데,
그것들을 푸느라 더 어려운 문제에 쓸 시간이 부족했습니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;a-crystal-crosswind&quot;&gt;A: Crystal Crosswind&lt;&#x2F;h1&gt;
&lt;p&gt;바람의 방향이 $(w_x, w_y)$, 가장자리의 집합이 $S$라고 하면 다음과 같은 정보를 얻습니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;(1) $(x, y) \in S$일 경우, $(x, y)$은 분자고, $(x - w_x, y - w_y)$는 빈칸입니다.&lt;&#x2F;li&gt;
&lt;li&gt;(2) $(x, y) \notin S$일 경우, $(x, y)$가 빈칸이거나 $(x - w_x, y - w_y)$가 분자입니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;두 번째 조건은 “(2A) $(x, y)$가 분자면 $(x - w_x, y - w_y)$도 분자”,
혹은 “(2B) $(x - w_x, y - w_y)$가 빈칸이면 $(x, y)$도 빈칸“과 동치입니다.&lt;&#x2F;p&gt;
&lt;p&gt;먼저 분자가 가장 적은 경우부터 구해봅시다.
우선 (1)로부터 무조건 분자여야 하는 칸이 정해집니다.
그리고 (2A)로부터 추가로 무조건 분자여야 하는 칸이 어디인지 알 수 있습니다.
(2A)를 반복적으로 적용시키다가 더 이상 무조건 분자여야 하는 칸이 안 생길 때가 바로 답입니다.
나머지 모든 칸을 빈칸으로 둬도 모든 규칙이 만족되기 때문입니다.
따라서 (2A)에 해당하는 각 칸 $(x, y)$에서 $(x - w_x, y - w_y)$로 간선을 긋고,
(1)에 해당하는 칸들을 시작점으로 하여 그래프 순회를 해주면 됩니다.
이때 각 칸이 적어도 한 번 방문되었을 경우 그 칸에는 분자가 있고, 아니면 빈칸입니다.&lt;&#x2F;p&gt;
&lt;p&gt;분자가 가장 많은 경우도 비슷합니다.
(1)로부터 무조건 빈칸이어야 하는 칸이 정해지고, 여기에 (2B)를 반복적으로 적용시켜야 합니다.
하지만 여기서 끝나는 게 아니라, (3) 격자의 바깥은 전부 빈칸입니다.
격자의 바깥에는 칸이 너무 많으니까 이걸 일일이 다 체크하지 말고, 여기다가 (2B)를 한 번 적용시켜서,
각 칸 $(x, y)$에 대해 $(x - w_x, y - w_y)$가 격자 바깥이면 $(x, y)$를 빈칸으로 두면 됩니다.
이제 (2B)에 해당하는 간선들을 긋고,
(1)과 (3 + 2B)에 해당하는 칸들을 시작점으로 하여 그래프 순회를 해주면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;시간 복잡도는 $O(d_x d_y k)$입니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;b-dungeon-crawler&quot;&gt;B: Dungeon Crawler&lt;&#x2F;h1&gt;
&lt;p&gt;시작점을 루트로 잡읍시다.&lt;&#x2F;p&gt;
&lt;p&gt;열쇠와 함정을 무시할 경우, 트리 순회를 하는데 가장 깊은 (루트에서 가장 먼) 점에서 멈추는 것이 최적입니다.
따라서 답은 &lt;code&gt;2*(간선 길이의 합) - (가장 깊은 점의 깊이)&lt;&#x2F;code&gt;입니다.&lt;&#x2F;p&gt;
&lt;p&gt;이제 함정과 열쇠가 있다고 합시다. 우선 함정이 열쇠의 조상이면 &lt;code&gt;impossible&lt;&#x2F;code&gt;입니다.
아닐 경우, 가장 마지막으로 방문하는 정점이 d라고 합시다. 가장 깊은 점이 아닐 수도 있습니다.
열심히 케이스 분석을 해보면서, 각 경로를 지나는 횟수를 아래 그림에서 빨간 글씨로 표시해보면
다음과 같습니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;wf211.png&quot; alt=&quot;.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;함정과 열쇠의 LCA를 $l$, 열쇠와 $d$의 LCA를 $z$라고 하면
답은 &lt;code&gt;2*(간선 길이의 합) - (d의 깊이) + 2*(z에서 l까지 거리)&lt;&#x2F;code&gt;입니다.
모든 $d$에 대해 이걸 계산하고 최솟값을 찾으면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;쿼리를 같은 시작점들끼리 묶어, 각 시작점마다 $O(n)$ 시간 전처리를 한 번씩 해줄 수 있다고 합시다.
그 후 각 쿼리를 어떻게든 $O(n)$에 수행하면 $O(n^2 + qn)$이고, 이는 약 4억이므로 시간 내에 돌아갑니다.&lt;&#x2F;p&gt;
&lt;p&gt;저기서 시간이 걸리는 요인은 (1) LCA 계산, (2) 거리 계산입니다.&lt;&#x2F;p&gt;
&lt;p&gt;(1) LCA의 경우, 모든 정점과 열쇠의 LCA를 구하는 것이 문제입니다.
LCA는 희소 배열 외에도 오일러 투어 + 구간 최솟값 쿼리로 풀 수 있음이 알려져 있습니다.
이 구간 최솟값도 범위의 한쪽 끝이 정해져 있기 때문에,
세그먼트 트리 같은 걸 쓸 필요 없이 그냥 범위를 하나씩 늘려 주면서 최솟값을 갱신하면
전체 $O(n)$에 모든 LCA를 구할 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;(2) 거리 계산의 경우, $z$와 $l$은 조상 관계이기 때문에 두 정점의 깊이의 차를 구하면 됩니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;c-fair-division&quot;&gt;C: Fair Division&lt;&#x2F;h1&gt;
&lt;p&gt;첫 번째 해적이 받는 금화의 비율은 $\sum_{i=0}^{\infty}(1-f)^{ni} = \frac{1}{1-(1-f)^n}$입니다.
$(j+1)$번째 해적이 받는 금화의 비율은 $\frac{(1-f)^j}{1-(1-f)^n}$입니다.
따라서 금화의 비는 $1 : (1-f) : \cdots : (1-f)^{n-1}$입니다.
$f = \frac{p}{q}$이고 $p$와 $q$가 서로소라고 하면, 금화의 비는
$q^{n-1} : q^{n-2}(q-p) : \cdots : (q-p)^{n-1}$입니다.
이 수들은 서로소이므로 $q^{n-1} + \cdots + (q-p)^{n-1}$의 합이 $m$의 약수여야 합니다.&lt;&#x2F;p&gt;
&lt;p&gt;그러려면 일단 $q^{n-1} \leq m$이어야 되는데, $n-1 \geq 5$이고
$m \leq 10^{18}$이기 때문에 $q \leq 3981$까지만 보면 됩니다. (1000이 아닙니다!)
오버플로우를 막으려면 저 $n$개 항을 통째로 합하는 게 아니라,
하나하나 더하면서 $m$을 넘을 때 바로 끊어줘야 합니다.
시간 복잡도는 $O(m^{2&#x2F;(n-1)})$입니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;d-guardians-of-the-gallery&quot;&gt;D: Guardians of the Gallery&lt;&#x2F;h1&gt;
&lt;p&gt;대회 당시 유일하게 아무도 못 푼 문제였습니다.
아쉽게도 딱 한 테스트케이스에서 틀린 팀이 있었다고 합니다.&lt;&#x2F;p&gt;
&lt;p&gt;우선 조각상이 보이는 영역을 구해야 합니다. 조각상에서 각 꼭짓점으로 반직선을 긋습니다.
각 반직선에 대해, 그 반직선이 미술관의 어디까지 닿는지를 계산합니다.
간단하게 생각하면 반직선과 각 선분의 교점을 구하고 가장 가까운 교점을 구하면 되는데,
실제로는 반직선의 왼쪽과 오른쪽 영역이 모두 막히는 교점까지 가야 합니다.
예를 들어 아래 그림에서 A 방향으로 그은 반직선은 A에서 끝나는 게 아니라
오른쪽 영역까지 막히는 B까지 가야 합니다.
각 선분이 어느 방향에서 교차하는지를 구하고, 교점을 가까운 순으로 정렬한 다음 하나씩 확인하면 됩니다.
시간 복잡도는 $O(n^2)$이고, 이 다각형에는 변이 $O(n)$개 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;wf212.png&quot; alt=&quot;.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;이제 출발점에서 목표 영역까지 가는 최단거리를 구해야 합니다. 최단경로는 다음과 같은 형태입니다.
(1) 우선 미술관의 꼭짓점 몇 개를 거치고, (2) 마지막에 목표 영역의 한 변에 수직인 방향으로 직진합니다.&lt;&#x2F;p&gt;
&lt;p&gt;(1)은 출발점, 목표 영역의 꼭짓점 및 미술관의 꼭짓점들을 정점으로 잡고,
서로 이동 가능한 정점 쌍을 이어 그래프를 만든 뒤 데이크스트라 알고리즘을 돌려서 구할 수 있습니다.
정점 쌍이 서로 이동 가능한지 판별하려면 둘을 잇는 선분이 미술관의 각 변과 (끝점 제외하고)
안 겹치는지 판별하면 됩니다. 시간 복잡도는 $O(n^3)$입니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;wf213.png&quot; alt=&quot;.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;마지막으로, (2)는 각 정점에서 목표 영역의 각 변으로 수선을 긋고,
마찬가지로 미술관의 각 변과 안 겹치는지 + 수선이 실제로 그 변과 만나는지 판별하면 됩니다.
시간 복잡도는 $O(n^3)$입니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;e-hand-of-the-free-marked&quot;&gt;E: Hand of the Free Marked&lt;&#x2F;h1&gt;
&lt;p&gt;우선 Fitch Cheney trick의 원본부터 분석해 봅시다.
이 마술은 본질적으로 &lt;strong&gt;52개 카드 집합에서의 크기 5의 조합&lt;&#x2F;strong&gt;에서
&lt;strong&gt;52개 카드 집합에서의 크기 4의 순열&lt;&#x2F;strong&gt;로 가는 일대일함수를 만드는 문제입니다.
조교는 조합에서 순열로 함수를 적용하고, 마술사는 그 순열에서 다시 조합으로 역함수를 적용하는 것이죠.&lt;&#x2F;p&gt;
&lt;p&gt;카드가 전체 $n$개이고 그중에서 $k$개를 뽑는다면,
전자는 $A := \frac{n!}{k!(n-k)!}$개이고, 후자는 $B := \frac{n!}{(n-k+1)!}$인데,
$A \leq B$이면 일대일함수가 존재할 것 같이 생겼습니다.
계산해보면 $n = k!+k-1$일 때 정확히 $A = B$이고,
$n$이 그보다 커지면 $A &amp;gt; B$라서 일대일함수가 존재할 수 없습니다.
물론 순열을 이루는 카드 4개가 모두 조합에 속해야 하기 때문에,
$A \leq B$라고 해서 아무렇게나 일대일함수를 만들면 안 됩니다.
다행히도 조건을 만족하는 일대일함수가 항상 존재합니다. 왜냐?&lt;&#x2F;p&gt;
&lt;p&gt;전자와 후자를 잇는 이분그래프를 생각합시다. 카드가 많을 때 가능하다면 적을 때도 가능하니까,
$n = k!+k-1$, $A = B$라고 합시다.
이제 이 그래프에 완전 매칭이 존재함을 홀의 정리로 증명합니다.
각 전자 조합은 정확히 $k!$개의 후자 순열과 인접하고, $A = B$니까
각 후자 순열도 정확히 $k!$개의 전자 조합과 인접합니다.
즉 이 그래프는 $k!$-regular graph입니다.
이제 전자 조합을 $s$개 골랐다고 하면, 이 조합들은 $k!s$개의 간선과 연결되어 있기 때문에,
적어도 $s$개의 후자 순열이 이 조합들과 인접해야 합니다.
따라서 홀의 정리에 의해 완전 매칭이 존재합니다.&lt;&#x2F;p&gt;
&lt;p&gt;$A &amp;gt; B$일 경우, 마술이 성공할 확률은 $\frac{B}{A}$입니다.
함숫값이 가능한 한 안 겹치도록 함수를 만들었으면, 전자의 원소 중에서 함수를 취하고
“역함수“를 취했을 때 자기 자신으로 돌아올 수 있는 원소가 $B$개이기 때문입니다.&lt;&#x2F;p&gt;
&lt;p&gt;이제 이 문제에서는 카드가 너무 많아서, &lt;del&gt;덱에서 카드를 몇 개 뺄 생각은 안 하고&lt;&#x2F;del&gt;
카드에 마킹을 해놓아서 마술사가 마지막 카드의 마킹을 알 수 있습니다.
얼핏 생각해보면 전자는 그대로 조합이고, 후자는 순열에다가 마킹 하나가 추가로 주어진 거니까
그대로 $A$와 $B$를 구하면 될 것처럼 생겼지만,
이러면 regular graph가 아니라서 위의 증명이 통하지 않습니다.&lt;&#x2F;p&gt;
&lt;p&gt;그 대신, 마술사가 마지막만이 아니라 &lt;strong&gt;모든 카드의 마킹&lt;&#x2F;strong&gt;을 알 수 있다는 사실에 주목합시다.
무슨 카드에 무슨 마킹이 있는지 외우면 그만이니까요.
따라서 마킹의 조합은 마술사와 조교가 공유하는 정보입니다.
그뿐만 아니라, 마킹의 조합을 고정하고 나면 &lt;strong&gt;원본 Fitch Cheney trick과 동일한 문제&lt;&#x2F;strong&gt;가 됩니다.
마킹의 조합을 백트래킹으로 뽑아내고, 각 조합에 대해 그 조합이 실제로 뽑힐 확률과
그 조합에서 마술이 성공할 확률을 곱하여 모두 더하면 답을 얻습니다.&lt;&#x2F;p&gt;
&lt;p&gt;마킹의 조합의 개수는 $m$과 $k$의 중복조합인데, $m=k=10$일 때 이는 $\binom{19}{10}=92378$이므로
충분히 모두 뽑아낼 수 있습니다. 이제 각 마킹 $i$에 대해, 그 마킹이 된 카드가 전체 $A_i$개이고
그중에서 $C_i$개를 뽑았다고 하면, 그 조합이 뽑힐 확률은
$\frac{1}{\binom{n}{k}} \prod \binom{A_i}{C_i}$이고,
그 조합에서 마술이 성공할 확률은
$\min(1, \frac{1}{\prod \binom{A_i}{C_i}} (k-1)! \prod \binom{A_i}{C_i} \sum_{C_i &amp;gt; 0} \frac{\binom{A_i}{C_i - 1}}{\binom{A_i}{C_i}})$ $= \min(1, (k-1)! \sum_{C_i &amp;gt; 0}\frac{C_i}{A_i - C_i + 1})$
입니다.&lt;&#x2F;p&gt;
&lt;p&gt;저는 여기에 log를 씌워서 계산한 다음 exp로 되돌리는 식으로 구현했는데,
&lt;code&gt;long double&lt;&#x2F;code&gt;도 안 되고 &lt;code&gt;__float128&lt;&#x2F;code&gt;까지 써야 $10^{-10}$ 정도의 절대오차로 통과했습니다.
모범 코드는 &lt;code&gt;double&lt;&#x2F;code&gt;만 쓴 걸로 봐서 식을 어떻게 정리했느냐에 따라
&lt;code&gt;double&lt;&#x2F;code&gt;로도 충분히 통과되는 것으로 보입니다.&lt;&#x2F;p&gt;
&lt;p&gt;시간 복잡도는 $O(\binom{m+k-1}{k}m)$입니다.&lt;&#x2F;p&gt;
&lt;p&gt;Fitch Cheney trick을 직접 선보이고 싶다면
&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;25434&quot;&gt;이 문제&lt;&#x2F;a&gt;와
&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;25460&quot;&gt;이 문제&lt;&#x2F;a&gt;를 풀어보시면 되겠습니다.
참고로 간선이 너무 많아서 이분 매칭 알고리즘을 직접 돌리는 식으로는 풀 수 없고,
매칭을 머리로 찾아내야 합니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;f-islands-from-the-sky&quot;&gt;F: Islands from the Sky&lt;&#x2F;h1&gt;
&lt;p&gt;지문이 무서워 보이지만 (3차원 기하???),
정작 읽어보면 대부분이 지문을 무서워 &lt;em&gt;보이게&lt;&#x2F;em&gt; 만드는 장치라고 느껴집니다.&lt;&#x2F;p&gt;
&lt;p&gt;$\theta$에 대해 이분탐색을 합니다. $\theta$를 정하면 각 사다리꼴 영역이 정해집니다.
비행기의 높이가 $h$이면 밑변의 길이는 $2h \tan \theta$이고,
방향은 비행 경로를 90도씩 회전시켜서 구할 수 있습니다.
이제 각 섬이 적어도 한 사다리꼴의 내부에 속하는지 판별합니다.
사다리꼴은 볼록다각형이므로 섬의 모든 꼭짓점만 확인하면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;시간 복잡도는 $O((\sum_{i=1}^n n_i) m\log X)$입니다.&lt;&#x2F;p&gt;
&lt;p&gt;저희 팀의 다른 팀원 분은 이분탐색 없이 풀었는데, 손 계산이 좀 들어갈 것 같습니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;g-mosaic-browsing&quot;&gt;G: Mosaic Browsing&lt;&#x2F;h1&gt;
&lt;p&gt;패턴과 격자의 높이가 1일 경우
&lt;a href=&quot;https:&#x2F;&#x2F;infossm.github.io&#x2F;blog&#x2F;2021&#x2F;08&#x2F;20&#x2F;wildcard-string-matching&#x2F;&quot;&gt;와일드카드 문자열 매칭&lt;&#x2F;a&gt;
문제와 동일하고, FFT로 풀 수 있습니다.
이 문제에서는 격자에 와일드카드가 없으므로 $T_j$는 안 곱해도 됩니다. 계수가 꽤 큰 편이므로 주의하세요.&lt;&#x2F;p&gt;
&lt;p&gt;높이가 2 이상일 경우, 그냥 격자를 일렬로 펴고 패턴에 와일드카드 패딩을 붙이면 높이 1 문제로 환원됩니다.
예를 들어 예제는 이렇게 될 겁니다.
물론 몇몇 인덱스는 격자에 안 맞기 때문에 매칭이 되어도 출력하지 말아야 합니다.&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;패턴: 1 0 0 0 0 1
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;격자: 1 2 1 2 2 1 1 1 2 2 1 3
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;bitset으로 푸는 방법도 있다고 합니다…&lt;&#x2F;p&gt;
&lt;h1 id=&quot;h-prehistoric-programs&quot;&gt;H: Prehistoric Programs&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;atcoder.jp&#x2F;contests&#x2F;abc167&#x2F;tasks&#x2F;abc167_f&quot;&gt;AtCoder Beginner Contest 167F&lt;&#x2F;a&gt;와 같은 문제이고,
&lt;a href=&quot;https:&#x2F;&#x2F;codeforces.com&#x2F;gym&#x2F;101341&#x2F;problem&#x2F;A&quot;&gt;다른 대회에서도&lt;&#x2F;a&gt; 몇 번 나왔다고 합니다.
심지어 &lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;12776&quot;&gt;2016년 월드 파이널 Swap Space&lt;&#x2F;a&gt;와도 거의 같은 문제입니다!&lt;&#x2F;p&gt;
&lt;p&gt;우선 주어진 문자열이 올바른 괄호 문자열인지 판별하는 문제를 생각해봅시다.
PS를 입문할 때 접해보셨을 유명한 문제입니다.
문자를 차례대로 보면서 &lt;code&gt;(&lt;&#x2F;code&gt;이면 카운터를 1 증가시키고 &lt;code&gt;)&lt;&#x2F;code&gt;이면 1 감소시킬 때,
카운터가 단 한 번도 음수가 되지 않으면서 마지막에는 0이 되어야 합니다.&lt;&#x2F;p&gt;
&lt;p&gt;이제 이 문제로 돌아와보면, 각 조각은 다음과 같은 정보로 표현할 수 있습니다.
“이 조각을 사용하려면 카운터가 $x$ 이상이어야 하고, 사용하면 카운터가 $d$만큼 변한다.”&lt;&#x2F;p&gt;
&lt;p&gt;모든 $d$의 합이 0이 아니면 당연히 &lt;code&gt;impossible&lt;&#x2F;code&gt;입니다. 이제 합이 0이라고 가정합시다.
$d \geq 0$인 조각들을 &lt;strong&gt;올라가는 조각&lt;&#x2F;strong&gt;, $d &amp;lt; 0$인 조각들을 &lt;strong&gt;내려가는 조각&lt;&#x2F;strong&gt;이라고 합시다.
그러면 먼저 올라가는 조각이 다 나오고, 그 다음에 내려가는 조각이 다 나와야 합니다.
어떤 올바른 해에서 내려가는 조각 바로 다음에 올라가는 조각이 나왔다면
그 둘을 교환해도 여전히 올바른 해가 되기 때문입니다.&lt;&#x2F;p&gt;
&lt;p&gt;이 조건대로 나열하면 카운터는 올라가는 조각을 다 쓰면서 정점을 찍고 다시 내려가는 조각을 다 써서
0으로 돌아오게 됩니다.
그 정점을 기준으로 둘로 나누고, 내려가는 조각을 쓰는 과정을 뒤집으면,
올라가는 조각을 쓰는 과정만 두 번 있는 형태가 됩니다.
따라서 올라가는 조각만 쓰는 문제를 두 번 풀면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;이제 올라가는 조각들을 잘 정렬해야 되는데, 그 순서는 바로 $x$에 대한 오름차순입니다.
어떤 올바른 해에서 $(x_1, d_1)$ 바로 다음에 $(x_2, d_2)$이 나오고 $x_1 &amp;gt; x_2$라면,
$(x_1, d_1)$을 쓰는 순간에 카운터는 $c \geq x_1$인데,
둘을 교환하면 $c \geq x_1 &amp;gt; x_2$, $c + d_2 \geq c \geq x_1$이라서
여전히 올바른 해가 되기 때문입니다.&lt;&#x2F;p&gt;
&lt;p&gt;이렇게 정렬했는데도 올바른 괄호 문자열이 안 되면 &lt;code&gt;impossible&lt;&#x2F;code&gt;이고,
되면 그 순서를 그대로 출력해주면 됩니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;i-spider-walk&quot;&gt;I: Spider Walk&lt;&#x2F;h1&gt;
&lt;p&gt;편의를 위해, 거미줄이 원형이 아니라 1번과 $N$번 가닥이 안 이어진 선형이라고 합시다.
풀이는 거의 달라지지 않습니다. 이제 우리가 풀어야 하는 문제는 다음과 같습니다.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;사다리타기를 하는데, $i$번째 가닥에서 시작해서 $s$번째 가닥의 맨 밑에 도착하려고 합니다.
그어야 하는 다리의 최소 개수를 각각의 $i$에 대해 구하세요.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;위에서 아래로 움직이면서 각 가닥으로부터 $s$번째 가닥까지 가는 게 아니라,
거꾸로 아래에서 위로 움직이면서 $s$번째 가닥으로부터 각 가닥까지 간다고 생각합시다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;DP[i][j]&lt;&#x2F;code&gt;를, 첫 $i$개의 다리만 고려하고 나머지 다리를 자유롭게 그을 수 있을 때
$j$번째 가닥에 오는 최소 비용이라고 합시다.
&lt;code&gt;DP[0][..]&lt;&#x2F;code&gt;은 $s$를 시작으로 양옆으로 하나씩 늘어나는 형태일 것입니다.&lt;&#x2F;p&gt;
&lt;p&gt;우선 &lt;code&gt;DP[i][..]&lt;&#x2F;code&gt;은 이웃한 DP 값들의 차이가 1 이하임을 염두에 둡시다.
이웃한 DP 값이 2 이상 차이가 날 경우, 낮은 쪽에서 높은 쪽으로 다리를 이어주면
더 좋은 해가 나오기 때문입니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;DP[i][..]&lt;&#x2F;code&gt;가 계산되었을 때 &lt;code&gt;DP[i+1][..]&lt;&#x2F;code&gt;을 계산하려면,&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i&lt;&#x2F;code&gt;번째 다리가 $a$와 $a+1$을 잇는다고 합시다.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;DP[i+1][a+1]&lt;&#x2F;code&gt;과 &lt;code&gt;DP[i+1][a]&lt;&#x2F;code&gt;에 각각 &lt;code&gt;DP[i][a]&lt;&#x2F;code&gt;와 &lt;code&gt;DP[i][a+1]&lt;&#x2F;code&gt;을 넣고,
나머지 &lt;code&gt;DP[i+1][..]&lt;&#x2F;code&gt; 값들은 &lt;code&gt;DP[i][..]&lt;&#x2F;code&gt;를 그대로 따라갑니다.&lt;&#x2F;li&gt;
&lt;li&gt;두 DP 값이 교환되면서 이웃한 DP 값의 차이가 2가 될 수 있습니다.
이 경우 높은 쪽을 하나 낮춰줍니다. 일단 &lt;code&gt;DP[i+1][a]&lt;&#x2F;code&gt;와 &lt;code&gt;DP[i+1][a+1]&lt;&#x2F;code&gt;만 낮춰줍시다.&lt;&#x2F;li&gt;
&lt;li&gt;그런데 저 값들을 낮추면서 또 다른 이웃한 DP 값의 차이가 2가 될 수 있습니다.
얘네들은 한꺼번에 낮춰줍시다. &lt;code&gt;DP[i+1][a] = v&lt;&#x2F;code&gt;라고 할 때, 각 &lt;code&gt;DP[i+1][..]&lt;&#x2F;code&gt;를 다시 계산합니다. &lt;code&gt;DP[i+1][b]&lt;&#x2F;code&gt;에는 현재 값과 &lt;code&gt;v + (a에서 b까지의 거리)&lt;&#x2F;code&gt; 중 최솟값을 넣으면 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;DP[i+1][a+1] = v&#x27;&lt;&#x2F;code&gt;도 마찬가지로 써서 각 &lt;code&gt;DP[i+1][..]&lt;&#x2F;code&gt;를 다시 계산합니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;여기까지 하면 $O(nm)$입니다.&lt;&#x2F;p&gt;
&lt;p&gt;네 번째, 다섯 번째 과정에서 &lt;code&gt;DP[i+1][b]&lt;&#x2F;code&gt;들을 효율적으로 계산해야 합니다.
v + (a에서 b까지의 거리)&lt;code&gt;는 절댓값 함수이기 때문에, 기울기가 1 또는 -1인 일차함수 여러 개로 표현할 수 있습니다. 따라서 이는 세그먼트 트리 lazy propagation으로 최적화할 수 있습니다. Lazy 값을 &lt;&#x2F;code&gt;(p, q)&lt;code&gt;로 둬서 &lt;&#x2F;code&gt;min(현재 값, x+p, -x+q)`을 표현하면 됩니다. 시간 복잡도는 $O(n + m \log n)$입니다.&lt;&#x2F;p&gt;
&lt;p&gt;이외에도 DP 값의 차이가 1인 이웃한 인덱스들을 그룹으로 묶어서 &lt;code&gt;std::set&lt;&#x2F;code&gt;으로 관리하는 풀이가 있습니다. 네 번째 과정에서 최대 하나의 그룹이 통째로 내려갈 것입니다. 따라서 내려갈 때 양옆의 그룹과 합쳐야 되면 합치고, DP 값을 교환할 때 그룹을 분리하는 식으로 구현할 수 있습니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;j-splitstream&quot;&gt;J: Splitstream&lt;&#x2F;h1&gt;
&lt;p&gt;우선 각 노드에 들어가는 수의 개수를 계산합니다. 1번을 입력으로 받는 노드는 정확히 $m$개의 수를 받습니다. Split 노드는 자신이 입력으로부터 받은 양을 두 출력 노드에 대강 반씩 나눠줍니다. 정확한 양은 자신에 들어가는 수의 개수의 홀짝성에 따라 다릅니다. Merge 노드는 출력 노드에 자신이 두 입력으로부터 받은 양 만큼 넘겨줍니다. 이 모든 것은 재귀 DP를 돌리거나, 위상 정렬하고 그 순서대로 DP를 돌려서 구할 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;쿼리를 처리하려면, $x$에서부터 입력 노드를 타고 거꾸로 거슬러 올라가면서 $k$를 관리하면 됩니다. 현재 보고 있는 입력이 split 노드의 출력일 경우 그 노드의 입력으로 올라가고, $k$는 대강 두 배가 됩니다. 정확한 양은 그 입력이 split 노드의 어느 방향 출력인지에 따라 다릅니다. Merge 노드일 때는 조금 복잡합니다. Merge 노드의 두 입력에 들어가는 수가 각각 $a$, $b$개라고 합시다. $k \leq 2 \times \min(a, b)$라면, $k$의 홀짝성에 따라 어느 입력으로 올라가는지가 다르고 $k$는 대강 절반이 됩니다. 아니라면, 둘 중 개수가 큰 입력으로 올라가고 $k$는 $\min(a, b)$만큼 감소합니다.&lt;&#x2F;p&gt;
&lt;p&gt;거슬러 올라가다가 한 번이라도 $k$가 현재 입력에 있는 수의 개수를 넘어가면 &lt;code&gt;none&lt;&#x2F;code&gt;이고, 넘어가는 일 없이 1번 입력까지 올라갔으면 그 $k$를 그대로 출력하면 됩니다. $O(qn)$인데 $q$와 $n$이 모두 작기 때문에 시간 내에 잘 돌아갑니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;k-take-on-meme&quot;&gt;K: Take On Meme&lt;&#x2F;h1&gt;
&lt;p&gt;각각의 밈은 벡터로 볼 수 있습니다. 노드 $v$의 최종 밈으로 가능한 모든 벡터의 집합을 $S_v$라고 합시다.&lt;&#x2F;p&gt;
&lt;p&gt;우선 벡터의 집합 $S$와 $T$에 대해,&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$-S = {-p : p \in S}$, 즉 모든 벡터를 180도 뒤집은 집합,&lt;&#x2F;li&gt;
&lt;li&gt;$S + T = {p+q : p \in S, q \in T}$, 즉 두 집합에서 하나씩 뽑아 합치는 모든 경우를 담은 집합이라고 합시다. 이를 “집합의 덧셈“이라고 합시다. 마찬가지로 3개, $\cdots$, $k$개의 집합에 대해서도 덧셈을 정의할 수 있습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;이제 $S_v$를 다음과 같이 계산합니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;리프 노드이고 해당하는 밈이 $p$일 경우, $S_v = { p }$입니다.&lt;&#x2F;li&gt;
&lt;li&gt;자식 노드가 $1, \cdots, k$라고 합시다. 어떤 $i$에 대해, $S_1, \cdots, S_k$ 중 $S_i$만 그대로 두고 나머지를 $-S$로 뒤집은 다음, 그 집합들을 전부 더한 것을 $T_i$로 정의합니다. 이제 $S_v = \bigcup_i T_i$입니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;참 쉽죠? 아쉽게도 밈이 9,000개를 넘는데, 이러면 절대로 문제를 풀 수 가없으니 출제자가 치명적인 약점을 남겨 놨죠. 이 문제의 치명적인 약점은 바로 좌표 범위와 차수가 작다는 것입니다. &lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=dQw4w9WgXcQ&quot;&gt;우리는 결코&lt;&#x2F;a&gt; 이 문제를 포기하지도, 실망시키지도, 마음 바꿔 버리고 떠나지도 않을 겁니다.&lt;&#x2F;p&gt;
&lt;p&gt;사실 우리가 구해야 되는 건 $S_1$의 원소 중 원점에서 가장 먼 것입니다. 그러면 $S_v$의 원소를 다 들고 있지 말고, “원점에서 먼” 것들만 적당히 들고 있으면 되지 않을까요? 맞습니다. 각 벡터를 점으로 생각했을 때 볼록 껍질을 이루는 것들만 들고 있으면 됩니다. 그러니까 $S_v$는 그냥 벡터의 집합이 아니라 볼록다각형이라고 생각해도 충분합니다.&lt;&#x2F;p&gt;
&lt;p&gt;볼록다각형으로 생각하면 둘을 더하는 것도 간편합니다. 이를 &lt;a href=&quot;https:&#x2F;&#x2F;cp-algorithms.com&#x2F;geometry&#x2F;minkowski.html&quot;&gt;민코프스키 합&lt;&#x2F;a&gt;이라고 하고, 선형 시간에 구할 수 있습니다. 합집합은 그냥 볼록 껍질 알고리즘을 아무거나 쓰면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;이렇게 하면 최적화가 매우 많이 된다는 건 짐작 가능하지만, 정확한 시간 복잡도를 구하기는 어렵습니다. 대충 어림잡아 봅시다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;좌표 범위가 $X$일 때 볼록 다각형의 점의 개수는 $O(X^{2&#x2F;3})$임이 &lt;a href=&quot;https:&#x2F;&#x2F;codeforces.com&#x2F;blog&#x2F;entry&#x2F;62183&quot;&gt;알려져 있습니다&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;어떤 노드 $v$의 자식 노드가 $k$개이고, $v$ 서브트리 안에 리프 노드가 $f$개라고 하면, 좌표 범위는 $Xf$이므로 최종적으로 $O((Xf)^{2&#x2F;3})$개의 점이 남고, 이는 $O(k \log k(Xf)^{2&#x2F;3})$ 정도에 계산할 수 있습니다.&lt;&#x2F;li&gt;
&lt;li&gt;따라서 $S_1$은 $O(n \log k(Xn)^{2&#x2F;3})$ 정도에 계산할 수 있습니다.&lt;&#x2F;li&gt;
&lt;li&gt;$n = 10^4, k = 100, X = 10^3$을 넣으면 약 32억이 나옵니다.&lt;&#x2F;li&gt;
&lt;li&gt;서브트리가 작을 때는 $O((Xn)^{2&#x2F;3})$개보다 훨씬 적은 점이 쓰이고, 서브트리가 클 때도 매번 최악의 케이스가 나오는 건 불가능에 가깝기 때문에, 실제로는 32억보다 훨씬 적은 연산이 들 것임을 짐작할 수 있습니다. 이론적으로도 더 작은 상한을 얻는 게 가능할 것 같습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;실제로 돌려 보면 별다른 최적화를 하지 않아도 여유롭게 통과합니다. 제 구현은 약 200 ms가 걸립니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;l-where-am-i&quot;&gt;L: Where Am I?&lt;&#x2F;h1&gt;
&lt;p&gt;각 시작점에서 출발했을 때 각 마커를 언제 방문하는지 계산합니다. &lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;25294&quot;&gt;이 문제&lt;&#x2F;a&gt;를 풀어보시면 좋습니다. $O(N^2M)$에 구할 수 있고, 사실 $O((NM)^2)$에 시뮬레이션 돌려서 계산해도 잘 짜면 시간 내에 돈다고 합니다. ($N$은 격자의 크기, $M$은 마커의 개수)&lt;&#x2F;p&gt;
&lt;p&gt;각 시작점마다 그 방문 시각들을 정렬합니다. 그 후 그 목록들을 다시 한 번 사전순으로 정렬합니다. 예를 들면 이런 식으로 나올 겁니다. (정확한 수는 아니고 그냥 아무거나 쓴 겁니다.)&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;[0, 1, 5, 10]: (1, 3)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;[0, 1, 6, 7]: (2, 4)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;[1, 5, 7, 12]: (3, 3)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;[1, 5, 9, 13]: (4, 1)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;[1, 7, 10, 12]: (2, 1)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;[1, 9, 12, 15]: (4, 4)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;(3, 3)&lt;&#x2F;code&gt;과 &lt;code&gt;(4, 1)&lt;&#x2F;code&gt;을 처음으로 구별 가능한 시점은 7입니다. 6까지는 둘 다 마커를 1, 5에서 방문해서 서로 구별할 수 없지만, 7이 되면서 &lt;code&gt;(3, 3)&lt;&#x2F;code&gt; 쪽만 마커를 방문하기 때문입니다. 이를 일반화해보면, 목록이 $A$와 $B$인 두 지점을 구별 가능한 최초의 시점은 $A[i] \neq B[i]$인 가장 작은 $i$에 대해 $\min(A[i], B[i])$입니다.&lt;&#x2F;p&gt;
&lt;p&gt;이 비교 과정을 모든 목록으로 확장해봅시다. 시점 0이 되면 &lt;code&gt;(1, 3)&lt;&#x2F;code&gt;과 &lt;code&gt;(2, 4)&lt;&#x2F;code&gt;가 나머지 전부와 구별이 됩니다. 이제 재귀적으로 &lt;code&gt;(1, 3)&lt;&#x2F;code&gt;과 &lt;code&gt;(2, 4)&lt;&#x2F;code&gt;를 구별하고, 나머지 전부를 서로 구별하면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;$solve(t, l, r)$을 현재 시각이 $t$일 때 $l$번째부터 $r$번째 목록까지 구별하는 함수라고 합시다. $l &amp;gt; r$일 경우 할 게 없습니다. $l = r$일 경우 $l$번째 목록이 시각 $t$에서 유일하게 결정됩니다. $l &amp;lt; r$일 경우, $l$번째 목록이 마커를 다시 방문하는 순간까지 시각을 올렸다가, 그 시각 $t’$에 마커를 방문하는 목록이 $l$부터 $k$번째라면, $solve(t’, l, k)$와 $solve(t’, k+1, r)$을 재귀적으로 호출해주면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;출력할 때 $y$ 순으로 먼저 비교해서 정렬해야 한다는 점을 주의하세요.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>도형의 합집합과 넓이</title>
        <published>2022-09-18T00:00:00+00:00</published>
        <updated>2022-09-18T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              jh05013
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://jh05013.github.io/blog/shape-union/"/>
        <id>https://jh05013.github.io/blog/shape-union/</id>
        
        <content type="html" xml:base="https://jh05013.github.io/blog/shape-union/">&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;upload.wikimedia.org&#x2F;wikipedia&#x2F;commons&#x2F;thumb&#x2F;7&#x2F;7a&#x2F;Boolean_operations_on_shapes-en.svg&#x2F;330px-Boolean_operations_on_shapes-en.svg.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;도형의 불리언 연산&lt;&#x2F;strong&gt;이란, 여러 도형의 영역에 대한 집합 연산을 말합니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;7869&quot;&gt;두 원의 교집합의 넓이&lt;&#x2F;a&gt;를 구하는 방법은 잘 알려져 있습니다.
부채꼴 2개의 넓이를 합친 다음, 이등변삼각형 2개의 넓이를 빼는 방식으로 구할 수 있습니다.
같은 방법으로 두 원의 합집합의 넓이도 구할 수 있습니다.
하지만 원이 3개만 되어도 이런 “포함 배제” 접근을 하기 어렵습니다.&lt;&#x2F;p&gt;
&lt;p&gt;이 글에서는 도형의 합집합 및 그 넓이를 구하는 일반적인 방법을 소개합니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;teduri-ddagi&quot;&gt;테두리 따기&lt;&#x2F;h1&gt;
&lt;p&gt;아래 그림에서 테두리가 갖고 있는 중요한 성질을 찾아봅시다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;circle_union.png&quot; alt=&quot;A few circles, whose union of interior is colored.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;테두리는 도형의 둘레로 이루어져 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;그런데 이뿐만이 아닙니다. 도형의 둘레 중 &lt;strong&gt;다른 도형의 내부에 포함되지 않는 부분&lt;&#x2F;strong&gt;만이 테두리가 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;도형의 합집합의 테두리를 구하는 방법은 다음과 같습니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;도형 사이의 모든 교점을 구합니다.&lt;&#x2F;li&gt;
&lt;li&gt;각 도형마다 둘레를 다른 도형들과의 교점으로 분할합니다. 분할한 각 부분을 “조각“이라고 부릅시다.
&lt;ul&gt;
&lt;li&gt;위 그림에서 예를 들어보면, 맨 아래의 원은 네 조각으로 분할되어 있습니다.&lt;&#x2F;li&gt;
&lt;li&gt;원의 경우, 교점들을 각도 순으로 정렬하면 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;다각형의 경우, 우선 꼭짓점으로 분할하고, 각 변마다 그 위의 교점들을 정렬하면 됩니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;각 조각마다, 원래 자신이 속했던 도형을 제외하고 나머지 중 적어도 하나의 내부에 포함되는지 판별합니다.
포함되지 않는다면 그 조각은 테두리의 일부가 됩니다.
&lt;ul&gt;
&lt;li&gt;꼭 조각 전체를 생각할 필요는 없고, 조각 위의 한 점을 잡아서 점이 도형 내부에 속하는지 판별해도 됩니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;모든 도형이 원일 경우, 교점은 $O(n^2)$개이므로 조각도 $O(n^2)$개이고,
각 조각이 테두리를 이루는지 $O(n)$에 판별할 수 있으므로 전체 시간 복잡도는 $O(n^3)$입니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;javaeseoyi-sayong&quot;&gt;Java에서의 사용&lt;&#x2F;h2&gt;
&lt;p&gt;Java에는 이 기능이 내장되어 있습니다. 합집합만이 아니라 교집합, 차집합, 대칭차집합 등을 지원합니다.&lt;&#x2F;p&gt;
&lt;p&gt;도형은 &lt;code&gt;java.awt.geom&lt;&#x2F;code&gt;에 있는 클래스 &lt;code&gt;Path2D&lt;&#x2F;code&gt;, &lt;code&gt;Ellipse2D&lt;&#x2F;code&gt; 등으로 만들고 &lt;code&gt;Area&lt;&#x2F;code&gt;로 관리합니다. 만든 &lt;code&gt;Area&lt;&#x2F;code&gt;의 테두리를 &lt;code&gt;PathIterator&lt;&#x2F;code&gt;로 따올 수도 있습니다.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;java&quot; class=&quot;language-java z-code&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-support z-class z-java&quot;&gt;Area&lt;&#x2F;span&gt; &lt;span class=&quot;z-support z-class z-java&quot;&gt;A&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-assignment z-rhs z-java&quot;&gt;&lt;span class=&quot;z-keyword z-operator z-assignment z-java&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-instantiation z-java&quot;&gt;&lt;span class=&quot;z-keyword z-other z-storage z-new z-java&quot;&gt;new&lt;&#x2F;span&gt; &lt;span class=&quot;z-support z-class z-java&quot;&gt;Area&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-parens z-constructor-arguments z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-java&quot;&gt;;&lt;&#x2F;span&gt;  &lt;span class=&quot;z-comment z-line z-double-slash z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-java&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; 빈 Area를 만듦
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-support z-class z-java&quot;&gt;Path2D&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-support z-class z-java&quot;&gt;Double&lt;&#x2F;span&gt; p &lt;span class=&quot;z-meta z-assignment z-rhs z-java&quot;&gt;&lt;span class=&quot;z-keyword z-operator z-assignment z-java&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-instantiation z-java&quot;&gt;&lt;span class=&quot;z-keyword z-other z-storage z-new z-java&quot;&gt;new&lt;&#x2F;span&gt; &lt;span class=&quot;z-support z-class z-java&quot;&gt;Path2D&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-support z-class z-java&quot;&gt;Double&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-parens z-constructor-arguments z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-java&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;p&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-java&quot;&gt;&lt;span class=&quot;z-variable z-function z-java&quot;&gt;moveTo&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;a&lt;span class=&quot;z-punctuation z-separator z-comma z-java&quot;&gt;,&lt;&#x2F;span&gt; b&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-java&quot;&gt;;&lt;&#x2F;span&gt; &lt;span class=&quot;z-comment z-line z-double-slash z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-java&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; 커서를 이동
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;p&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-java&quot;&gt;&lt;span class=&quot;z-variable z-function z-java&quot;&gt;lineTo&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;a&lt;span class=&quot;z-punctuation z-separator z-comma z-java&quot;&gt;,&lt;&#x2F;span&gt; b&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-java&quot;&gt;;&lt;&#x2F;span&gt; &lt;span class=&quot;z-comment z-line z-double-slash z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-java&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; 커서를 이동시키면서 선분을 그림
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;p&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-java&quot;&gt;&lt;span class=&quot;z-variable z-function z-java&quot;&gt;closePath&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-java&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-support z-class z-java&quot;&gt;Area&lt;&#x2F;span&gt; &lt;span class=&quot;z-constant z-other z-java&quot;&gt;A2&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-assignment z-rhs z-java&quot;&gt;&lt;span class=&quot;z-keyword z-operator z-assignment z-java&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-instantiation z-java&quot;&gt;&lt;span class=&quot;z-keyword z-other z-storage z-new z-java&quot;&gt;new&lt;&#x2F;span&gt; &lt;span class=&quot;z-support z-class z-java&quot;&gt;Area&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-parens z-constructor-arguments z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;p&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-java&quot;&gt;;&lt;&#x2F;span&gt; &lt;span class=&quot;z-comment z-line z-double-slash z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-java&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; Path2D로부터 Area를 만듦
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-support z-class z-java&quot;&gt;A&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-java&quot;&gt;&lt;span class=&quot;z-variable z-function z-java&quot;&gt;add&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-constant z-other z-java&quot;&gt;A2&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-java&quot;&gt;;&lt;&#x2F;span&gt; &lt;span class=&quot;z-comment z-line z-double-slash z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-java&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; A에 A2를 합집합
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-support z-class z-java&quot;&gt;PathIterator&lt;&#x2F;span&gt; it &lt;span class=&quot;z-meta z-assignment z-rhs z-java&quot;&gt;&lt;span class=&quot;z-keyword z-operator z-assignment z-java&quot;&gt;=&lt;&#x2F;span&gt; area&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-java&quot;&gt;&lt;span class=&quot;z-variable z-function z-java&quot;&gt;getPathIterator&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-constant z-language z-java&quot;&gt;null&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-java&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-keyword z-control z-loop z-while z-java&quot;&gt;while&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-parens z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-keyword z-operator z-logical z-java&quot;&gt;!&lt;&#x2F;span&gt;it&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-java&quot;&gt;&lt;span class=&quot;z-variable z-function z-java&quot;&gt;isDone&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-block z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-java&quot;&gt;{&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;  &lt;span class=&quot;z-keyword z-control z-conditional z-switch z-java&quot;&gt;switch&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-parens z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;it&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-java&quot;&gt;&lt;span class=&quot;z-variable z-function z-java&quot;&gt;currentSegment&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;tmp&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-block z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-java&quot;&gt;{&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;    &lt;span class=&quot;z-keyword z-control z-conditional z-case z-java&quot;&gt;case&lt;&#x2F;span&gt; &lt;span class=&quot;z-support z-class z-java&quot;&gt;PathIterator&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-constant z-other z-java&quot;&gt;SEG_MOVETO&lt;&#x2F;span&gt;&lt;span class=&quot;z-keyword z-operator z-ternary z-java&quot;&gt;:&lt;&#x2F;span&gt; &lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;    &lt;span class=&quot;z-keyword z-control z-conditional z-case z-java&quot;&gt;case&lt;&#x2F;span&gt; &lt;span class=&quot;z-support z-class z-java&quot;&gt;PathIterator&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-constant z-other z-java&quot;&gt;SEG_LINETO&lt;&#x2F;span&gt;&lt;span class=&quot;z-keyword z-operator z-ternary z-java&quot;&gt;:&lt;&#x2F;span&gt; &lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;    &lt;span class=&quot;z-keyword z-control z-conditional z-case z-java&quot;&gt;case&lt;&#x2F;span&gt; &lt;span class=&quot;z-support z-class z-java&quot;&gt;PathIterator&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-constant z-other z-java&quot;&gt;SEG_CLOSE&lt;&#x2F;span&gt;&lt;span class=&quot;z-keyword z-operator z-ternary z-java&quot;&gt;:&lt;&#x2F;span&gt; &lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;  &lt;span class=&quot;z-punctuation z-section z-block z-end z-java&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;  it&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-java&quot;&gt;&lt;span class=&quot;z-variable z-function z-java&quot;&gt;next&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-java&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-java&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;자세한 내용은 &lt;a href=&quot;https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;7&#x2F;docs&#x2F;api&#x2F;java&#x2F;awt&#x2F;geom&#x2F;package-summary.html&quot;&gt;공식 문서&lt;&#x2F;a&gt;를 참조하세요.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;neolbi-guhagi&quot;&gt;넓이 구하기&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;strong&gt;그린 정리(Green theorem)&lt;&#x2F;strong&gt;&lt;sup class=&quot;footnote-reference&quot; id=&quot;fr-1-1&quot;&gt;&lt;a href=&quot;#fn-1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;는 닫힌 곡선에 대한 면적분을 선적분으로 바꿔주는 정리입니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$C$를 조각마다 매끄러운 단순 닫힌 곡선이라고 합시다.
&lt;ul&gt;
&lt;li&gt;“조각마다 매끄러운“은 무한 번 미분 가능한 곡선을 여러 개 이어붙인 형태를 의미합니다.&lt;&#x2F;li&gt;
&lt;li&gt;“단순“은 자기 자신과 교차하지 않음을 의미합니다.&lt;&#x2F;li&gt;
&lt;li&gt;“닫힌“은 출발했던 점으로 돌아옴을 의미합니다.&lt;&#x2F;li&gt;
&lt;li&gt;이러한 곡선의 예로 원이나 단순다각형이 있습니다.
단순다각형의 경우 선분이 무한 번 미분 가능한 곡선이고,
그 선분을 여러 개 이어붙인 형태이기 때문에 조각마다 매끄러운 곡선입니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;$D$를 그 곡선의 내부 영역이라고 합시다.&lt;&#x2F;li&gt;
&lt;li&gt;$L$과 $M$이 $(x, y)$에 대한 함수라고 합시다. 여기에도 조건이 더 붙지만 이 글에서는 필요하지 않습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;그러면 $C$를 반시계 방향으로 돌면서 선적분($\oint$)을 한다고 할 때 다음이 성립합니다.&lt;&#x2F;p&gt;
&lt;p&gt;$$
\oint_C(L\ dx+ M\ dy) =
\iint_D(\frac{\partial M}{\partial x} - \frac{\partial L}{\partial y}) \ dx \ dy
$$&lt;&#x2F;p&gt;
&lt;p&gt;이것으로 면적을 어떻게 구할 수 있을까요? 면적은 다음과 같습니다.&lt;&#x2F;p&gt;
&lt;p&gt;$$
\iint_D 1 \ dx \ dy
$$&lt;&#x2F;p&gt;
&lt;p&gt;따라서 $\frac{\partial M}{\partial x} - \frac{\partial L}{\partial y} = 1$이 되도록
$M$과 $L$을 잡아주면 됩니다.
대표적으로 $M = \frac{x}{2}$, $L = -\frac{y}{2}$를 사용하고, 이때 그린 정리는 이렇게 바뀝니다.&lt;&#x2F;p&gt;
&lt;p&gt;$$
\frac{1}{2} \oint_C(x\ dy - y\ dx) =
\iint_D 1 \ dx \ dy
$$&lt;&#x2F;p&gt;
&lt;p&gt;이제 우리가 원하는 곡선 $C$를 잡아준 다음 선적분을 열심히 계산하면 됩니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;weon-hana&quot;&gt;원 하나&lt;&#x2F;h2&gt;
&lt;p&gt;우선 중심이 $(x_c, y_c)$, 반지름이 $r$인 원 하나의 넓이를 구해봅시다.
그러려면 $C$를 $\theta$에 대한 매개변수 곡선으로 나타내면 됩니다.
즉 $x = x_c + r \cos \theta$, $y = y_c + r \sin \theta$, $0 \leq \theta &amp;lt; 2 \pi$입니다. 이제,&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;연쇄 법칙(chain rule)에 의해 $\oint (x\ dy - y\ dx) = \oint (x \frac{dy}{d\theta} d\theta - y \frac{dx}{d\theta} d\theta)$&lt;&#x2F;li&gt;
&lt;li&gt;$\frac{dy}{d\theta} = r \cos \theta$&lt;&#x2F;li&gt;
&lt;li&gt;$\oint x \frac{dy}{d\theta} d\theta = \oint (x_c + r \cos \theta)(r \cos \theta) d\theta = r \oint (x_c \cos \theta + r \cos^2 \theta) d\theta$&lt;&#x2F;li&gt;
&lt;li&gt;$-\oint y \frac{dx}{d\theta} d\theta = \oint (y_c + r \sin \theta)(r \sin \theta) d\theta = r \oint (y_c \sin \theta + r \sin^2 \theta) d\theta$&lt;&#x2F;li&gt;
&lt;li&gt;$\frac{1}{2} \oint (x \frac{dy}{d\theta} d\theta - y \frac{dx}{d\theta} d\theta) = \frac{r}{2} \oint (x_c \cos \theta + y_c \sin \theta + r) d\theta$&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;따라서 적분 결과는 $\frac{r}{2}(x_c \sin \theta - y_c \cos \theta + r\theta) + C$입니다.
실제로 $\theta$에 $0$과 $2\pi$를 넣어서 빼보면 원의 넓이인 $\pi r^2$만 남는 것을 확인할 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;한편, $a \leq \theta \leq b$에 해당하는 부채꼴 영역의 넓이를 구하려고
$\theta$에 $a$와 $b$를 넣어서 빼보면 이상한 값이 나오는데,
이는 부채꼴 영역이 호 하나만 있는 게 아니라 선분 두 개가 더 있기 때문입니다.
따라서 선분에 대해서도 선적분을 해줘야 합니다. 이에 대해서는 후술합니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;weon-du-gae&quot;&gt;원 두 개&lt;&#x2F;h2&gt;
&lt;p&gt;테두리가 호 두 개로 이루어져 있다고 해봅시다.
그러면 각각의 호를 매개변수 곡선으로 생각할 수 있습니다.
호의 매개변수 곡선은 위와 별반 다르지 않습니다.
방정식은 원과 같은데, $\theta$의 범위만 다릅니다.&lt;&#x2F;p&gt;
&lt;p&gt;이제 그린 정리를 여기에도 적용하려면 매개변수 곡선 두 개를 이어붙여
하나의 매개변수 곡선으로 만들어야 합니다.
그러려면 곡선의 방정식을 어떻게 바꿔야 할까요?&lt;&#x2F;p&gt;
&lt;p&gt;안 바꿔도 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;좀 더 단순화해서, 함수 $y = f_1(x)$ ($l_1 \leq x \leq r_1$), $y = f_2(x)$ ($l_2 \leq x \leq r_2$)
두 개를 이어붙여 만든 함수 ($l_1 \leq x \leq r_1 + r_2 - l_2$)를 적분한다고 해봅시다.
그러면 그 함수는&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$x \leq r_1$이면 $y = f_1(x)$&lt;&#x2F;li&gt;
&lt;li&gt;아니면 $y = f_2(x - r_1 + l_2)$&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;가 됩니다. 그런데
$\int_{r_1}^{r_1 + r_2 - l_2} f_2(x - r_1 + l_2) dx = \int_{l_2}^{r_2} f_2(x) dx$라서,
그냥 두 함수를 따로 적분하고 합하면 됩니다.
직관적으로, 함수를 $x$ 방향으로 평행이동한 것이라서 적분값이 달라질 리가 없습니다.&lt;&#x2F;p&gt;
&lt;p&gt;매개변수 곡선도 마찬가지입니다.
곡선들을 모아 하나의 큰 곡선으로 만들 필요 없이, 곡선 각각을 적분하고 합치면 됩니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;weon-yeoreo-gae&quot;&gt;원 여러 개&lt;&#x2F;h2&gt;
&lt;p&gt;원이 여러 개 있을 때로 절차를 확장하면 다음과 같습니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;원의 합집합의 테두리를 이루는 호를 모두 구합니다.&lt;&#x2F;li&gt;
&lt;li&gt;각 호에 대해 그린 정리를 적용해서 합칩니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;네, 이게 끝입니다. 매우 복잡한 디테일이 있을 것 같이 생겼지만 그렇지 않습니다.&lt;&#x2F;p&gt;
&lt;p&gt;첫째로 들 수 있는 의문점은 “테두리를 ‘순서대로’ 따라가면서 적분해야 하지 않나?“일텐데요,
그렇지 않습니다. 테두리의 모든 부분을 한 번씩 지나가기만 하면 됩니다.
즉, 적분을 할 호를 선택하는 순서는 중요하지 않습니다.&lt;&#x2F;p&gt;
&lt;p&gt;둘째로 “구멍이 있으면 이상해지지 않을까?“라는 의문이 들 수 있습니다.
다행히도 구멍이 얼마나 있든 넓이는 잘 계산됩니다.
왜냐하면 그 구멍은 시계방향으로 돌게 되어서, 자연스럽게 음의 넓이로 계산되기 때문입니다.
아래 그림에서 빨간색 테두리는 반시계방향으로 도는 부분, 파란색 테두리는 시계방향으로 도는 부분입니다.
원의 둘레를 반시계방향으로 돌 때 파란색 테두리에서 어떻게 되는지 확인해 보세요.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;circle_union.png&quot; alt=&quot;A few circles, whose union of interior is colored.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;seonbuni-pohamdoen-dohyeong&quot;&gt;선분이 포함된 도형&lt;&#x2F;h2&gt;
&lt;p&gt;다각형이나 부채꼴처럼 둘레에 선분이 포함될 경우,
꼭짓점을 기준으로 분할해서 선분 단위로 생각하면 편합니다.&lt;&#x2F;p&gt;
&lt;p&gt;선분은 매개변수 곡선 $x = x_c + v_x t$, $y = y_c + v_y t$, $0 \leq t \leq 1$로 표현할 수 있습니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;연쇄 법칙(chain rule)에 의해 $\oint (x\ dy - y\ dx) = \oint (x \frac{dy}{dt} dt - y \frac{dx}{dt} dt)$&lt;&#x2F;li&gt;
&lt;li&gt;$= \oint(v_y (x_c + v_x t)dt - v_x (y_c + v_y t)dt)$&lt;&#x2F;li&gt;
&lt;li&gt;$= \oint(v_y x_c - v_x y_c)dt$&lt;&#x2F;li&gt;
&lt;li&gt;$= (v_y x_c - v_x y_c)t + C$&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;$t$에 0과 1을 넣어서 빼면 그냥 $v_y x_c - v_x y_c$가 됩니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;munje-puli&quot;&gt;문제 풀이&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;boj-17804&quot;&gt;BOJ 17804&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;17804&quot;&gt;BOJ 17804 Knocked Ink&lt;&#x2F;a&gt;는 잉크가 원형으로 퍼질 때,
합집합의 넓이가 특정 값이 되는 순간을 구하는 문제입니다.&lt;&#x2F;p&gt;
&lt;p&gt;원의 합집합의 넓이는 시간에 따른 증가함수이기 때문에 이분탐색으로 답을 구할 수 있습니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ojuz-saegjongi&quot;&gt;ojuz 색종이&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;oj.uz&#x2F;problem&#x2F;view&#x2F;kriii3_T&quot;&gt;ojuz 색종이&lt;&#x2F;a&gt;는 색종이를 놓을 때마다
각 색종이가 보이는 영역의 넓이를 구하는 문제입니다.
서브태스크 1에서는 모든 색종이가 원이고, 2에서는 원 또는 삼각형입니다.&lt;&#x2F;p&gt;
&lt;p&gt;$A_{i,j}$를 첫 $i$개의 색종이를 놓았을 때 $j$번째 색종이가 보이는 영역의 넓이라고 합시다.
즉 우리가 구해야 하는 값은 모든 $A_{i,j}$입니다.
$i = j$일 때는 그냥 도형 하나의 넓이를 구해주면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;$S_{l,r}$을 $l$번째부터 $r$번째까지의 색종이를 놓았을 때 전체 영역의 넓이라고 합시다.
그러면 $i &amp;lt; j$일 때 $A_{i,j} = S_{j,i} - S_{j+1,i}$입니다.&lt;&#x2F;p&gt;
&lt;p&gt;모든 $A$ 값 대신에 모든 $S$ 값을 구해줍시다.
일단 색종이를 다 놓은 다음 모든 도형의 둘레를 조각으로 나눕니다.
그 다음 각 조각 및 모든 $l \leq r$에 대해,
그 조각이 $S_{l,r}$의 테두리를 이룰 경우 그 조각에 대한 적분값을 $S_{l, r}$에 더합니다.
도형 $k$로부터 나온 조각 하나가 $S_{l,r}$의 테두리를 이루려면&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;물론 $l \leq k \leq r$이어야 합니다.&lt;&#x2F;li&gt;
&lt;li&gt;도형 $k$를 놓는 순간 그 조각이 테두리에 있어야 합니다.
즉 도형 $l, \cdots, k-1$ 바깥에 그 조각이 있어야 합니다.&lt;&#x2F;li&gt;
&lt;li&gt;도형 $r$을 놓을 때까지 그 조각이 테두리에 남아있어야 합니다.
즉 도형 $k+1, \cdots, r$ 바깥에 그 조각이 있어야 합니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;$S_{l, r}$에 대한 표를 그려본다고 생각하면 각 조각이 영향을 미치는 $S$들은 직사각형을 이루기 때문에,
누적합으로 각 $S$를 계산할 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;주의할 점은 여러 조각이 완전히 일치할 수도 있다는 것입니다.
예를 들어 두 원이 완전히 일치하거나, 두 삼각형의 둘레가 선분으로 겹칠 수 있습니다.
이 경우 나중에 나타난 조각이 우위를 점하고 이전에 나타난 조각은 사라집니다.
그래서 각 조각이 $S_{l,r}$의 테두리를 이루는지 판별할 때 주의를 기울여야 합니다.&lt;&#x2F;p&gt;
&lt;p&gt;아쉽게도 서브태스크 1만 해도 구현량이 상당하기 때문에
&lt;a href=&quot;https:&#x2F;&#x2F;oj.uz&#x2F;submission&#x2F;565066&quot;&gt;서브태스크 1 코드&lt;&#x2F;a&gt;만 첨부합니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;boj-9598&quot;&gt;BOJ 9598&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;9598&quot;&gt;BOJ 9598 Cleaning the Hallway&lt;&#x2F;a&gt;는
도넛의 합집합의 넓이를 구하는 문제입니다.&lt;&#x2F;p&gt;
&lt;p&gt;도넛의 바깥쪽 원은 반시계방향으로 돌고, 안쪽 원은 시계방향으로 돌면 됩니다.
나머지는 원의 합집합과 동일합니다. 교점을 구하고 조각으로 나눈 다음 그린 정리를 써주되,
테두리를 구할 때는 조각이 &lt;strong&gt;도넛&lt;&#x2F;strong&gt;의 안에 속하는지 판별하면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;del&gt;참고로 전 안 풀었습니다.&lt;&#x2F;del&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gwanryeon-munje&quot;&gt;관련 문제&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;17804&quot;&gt;BOJ 17804 Knocked Ink&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;10900&quot;&gt;BOJ 10900 Lonely mdic&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;codeforces.com&#x2F;problemset&#x2F;problem&#x2F;107&#x2F;E&quot;&gt;CF 107E Darts&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;oj.uz&#x2F;problem&#x2F;view&#x2F;kriii3_T&quot;&gt;ojuz 색종이&lt;&#x2F;a&gt;의 서브태스크 1&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;9598&quot;&gt;BOJ 9598 Cleaning the Hallway&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;19368&quot;&gt;BOJ 19368 Circular Sectors&lt;&#x2F;a&gt; (왜 이런 문제를…)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;11392&quot;&gt;BOJ 11392 색종이&lt;&#x2F;a&gt;
(즉 위에 있는 ojuz 색종이의 서브태스크 2를 풀면 됩니다.)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;camgo-jaryo&quot;&gt;참고 자료&lt;&#x2F;h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;codeforces.com&#x2F;blog&#x2F;entry&#x2F;2111&quot;&gt;Area of union of circles (Codeforces)&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Boolean_operations_on_polygons&quot;&gt;Boolean operations on polygons (Wikipedia)&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;footer class=&quot;footnotes&quot;&gt;
&lt;ol class=&quot;footnotes-list&quot;&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;이 정리를 만든 수학자 &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;George_Green_(mathematician)&quot;&gt;George Green&lt;&#x2F;a&gt;을 따서 이름이 붙었습니다. &lt;a href=&quot;#fr-1-1&quot;&gt;↩&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;footer&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>BOJ 18796 이동하기 4</title>
        <published>2022-06-04T00:00:00+00:00</published>
        <updated>2022-06-04T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              jh05013
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://jh05013.github.io/blog/boj18796/"/>
        <id>https://jh05013.github.io/blog/boj18796/</id>
        
        <content type="html" xml:base="https://jh05013.github.io/blog/boj18796/">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;acmicpc.net&#x2F;problem&#x2F;18796&quot;&gt;https:&#x2F;&#x2F;acmicpc.net&#x2F;problem&#x2F;18796&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;60  +---+---+---+       +60-+60-+60-+
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    |   |   |   |       10  90  80  70
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;20  +---+---+---+       +20-+20-+20-+
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    |   |   |   |       10  90  80  70
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;90  +---+---+---+       +90-+90-+90-+
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    10  90  80  70
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;예제 입력 1과 각 이동의 비용을 그림으로 나타내면 위와 같습니다.
출력은 $10 + 20 + 20 + 20 + 70 = 140$입니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;munjeyi-jaeguseong&quot;&gt;문제의 재구성&lt;&#x2F;h1&gt;
&lt;p&gt;먼저, 생각하기 쉽도록 문제를 조금 변형해 봅시다.&lt;&#x2F;p&gt;
&lt;p&gt;맨 처음에 경로 하나가 주어집니다. 이 경로는 아래로 쭉 이동한 다음 오른쪽으로 쭉 이동합니다.&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;60  +
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;20  +
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;90  +---+---+---&amp;gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    10  90  80  70
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;이 경로가 아래, 오른쪽 순서로 지나간 칸이 있으면
이 칸을 오른쪽, 아래 순서로 지나가도록 경로를 변경할 수 있습니다.
이때 경로의 비용도 변화하는데, 그 변화량은
인접한 두 $B_c$ 값의 차와 인접한 두 $A_r$ 값의 차를 합하여 계산할 수 있습니다.&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;60  +
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;20  +---+          cost = (20-90) + (90-10)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        |               = 10
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;90      +---+---&amp;gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    10  90  80  70
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;이제 문제는 이렇게 바뀝니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;격자가 있습니다. 칸 $(x, y)$를 칠하는 비용은 $Cost[x,y] := R[x] + C[y]$입니다.&lt;&#x2F;li&gt;
&lt;li&gt;몇 개의 칸을 색칠할 건데, 색칠한 칸은 첫 열부터 마지막 열까지 높이가 단조감소하는 히스토그램을 이루어야 합니다.&lt;&#x2F;li&gt;
&lt;li&gt;비용을 최소화하세요.&lt;&#x2F;li&gt;
&lt;li&gt;편의를 위해, 비용이 최소이더라도 칸을 더 칠하면서 비용을 유지시킬 수 있다면 최적해가 아니라고 간주합시다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;이 최소 비용을 계산한 다음, 초기 경로의 비용에 더하면 원래 문제의 답을 얻습니다.&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    +---+---+---+
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; 40 |120|30 |30 |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    +---+---+---+
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;-70 |10 |-80|-80|
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    +---+---+---+
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;     80  -10 -10
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;예제 입력 1을 히스토그램 버전으로 재구성하면 위와 같이 됩니다.
$R$은 (-70, 40), $C$는 (80, -10, -10)입니다.
이 문제의 최적해는 아래 세 칸을 칠하는 것으로 -150의 비용이 들고,
초기 경로의 비용은 $10 \times 2 + 90 \times 3 = 290$이므로 출력은 $290 - 150 = 140$입니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;myeoc-gaji-gwancal&quot;&gt;몇 가지 관찰&lt;&#x2F;h1&gt;
&lt;p&gt;우선 첫 번째 열부터 봅시다. 최적해에서 첫 번째 열의 높이가 $i$라고 합시다.
즉 $(1, 1), (2, 1), \cdots, (i, 1)$을 칠했고 $(i+1, 1)$은 칠하지 않은 상태입니다.&lt;&#x2F;p&gt;
&lt;p&gt;그러면 다음이 성립합니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$Cost[i+1, 1] &amp;gt; 0$. 안 그러면 $(i+1, 1)$을 칠하지 않을 이유가 없습니다.&lt;&#x2F;li&gt;
&lt;li&gt;만약 두 번째 열이 $i$층을 칠하지 않았다면, $Cost[i, 1] \leq 0 \wedge Cost[i, 2] &amp;gt; 0$.
첫 번째 부등식이 성립하지 않으면 $(i, 1)$을 지우는 것이 더 좋고,
두 번째 부등식이 성립하지 않으면 $(i, 2)$를 칠하는 것이 더 좋습니다.&lt;&#x2F;li&gt;
&lt;li&gt;만약 두 번째 열도 $i$층을 칠했다면, $Cost[i+1,1] + Cost[i+1,2] &amp;gt; 0$.
안 그러면 $(i, 1)$과 $(i, 2)$를 칠하지 않는 것이 더 좋습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   +---+---+---+      +---+---+---+
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;i+1|   |   |   |   i+1|   |   |   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   +---+---+---+      +---+---+---+
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;i  |###|   |   |   i  |###|###|   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   +---+---+---+      +---+---+---+
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;i-1|###|   |   |   i+1|###|###|   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   +---+---+---+      +---+---+---+
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |###|###|   |      |###|###|   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   +---+---+---+      +---+---+---+
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    1   2              1   2
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;ilbanhwa&quot;&gt;일반화&lt;&#x2F;h2&gt;
&lt;p&gt;이를 일반화해봅시다. 만약 1, 2, 3, …, $k$번째 열이 정확히 $i$층까지 칠했고 $k+1$번째 열이 $i$층을 칠하지 않았다면,&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$Cost[i, 1] + \cdots + Cost[i, k] \leq 0$.
안 그러면 $(i, 1), \cdots, (i, k)$를 지우는 것이 더 좋습니다.&lt;&#x2F;li&gt;
&lt;li&gt;$Cost[i+1, 1] + \cdots + Cost[i+1, k] &amp;gt; 0$.
안 그러면 $(i+1, 1), \cdots, (i+1, k)$를 칠하는 것이 더 좋습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   +---+---+---+---+---+
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;i+1|   |   |   |   |   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   +---+---+---+---+---+
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;i  |###|###|###|   |   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   +---+---+---+---+---+
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;i-1|###|###|###|###|   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   +---+---+---+---+---+
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |###|###|###|###|###|
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   +---+---+---+---+---+
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    1       k   k+1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;geureomyeon-mueoseul-al-su-issnayo&quot;&gt;그러면 무엇을 알 수 있나요?&lt;&#x2F;h2&gt;
&lt;p&gt;두 부등식을 정리하면 $kR[i] + C[1] + \cdots + C[k] \leq 0 &amp;lt; kR[i+1] + C[1] + \cdots + C[k]$이므로,
$R[i] &amp;lt; R[i+1]$임을 알 수 있습니다.
히스토그램을 어떻게 칠하든 위에서 제시한 $k$는 반드시 존재하므로,
이는 **최적해의 첫 번째 열이 정확히 $i$층까지 칠했다면 $R[i] &amp;lt; R[i+1]$**임을 의미합니다.
그리고 이 관찰은 꼭 첫 번째 열에서만 적용되는 건 아닙니다.
**최적해의 어느 열이 정확히 $i$층까지 칠했을 경우, $R[i] &amp;lt; R[i+1]$**입니다.&lt;&#x2F;p&gt;
&lt;p&gt;반대로 말하면, &lt;strong&gt;$R[i] \geq R[i+1]$이면 $i$층에서 멈출 일이 없습니다&lt;&#x2F;strong&gt;.
즉 어떤 열이든 i층을 칠하면 i+1층도 반드시 칠해야 합니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;geureomeuro-iceungeul-jiubsida&quot;&gt;그러므로 i층을 지웁시다&lt;&#x2F;h1&gt;
&lt;p&gt;$R[i] \geq R[i+1]$이라면 $i$층과 $i+1$층을 아예 “합체“해줍시다. 즉&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;기존의 $R$ 배열이 $[R[1], \cdots, R[i], R[i+1], R[i+2], \cdots, R[N]]$이었다면,&lt;&#x2F;li&gt;
&lt;li&gt;새로운 $R$ 배열은 $[R[1], \cdots, R[i] + R[i+1], R[i+2], \cdots, R[N]]$이 됩니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;그런데 이렇게 그냥 합체해 버리면 칸을 칠하는 비용이 전과 맞지 않게 됩니다.
왜냐하면 합체 전에 $(i, 1)$과 $(i+1, 1)$을 칠하는 비용은 $R[i] + R[i+1] + 2C[1]$이었는데,
합체 후에 $(i, 1)$을 칠하는 비용은 $R[i] + R[i+1] + C[1]$이기 때문입니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;haegyeol-bangbeob&quot;&gt;해결 방법&lt;&#x2F;h2&gt;
&lt;p&gt;이를 해결하기 위해, 각 층마다 &lt;strong&gt;높이&lt;&#x2F;strong&gt; 값을 도입합니다. $i$층의 높이를 $H[i]$라고 할 때,
$Cost[i, j] := R[i] + H[i]C[j]$로 정의하고, 두 층을 합칠 때는 $R$과 $H$ 값을 모두 합치면 됩니다.&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   +---+---+---+---+---+
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;i  |###|###|###|   |   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |###|###|###|   |   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   +---+---+---+---+---+
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;i-1|###|###|###|###|   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   +---+---+---+---+---+
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |###|###|###|###|###|
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   +---+---+---+---+---+
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    1       k   k+1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;myeoc-gaji-gwancal-v2&quot;&gt;몇 가지 관찰 v2&lt;&#x2F;h2&gt;
&lt;p&gt;이제 위에서 본 그리디 전략을 다시 적용해 봅시다.
만약 1, 2, 3, …, $k$번째 열이 정확히 $i$층까지 칠했고 $k+1$번째 열이 $i$층을 칠하지 않았다면,&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$Cost[i, 1] + \cdots + Cost[i, k] = kR[i] + H[i]\mathscr{C} \leq 0$ ($\mathscr{C} := C[1] + \cdots + C[k]$).&lt;&#x2F;li&gt;
&lt;li&gt;$Cost[i+1, 1] + \cdots + Cost[i+1, k] = kR[i+1] + H[i+1]\mathscr{C} &amp;gt; 0$.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;따라서 $k \frac{R[i]}{H[i]} + \mathscr{C} \leq 0 &amp;lt; k \frac{R[i+1]}{H[i+1]} + \mathscr{C}$이므로,
$\frac{R[i]}{H[i]} &amp;lt; \frac{R[i+1]}{H[i+1]}$입니다.
같은 이유로, $\frac{R[i]}{H[i]} \geq \frac{R[i+1]}{H[i+1]}$이면
$i$층과 $i+1$층을 합체해줄 수 있습니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;eoddeohge-habcehaeya-haneunga&quot;&gt;어떻게 합체해야 하는가?&lt;&#x2F;h1&gt;
&lt;p&gt;이제 우리가 할 일은 $\frac{R[i]}{H[i]} \geq \frac{R[i+1]}{H[i+1]}$인
$i$를 찾아 합체하는 과정을 이러한 $i$가 존재하지 않을 때까지 반복하는 것입니다.
그런데 이러한 $i$가 여러 개라면 무엇을 먼저 합체해야 할까요?&lt;&#x2F;p&gt;
&lt;p&gt;그 답은… 상관없습니다. &lt;strong&gt;어떤 순서로 합체를 하더라도 최종적으로는 똑같은 배열이 됩니다.&lt;&#x2F;strong&gt;
왜일까요? $H$의 누적합을 $x$좌표, $R$의 누적합을 $y$좌표로 두고 점을 찍어봅시다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;move41.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;각각의 $H[i]$, $R[i]$ 쌍은 $i$번째와 $i+1$번째 점을 잇는 선분에 해당되고,
어떤 $i$에 대해 $i$번째 선분의 기울기가 $i+1$번째 선분의 기울기보다 크거나 같으면
$i+1$번째 점을 제거할 수 있습니다. 최종적으로는 선분들의 기울기가 단조증가하게 됩니다.
따라서, 어떤 순서로 합체를 하더라도 결국에는 아래로 볼록한 볼록 껍질만 남습니다.&lt;&#x2F;p&gt;
&lt;p&gt;합체 과정은 monotone chain 알고리즘처럼 스택으로 구현할 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;move42.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;이렇게 분수를 직선의 기울기로 생각하는 발상은 &lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;16760&quot;&gt;이 문제&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;12122&quot;&gt;이 문제&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;codeforces.com&#x2F;contest&#x2F;1300&#x2F;problem&#x2F;E&quot;&gt;이 문제&lt;&#x2F;a&gt; 등에서도 쓸 수 있습니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;yeol-habce&quot;&gt;열 합체&lt;&#x2F;h1&gt;
&lt;p&gt;지금까지의 논리를 $C$에도 적용할 수 있습니다.
각 열마다 &lt;strong&gt;너비&lt;&#x2F;strong&gt; $W[j]$ 값을 도입하고, $Cost[i, j] := R[i]W[j] + C[j]H[i]$로 정의한 뒤,
$\frac{C[j]}{W[j]}$ 값이 단조증가하도록 열을 합쳐 줍시다.&lt;&#x2F;p&gt;
&lt;p&gt;거의 다 왔습니다!&lt;&#x2F;p&gt;
&lt;h1 id=&quot;bunhae&quot;&gt;분해&lt;&#x2F;h1&gt;
&lt;p&gt;이제 아주 중요한 일이 일어납니다.
볼록 껍질의 둘레를 따라 각 $x$좌표마다 다시 점을 찍어서 볼록 껍질을 다시 $N$개의 선분으로 분해해 봅시다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;move43.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;그러면 볼록 껍질은 바뀌지 않았기 때문에 최적해도 바뀌지 않습니다.
선분들의 기울기는 여전히 단조증가합니다.
그런데 이제 모든 $H[i]$가 1이기 때문에, 이는 $R[i]$가 단조증가함을 의미합니다.
마찬가지로 모든 $W[j]$가 1이면서 $C[j]$도 단조증가하도록 바꿀 수 있습니다.
답을 바꾸지 않으면서 $R$과 $C$가 단조증가한다는 매우 강력한 조건을 추가한 것입니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mamuri&quot;&gt;마무리&lt;&#x2F;h2&gt;
&lt;p&gt;이제 나머지는 간단합니다. $Cost[i, j] &amp;gt; 0$이라면
$Cost[i+1, j]$와 $Cost[i, j+1]$도 모두 양수이기 때문에,
$Cost[i, j] \leq 0$인 모든 $(i, j)$는 높이가 단조감소하는 히스토그램의 형태를 갖습니다.
&lt;strong&gt;따라서 그 히스토그램이 그냥 최적해입니다.&lt;&#x2F;strong&gt;
히스토그램 및 비용은 투 포인터와 누적합으로 찾을 수 있습니다.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>IOI 2012-1-2 낙하산 고리들</title>
        <published>2022-06-04T00:00:00+00:00</published>
        <updated>2022-06-04T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              jh05013
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://jh05013.github.io/blog/boj5811/"/>
        <id>https://jh05013.github.io/blog/boj5811/</id>
        
        <content type="html" xml:base="https://jh05013.github.io/blog/boj5811/">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;5811&quot;&gt;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;5811&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;seobeutaeseukeu-1&quot;&gt;서브태스크 1&lt;&#x2F;h1&gt;
&lt;p&gt;각각의 정점이 중요한 고리인지 O(N)에 확인하면 됩니다.
즉, 해당 정점을 지웠을 때 나머지가 체인으로 구성되어 있는지 확인하면 됩니다.
가장 간단한 방법은 다음 조건을 검사하는 것이라고 생각됩니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;포레스트여야 합니다. 즉, 사이클이 없어야 합니다.&lt;&#x2F;li&gt;
&lt;li&gt;모든 정점의 차수가 2 이하여야 합니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;seobeutaeseukeu-2-3&quot;&gt;서브태스크 2, 3&lt;&#x2F;h1&gt;
&lt;p&gt;CountCritical이 호출될 때마다 모든 중요한 고리를 O(N)에 찾는 것이 목표입니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;관찰 1.&lt;&#x2F;strong&gt; 정점을 지우면 나머지 정점의 차수가 최대 1 감소합니다.
따라서, 차수가 4 이상인 정점 v가 있으면 v만 중요한 고리가 될 수 있습니다.
v가 아닌 정점을 지우면 v의 차수는 3 이상이라서 절대로 체인을 이룰 수 없기 때문입니다.&lt;&#x2F;p&gt;
&lt;p&gt;차수가 4 이상인 정점이 있으면 그중 아무거나 하나를 잡고 중요한 고리인지 확인하면 됩니다.
따라서 O(N)에 풀립니다.
(그런 정점이 여러 개면 아무 것도 중요한 고리가 될 수 없지만, 그 경우를 따로 처리할 필요는 없습니다.)&lt;&#x2F;p&gt;
&lt;p&gt;이제 그런 정점이 없다고 가정합시다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;관찰 2.&lt;&#x2F;strong&gt; 차수가 3인 정점 v가 있으면 v 및 v에 인접한 정점만 중요한 고리가 될 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;차수가 3인 정점이 있으면, 그중 아무거나 하나를 잡고 그 정점 및 그에 인접한 정점 3개를 확인하면 됩니다.
후보가 4개이므로 O(N)에 풀립니다.&lt;&#x2F;p&gt;
&lt;p&gt;이제 그런 정점도 없다고 가정합시다.
모든 정점의 차수가 2 이하이면, 모든 연결 요소는 체인이거나 사이클입니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;관찰 3.&lt;&#x2F;strong&gt; 사이클이 있으면 그 사이클에 있는 정점만 중요한 고리가 될 수 있습니다.
연결 요소 중 사이클이 없으면 답은 N, 하나이면 답은 그 사이클의 크기와 같고, 두 개 이상이면 답은 0입니다.&lt;&#x2F;p&gt;
&lt;p&gt;따라서 직접 정점을 지워볼 필요 없이 답을 그래프의 구조만 보고 알아낼 수 있습니다.
이번에도 O(N)에 풀립니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;seobeutaeseukeu-4-5&quot;&gt;서브태스크 4, 5&lt;&#x2F;h1&gt;
&lt;p&gt;간선을 추가하면서 위의 세 가지 관찰을 동적으로 관리하는 것이 목표입니다.
관찰 3부터 시작해서 거꾸로 올라가는 것이 좋습니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gwancal-3-coejeoghwa&quot;&gt;관찰 3 최적화&lt;&#x2F;h2&gt;
&lt;p&gt;차수가 3 이상인 정점이 생기지 않는다는 가정 하에 답을 동적으로 관리하려면 분리 집합을 사용하면 됩니다.
분리 집합에 크기까지 추가로 저장해 둡시다. 이제 답은 두 단계에 걸쳐 바뀌는데,&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;처음에는 답이 N입니다.&lt;&#x2F;li&gt;
&lt;li&gt;이미 연결된 두 점이 연결될 경우 사이클이 하나 형성됩니다.
사이클이 처음으로 형성될 경우, 답은 해당 연결 요소의 크기와 같습니다.&lt;&#x2F;li&gt;
&lt;li&gt;이미 연결된 두 점이 또 연결될 경우 답은 0입니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;그러다가 차수가 3인 정점이 생기는 순간, 이 자료구조를 파기하고 아래의 “관찰 2 최적화”
단락으로 넘어가면 됩니다. 정점의 차수는 그냥 배열로 관리하면 됩니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gwancal-2-coejeoghwa&quot;&gt;관찰 2 최적화&lt;&#x2F;h2&gt;
&lt;p&gt;이제 새로운 자료구조를 생각해야 합니다.
후보가 최대 4개니까, 각각의 후보에 대해 “이 후보를 지웠을 때 나머지가 체인을 이루는가“를
판별할 수 있으면 좋을 것입니다. 즉 후보 v가 실제로 중요한 고리인지 확인하려면&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;v와 연결된 간선을 모두 지우고,&lt;&#x2F;li&gt;
&lt;li&gt;나머지가 포레스트를 이루면서 최대 차수가 2인지 확인하고,&lt;&#x2F;li&gt;
&lt;li&gt;지운 간선을 모두 복원하면 됩니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;하지만 간선을 지우는 건 일반적으로 매우 어려운 작업입니다.&lt;&#x2F;p&gt;
&lt;p&gt;이를 해결하려면 그 4개의 후보가 한 번 정해진 후로 바뀌지 않는다는 점을 활용하면 됩니다.
(정확히는, 바꿀 필요가 없습니다.) 후보를 a, b, c, d라고 합시다.
간선을 하나 추가할 때마다 a를 지우고 확인한 다음 도로 추가하지 말고,
애초부터 a를 미리 지워놓고 간선이 추가될 때마다 확인해 줍시다. b, c, d도 마찬가지입니다.&lt;&#x2F;p&gt;
&lt;p&gt;즉 다음과 같은 자료구조를 a, b, c, d 하나씩 총 4개 만들면 됩니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;이 자료구조는 특정 정점 v를 &lt;strong&gt;무시&lt;&#x2F;strong&gt;합니다.&lt;&#x2F;li&gt;
&lt;li&gt;간선을 추가하려고 할 때, 간선의 양끝 점 중 하나가 v이면 &lt;strong&gt;무시&lt;&#x2F;strong&gt;합니다.&lt;&#x2F;li&gt;
&lt;li&gt;그래프 전체가 체인으로 이루어져 있는지 검사합니다.
이는 서브태스크 1에서 제시한 방법을 쓰면 분리 집합으로 구현할 수 있습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;이 자료구조를 새로 만드는 순간, 지금까지 나왔던 Link 쿼리들을 전부 이 자료구조에 적용시켜야 합니다.
관찰 3에서 쓴 자료구조에서 Link 쿼리들을 저장해 뒀다가, 관찰 2로 넘어갈 때 그대로 Link해주면 됩니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gwancal-1-coejeoghwa&quot;&gt;관찰 1 최적화&lt;&#x2F;h2&gt;
&lt;p&gt;관찰 1은 구현할 필요도 없습니다. 차수가 4 이상인 정점이 있든 없든
후보는 위에서 정한 a, b, c, d 중에 있다는 사실은 바뀌지 않습니다.&lt;&#x2F;p&gt;
&lt;p&gt;서브태스크 2, 3에서 관찰 1이 필요했던 이유는
차수가 매우 큰 정점에다가 그와 인접한 정점까지 다 확인하면 후보가 O(N)개나 되기 때문인데,
이미 관찰 2를 최적화하면서 후보를 O(1)개로 좁혀 버렸기 때문에 관찰 1은 이제 필요가 없습니다.&lt;&#x2F;p&gt;
&lt;p&gt;각 쿼리에 대한 시간 복잡도는 amortized O(logN)입니다.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>BOJ 22906 장난감 오렌지 만들기</title>
        <published>2022-05-22T00:00:00+00:00</published>
        <updated>2022-05-22T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              jh05013
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://jh05013.github.io/blog/boj22906/"/>
        <id>https://jh05013.github.io/blog/boj22906/</id>
        
        <content type="html" xml:base="https://jh05013.github.io/blog/boj22906/">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;22906&quot;&gt;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;22906&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;seobeutaeseukeu-1&quot;&gt;서브태스크 1&lt;&#x2F;h1&gt;
&lt;p&gt;사실 이 문제는 그래프로 모델링할 수 있습니다.
연결 고리의 색이 a, b인 블록은 정점 a와 b를 잇는 간선으로 보면,
각 쿼리는 정확히 l번째부터 r번째까지의 간선만으로 만들어진 그래프를
최소 개수의 회로(circuit)로 분할하는 문제가 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;모든 정점의 번호가 1 이상 2N 이하라고 합시다. 아니라면 좌표 압축을 하면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;l번째부터 r번째까지의 간선만 이은 다음, 각각의 연결 요소에 대해 문제를 풀고 합치면 답을 구할 수 있습니다.
연결 요소에 간선이 없다면 최소 회로는 0개입니다.
차수가 홀수인 정점이 하나라도 있다면 회로로 분할할 수 없습니다.
그렇지 않다면 오일러 회로를 만들 수 있기 때문에 최소 회로는 1개입니다.&lt;&#x2F;p&gt;
&lt;p&gt;따라서, 쿼리의 답은 차수가 홀수인 정점이 하나라도 있다면 -1,
아니면 간선이 최소 하나인 연결 요소의 개수와 같습니다.
쿼리가 들어올 때마다 DFS를 하면 O(QN)이 됩니다. 실제로 오일러 회로를 만들 필요는 없습니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;seobeutaeseukeu-2&quot;&gt;서브태스크 2&lt;&#x2F;h1&gt;
&lt;p&gt;차수가 홀수인 정점이 존재하는지를 빠르게 알아내야 합니다.&lt;&#x2F;p&gt;
&lt;p&gt;수열 &lt;code&gt;a1, b1, a2, b2, ..., aN, bN&lt;&#x2F;code&gt;을 생각해 봅시다.
그러면 2l번째부터 2r+1번째까지 보았을 때, 정확히 홀수 개 들어있는 수가 존재하는지 판별하는 문제가 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;“같은 수가 짝수 개“라는 키워드에서 XOR을 생각할 수 있습니다.
각 정점마다 랜덤으로 64비트 정수 “레이블“을 부여한 다음,
2l번째부터 2r+1번째까지 정점의 레이블 값을 XOR합시다.
이 값이 0이라면, &lt;em&gt;1에  가까운 확률로&lt;&#x2F;em&gt; 모든 수가 짝수 개씩 존재합니다.
0이 아니라면, &lt;em&gt;무조건&lt;&#x2F;em&gt; 홀수 개 들어있는 수가 적어도 하나 존재합니다.&lt;&#x2F;p&gt;
&lt;p&gt;수열의 값이 중간에 바뀌지 않으므로, 구간 XOR은 누적 합으로 쿼리 당 O(1),
총 O(N+Q)에 구할 수 있습니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;seobeutaeseukeu-3&quot;&gt;서브태스크 3&lt;&#x2F;h1&gt;
&lt;p&gt;서브태스크 2의 방법으로 답이 -1인지 아닌지는 알 수 있습니다.
이제 답이 -1이 아니면 “간선이 최소 하나인 연결 요소의 개수“를 세야 되는데,
일단 간선이 최소 하나라는 조건은 무시하고 그냥 연결 요소의 개수를 다 세어 봅시다.
그런데 사실 이것도 어렵기 때문에, 이걸 또 두 서브태스크로 나눠서 생각해야 합니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Easy 버전: 모든 쿼리의 l이 같습니다.&lt;&#x2F;li&gt;
&lt;li&gt;Hard 버전: 추가 제약 조건이 없습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;yeongyeol-yosoyi-gaesu-easy&quot;&gt;연결 요소의 개수 (Easy)&lt;&#x2F;h2&gt;
&lt;p&gt;우선 모든 쿼리의 l이 같다고 합시다.
그러면 모든 쿼리를 r에 대한 오름차순으로 정렬한 후 분리 집합으로 풀 수 있습니다.
l번째 간선부터 차례대로, 간선이 두 연결 요소 사이를 이을 때마다, 그 둘을 합쳐 주고 개수를 1 줄이면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;사실 쿼리를 정렬할 필요도 없습니다. 실제로 연결 요소를 합치는 데 사용된 간선들을 모아 놓으면,
&lt;code&gt;[l, r]&lt;&#x2F;code&gt;에 대한 답은 n - (번호가 r 이하인 간선의 개수)입니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yeongyeol-yosoyi-gaesu-hard&quot;&gt;연결 요소의 개수 (Hard)&lt;&#x2F;h2&gt;
&lt;p&gt;실제로 연결 요소를 합치는 데 사용된 간선들은 스패닝 포레스트를 이룰 것입니다.
l번째 간선에서부터 위 과정으로 만들어진 스패닝 포레스트를 F(l)이라고 합시다.&lt;&#x2F;p&gt;
&lt;p&gt;F(l)이 있을 때, F(l-1)은 어떻게 구할 수 있을까요?
우선 l-1번째 간선을 볼 때는 아무 간선도 없으므로, F(l)에다가 l-1번째 간선을 추가해 봅시다.
만약 l-1번째 간선이 F(l)의 서로 다른 연결 요소를 이었다면, 이게 그냥 F(l-1)입니다.&lt;&#x2F;p&gt;
&lt;p&gt;l-1번째 간선이 F(l)의 하나의 연결 요소 안에 놓여 있는 경우가 문제입니다.
l-1번째 간선이 정점 a와 b를 잇는다고 합시다.
그러면 F(l-1)을 만드는 과정은 F(l)과 거의 같은데, a와 b가 한 연결 요소로 모이는 시점이 앞당겨집니다.
그리고 &lt;strong&gt;F(l)에서 a와 b 사이의 경로 중 가장 마지막으로 추가된 간선&lt;&#x2F;strong&gt;이 무시됩니다.
나머지 간선은 변화가 없습니다.&lt;&#x2F;p&gt;
&lt;p&gt;따라서 F(l-1)은, F(l)을 구한 다음,
a와 b 사이의 경로 중 번호가 가장 큰 간선을 제거하고 a와 b를 바로 이으면 구할 수 있습니다.
링크-컷 트리로 모든 F(i)를 O(NlogN)에 구할 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;쿼리 &lt;code&gt;[l, r]&lt;&#x2F;code&gt;에 대한 답은 n - (F(l)에서 번호가 r 이하인 간선의 개수)입니다.
쿼리를 l에 대한 내림차순으로 정렬하고, F(n), F(n-1), …, F(1)을
차례대로 구하면서 모든 쿼리의 답을 펜윅 트리로 O(Q+NlogN)에 구할 수 있습니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ganseoni-issneun-yeongyeol-yosoyi-gaesu&quot;&gt;간선이 있는 연결 요소의 개수&lt;&#x2F;h2&gt;
&lt;p&gt;실제 답은 (차수가 1 이상인 정점의 개수) - (F(l)에서 번호가 r 이하인 간선의 개수)이기 때문에,
이제 차수가 1 이상인 정점의 개수를 구해야 합니다.&lt;&#x2F;p&gt;
&lt;p&gt;이 값은 수열 &lt;code&gt;a1, b1, a2, b2, ..., aN, bN&lt;&#x2F;code&gt;의 2l번째부터 2r+1번째까지의 수 중
서로 다른 수의 개수와 같습니다.
&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;14897&quot;&gt;BOJ 14897 서로 다른 수와 쿼리 1&lt;&#x2F;a&gt;의
풀이를 그대로 쓰면 됩니다. Mo’s algorithm 말고 오프라인 + 펜윅 트리를 권장합니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;14898&quot;&gt;BOJ14898 서로 다른 수와 쿼리 2&lt;&#x2F;a&gt;의 풀이인
온라인 + 머지 소트 트리를 써도 시간 내에 돌아갑니다.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Persistent Data Structures</title>
        <published>2021-09-04T00:00:00+00:00</published>
        <updated>2021-09-04T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              jh05013
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://jh05013.github.io/blog/persistent/"/>
        <id>https://jh05013.github.io/blog/persistent/</id>
        
        <content type="html" xml:base="https://jh05013.github.io/blog/persistent/">&lt;h1 id=&quot;persistent-introduction&quot;&gt;Persistent Introduction&lt;&#x2F;h1&gt;
&lt;p&gt;과거의 상태를 보존하는 자료구조를 &lt;strong&gt;persistent data structure&lt;&#x2F;strong&gt;라고 합니다.
예를 들어, persistent array는 과거의 배열의 상태를 담고 있는 “버전“을 갖고 있습니다.
여기에 “버전 $x$에서 $i$번째 원소를 $d$로 바꿔서 버전 $y$를 만들어라”,
또는 “버전 $x$에서 $i$번째 원소의 값을 반환해라” 등의 연산을 적용할 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;Persistent segment tree(PST)에 대한 자료는 인터넷에서 많이 찾아볼 수 있습니다.
하지만 persistence라는 개념은 segment tree에만 적용되는 것이 아닙니다.
PST는 persistence를 지원하는 일반적인 방법을 segment tree에 적용한 것일 뿐,
segment tree만을 위한 특별한 아이디어를 적용해서 만든 것이 아닙니다.&lt;&#x2F;p&gt;
&lt;p&gt;이 글에서는 수많은 자료구조를
&lt;strong&gt;기계적이고 간단한 방법을 통해 persistent data structure로 바꿀 수 있다&lt;&#x2F;strong&gt;는
것을 보이고자 합니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;persistent-stack&quot;&gt;Persistent Stack&lt;&#x2F;h1&gt;
&lt;p&gt;Linked list로 구현한 평범한 스택을 생각해 봅시다.
각각의 노드에는 고유의 값이 쓰여 있고, 다른 노드를 가리키는 포인터를 갖고 있습니다.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; class=&quot;language-cpp z-code&quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-storage z-type z-c++&quot;&gt;struct&lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-struct z-c++&quot;&gt;Node&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-storage z-type z-c&quot;&gt;int&lt;&#x2F;span&gt; v&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;	Node &lt;span class=&quot;z-keyword z-operator z-c++&quot;&gt;*&lt;&#x2F;span&gt;nxt&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;	&lt;span class=&quot;z-meta z-method z-constructor z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-function z-constructor z-c++&quot;&gt;Node&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-storage z-type z-c&quot;&gt;int&lt;&#x2F;span&gt; &lt;span class=&quot;z-variable z-parameter z-c++&quot;&gt;V&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; Node &lt;span class=&quot;z-keyword z-operator z-c&quot;&gt;*&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-parameter z-c++&quot;&gt;N&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-constructor z-initializer-list z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-separator z-initializer-list z-c++&quot;&gt;:&lt;&#x2F;span&gt; &lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;v&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;V&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; &lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;nxt&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;N&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-storage z-type z-c++&quot;&gt;struct&lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-struct z-c++&quot;&gt;Stack&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    Node &lt;span class=&quot;z-keyword z-operator z-c++&quot;&gt;*&lt;&#x2F;span&gt;head &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-constant z-language z-c&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;	
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;	&lt;span class=&quot;z-storage z-type z-c&quot;&gt;void&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-function z-c++&quot;&gt;push&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-storage z-type z-c&quot;&gt;int&lt;&#x2F;span&gt; &lt;span class=&quot;z-variable z-parameter z-c++&quot;&gt;v&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;	    head &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;new&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;Node&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;v&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; head&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;	&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;	
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;	&lt;span class=&quot;z-storage z-type z-c&quot;&gt;int&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-function z-c++&quot;&gt;top&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;	    &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-support z-function z-C99 z-c&quot;&gt;assert&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;head&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;		&lt;span class=&quot;z-keyword z-control z-flow z-return z-c++&quot;&gt;return&lt;&#x2F;span&gt; head&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;v&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;	&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;	
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;	&lt;span class=&quot;z-storage z-type z-c&quot;&gt;void&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-function z-c++&quot;&gt;pop&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;	    &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-support z-function z-C99 z-c&quot;&gt;assert&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;head&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;		head &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; head&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;nxt&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;	&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;일반적인 스택에서는 push나 pop을 하면 머리 노드가 바뀌고,
기존의 머리 노드에 대한 정보는 사라집니다.
이 정보를 버리지 말고, $i$번째 연산을 하기 직전의 머리 노드 $S_i$를 모두 저장해 봅시다.
그러면 아래처럼 같은 $S_2$에 다른 원소를 push하여 $S_3$와 $S_4$를 만들 수도 있고,
이전 버전인 $S_1$의 맨 앞 원소가 얼마인지도 알 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;stack1.png&quot; alt=&quot;Persistent stack with node 1 labeled S1 and S7; node 2 labeled S2, S5 and S6, and pointing to node 1; node 3 labeled S3 and pointing to node 2; node 4 labeled S4 and pointing to node 2.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; class=&quot;language-cpp z-code&quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-storage z-type z-c++&quot;&gt;struct&lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-struct z-c++&quot;&gt;Node&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-storage z-type z-c&quot;&gt;int&lt;&#x2F;span&gt; v&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    Node &lt;span class=&quot;z-keyword z-operator z-c++&quot;&gt;*&lt;&#x2F;span&gt;nxt&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-meta z-method z-constructor z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-function z-constructor z-c++&quot;&gt;Node&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-storage z-type z-c&quot;&gt;int&lt;&#x2F;span&gt; &lt;span class=&quot;z-variable z-parameter z-c++&quot;&gt;V&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; Node &lt;span class=&quot;z-keyword z-operator z-c&quot;&gt;*&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-parameter z-c++&quot;&gt;N&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-constructor z-initializer-list z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-separator z-initializer-list z-c++&quot;&gt;:&lt;&#x2F;span&gt; &lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;v&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;V&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; &lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;nxt&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;N&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-storage z-type z-c++&quot;&gt;struct&lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-struct z-c++&quot;&gt;Stack&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    Node &lt;span class=&quot;z-keyword z-operator z-c++&quot;&gt;*&lt;&#x2F;span&gt;head&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-meta z-method z-constructor z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-function z-constructor z-c++&quot;&gt;Stack&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-constructor z-initializer-list z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-separator z-initializer-list z-c++&quot;&gt;:&lt;&#x2F;span&gt; &lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;head&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-constant z-language z-c&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-meta z-method z-constructor z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-function z-constructor z-c++&quot;&gt;Stack&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;Node &lt;span class=&quot;z-keyword z-operator z-c&quot;&gt;*&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-parameter z-c++&quot;&gt;N&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-constructor z-initializer-list z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-separator z-initializer-list z-c++&quot;&gt;:&lt;&#x2F;span&gt; &lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;head&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;N&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    Stack &lt;span class=&quot;z-keyword z-operator z-c++&quot;&gt;*&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-function z-c++&quot;&gt;push&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-storage z-type z-c&quot;&gt;int&lt;&#x2F;span&gt; &lt;span class=&quot;z-variable z-parameter z-c++&quot;&gt;v&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        &lt;span class=&quot;z-keyword z-control z-flow z-return z-c++&quot;&gt;return&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;new&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;Stack&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;new&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;Node&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;v&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; head&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-storage z-type z-c&quot;&gt;int&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-function z-c++&quot;&gt;top&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-support z-function z-C99 z-c&quot;&gt;assert&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;head&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        &lt;span class=&quot;z-keyword z-control z-flow z-return z-c++&quot;&gt;return&lt;&#x2F;span&gt; head&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;v&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    Stack &lt;span class=&quot;z-keyword z-operator z-c++&quot;&gt;*&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-function z-c++&quot;&gt;pop&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-support z-function z-C99 z-c&quot;&gt;assert&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;head&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        &lt;span class=&quot;z-keyword z-control z-flow z-return z-c++&quot;&gt;return&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;new&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;Stack&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;head&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;nxt&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-storage z-type z-c&quot;&gt;int&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-toc-list z-full-identifier z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-function z-c++&quot;&gt;main&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;	Stack &lt;span class=&quot;z-keyword z-operator z-c&quot;&gt;*&lt;&#x2F;span&gt;S &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;new&lt;&#x2F;span&gt; Stack&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    Stack &lt;span class=&quot;z-keyword z-operator z-c&quot;&gt;*&lt;&#x2F;span&gt;S1 &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; S&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;push&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-constant z-numeric z-integer z-decimal z-c++&quot;&gt;1&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    Stack &lt;span class=&quot;z-keyword z-operator z-c&quot;&gt;*&lt;&#x2F;span&gt;S2 &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; S1&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;push&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-constant z-numeric z-integer z-decimal z-c++&quot;&gt;2&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    Stack &lt;span class=&quot;z-keyword z-operator z-c&quot;&gt;*&lt;&#x2F;span&gt;S3 &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; S2&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;push&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-constant z-numeric z-integer z-decimal z-c++&quot;&gt;3&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    cout &lt;span class=&quot;z-keyword z-operator z-arithmetic z-c&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt; S2&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;top&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;         &lt;span class=&quot;z-comment z-line z-double-slash z-c&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-c&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; 2
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    Stack &lt;span class=&quot;z-keyword z-operator z-c&quot;&gt;*&lt;&#x2F;span&gt;S4 &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; S2&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;push&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-constant z-numeric z-integer z-decimal z-c++&quot;&gt;4&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    cout &lt;span class=&quot;z-keyword z-operator z-arithmetic z-c&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt; S3&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;top&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;         &lt;span class=&quot;z-comment z-line z-double-slash z-c&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-c&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; 3
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    cout &lt;span class=&quot;z-keyword z-operator z-arithmetic z-c&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt; S4&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;top&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;         &lt;span class=&quot;z-comment z-line z-double-slash z-c&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-c&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; 4
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    Stack &lt;span class=&quot;z-keyword z-operator z-c&quot;&gt;*&lt;&#x2F;span&gt;S5 &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; S4&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    cout &lt;span class=&quot;z-keyword z-operator z-arithmetic z-c&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt; S5&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;top&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;         &lt;span class=&quot;z-comment z-line z-double-slash z-c&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-c&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; 2
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    Stack &lt;span class=&quot;z-keyword z-operator z-c&quot;&gt;*&lt;&#x2F;span&gt;S6 &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; S3&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    cout &lt;span class=&quot;z-keyword z-operator z-arithmetic z-c&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt; S2&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;top&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;         &lt;span class=&quot;z-comment z-line z-double-slash z-c&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-c&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; 2
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    Stack &lt;span class=&quot;z-keyword z-operator z-c&quot;&gt;*&lt;&#x2F;span&gt;S7 &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; S6&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    cout &lt;span class=&quot;z-keyword z-operator z-arithmetic z-c&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt; S7&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;top&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;         &lt;span class=&quot;z-comment z-line z-double-slash z-c&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-c&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; 1
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;만약 “머리의 값을 $v$로 바꾼다“라는 연산을 지원하면 어떻게 될까요?
기존의 스택이라면 그냥 바꾸면 되겠지만,
persistent stack에서 그러면 이전 버전이 보존되지 않아서 안 됩니다.
그 대신 머리를 그대로 복사한 다음, 그 복사본의 값을 $v$로 바꿔야 합니다.
포인터는 복사한 그대로 남아있으므로 두 번째 노드를 가리키고 있을 것입니다.
그리고 스택의 버전이 바뀌었으므로 이 연산에서 새로운 머리를 반환해줍시다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;assets&#x2F;images&#x2F;persistent&#x2F;stack2.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; class=&quot;language-cpp z-code&quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-storage z-type z-c++&quot;&gt;struct&lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-struct z-c++&quot;&gt;Node&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-comment z-line z-double-slash z-c&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-c&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; ... (중략) ...
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    Node &lt;span class=&quot;z-keyword z-operator z-c++&quot;&gt;*&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-function z-c++&quot;&gt;copy&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        &lt;span class=&quot;z-keyword z-control z-flow z-return z-c++&quot;&gt;return&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;new&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;Node&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;v&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; nxt&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-storage z-type z-c++&quot;&gt;struct&lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-struct z-c++&quot;&gt;Stack&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-comment z-line z-double-slash z-c&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-c&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; ... (중략) ...
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    Stack &lt;span class=&quot;z-keyword z-operator z-c++&quot;&gt;*&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-function z-c++&quot;&gt;change_head&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-storage z-type z-c&quot;&gt;int&lt;&#x2F;span&gt; &lt;span class=&quot;z-variable z-parameter z-c++&quot;&gt;v&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-support z-function z-C99 z-c&quot;&gt;assert&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;head&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        Stack &lt;span class=&quot;z-keyword z-operator z-c&quot;&gt;*&lt;&#x2F;span&gt;s &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;new&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;Stack&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;head&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;copy&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        s&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;head&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;v&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; v&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        &lt;span class=&quot;z-keyword z-control z-flow z-return z-c++&quot;&gt;return&lt;&#x2F;span&gt; s&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;그 다음으로, “두 번째 노드의 값을 $v$로 바꾼다“라는 연산을 지원하면 어떻게 될까요?
마찬가지로 두 번째 노드를 복사한 다음, 그 복사본의 값을 $v$로 바꾸면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;그런데 이 연산에서 반환해줄 새로운 머리가 없습니다.
그렇다고 기존의 머리를 반환하면 안 됩니다. 그 머리는 이전 버전에 해당되고,
새로운 노드가 아닌 과거의 노드를 가리키고 있기 때문입니다.
따라서 머리도 새로 복사해 준 다음, 새 머리의 포인터도 바꿔주고 그 머리를 반환해야 합니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;assets&#x2F;images&#x2F;persistent&#x2F;stack3.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; class=&quot;language-cpp z-code&quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;    Stack &lt;span class=&quot;z-keyword z-operator z-c++&quot;&gt;*&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-toc-list z-full-identifier z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-function z-c++&quot;&gt;change_second&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-storage z-type z-c&quot;&gt;int&lt;&#x2F;span&gt; &lt;span class=&quot;z-variable z-parameter z-c++&quot;&gt;v&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-support z-function z-C99 z-c&quot;&gt;assert&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;head &lt;span class=&quot;z-keyword z-operator z-arithmetic z-c&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt; head&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;nxt&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        Node &lt;span class=&quot;z-keyword z-operator z-c&quot;&gt;*&lt;&#x2F;span&gt;n2 &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; head&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;nxt&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;copy&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        n2&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;v&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; v&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        Node &lt;span class=&quot;z-keyword z-operator z-c&quot;&gt;*&lt;&#x2F;span&gt;n1 &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; head&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;copy&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        n1&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;nxt&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; n2&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        &lt;span class=&quot;z-keyword z-control z-flow z-return z-c++&quot;&gt;return&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;new&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;Stack&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;n1&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;마찬가지로, “$k$번째 노드의 값을 $v$로 바꾼다“라는 연산을 지원하려면
머리부터 $k$번째 노드까지 모두 복사해 주면 됩니다. 코드는 생략합니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;persistent-data-structures&quot;&gt;Persistent Data Structures&lt;&#x2F;h1&gt;
&lt;p&gt;위의 예시를 일반화해 봅시다. 다음 조건이 성립하는 자료구조를 생각합시다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;각 노드는 &lt;strong&gt;값&lt;&#x2F;strong&gt;과 &lt;strong&gt;포인터&lt;&#x2F;strong&gt; 필드로 이루어져 있습니다. (위의 &lt;code&gt;Node::v&lt;&#x2F;code&gt;와 &lt;code&gt;Node::nxt&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;자료구조 자체도 &lt;strong&gt;값&lt;&#x2F;strong&gt;과 &lt;strong&gt;포인터&lt;&#x2F;strong&gt; 필드로 이루어져 있습니다. (위의 &lt;code&gt;Stack::head&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;그러면 이 자료구조에서 일어나는 연산을 persistent하게 수행할 수 있습니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;연산이 노드 몇 개의 필드를 수정할 텐데, 그렇게 수정되는 노드의 집합을 $N$이라고 합시다.&lt;&#x2F;li&gt;
&lt;li&gt;포인터를 통해 $N$의 노드 중 적어도 하나에 도달할 수 있는 노드의 집합을 $S$라고 합시다.&lt;&#x2F;li&gt;
&lt;li&gt;$S$의 모든 노드를 복사하고, 자료구조 자체도 복사합니다. 노드 $x$를 복사한 것을 $x’$이라고 합시다.&lt;&#x2F;li&gt;
&lt;li&gt;복사된 모든 노드에 대해, 포인터가 $S$ 중 한 노드인 $y$를 가리키면 $y’$으로 바꿉니다.
복사된 자료구조에 대해서도, 포인터가 $S$ 중 한 노드를 가리키면 복사본으로 바꿉니다.&lt;&#x2F;li&gt;
&lt;li&gt;복사된 자료구조에 대해 기존의 연산을 적용합니다.&lt;&#x2F;li&gt;
&lt;li&gt;복사된 자료구조를 반환합니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;특히 포인터들이 트리의 형태를 이루고 있고 $N$의 크기가 1이라면, $S$는 하나의 경로를 이룰 것입니다.
그래서 이 기법을 &lt;strong&gt;path copying&lt;&#x2F;strong&gt;이라고 부릅니다.&lt;&#x2F;p&gt;
&lt;p&gt;물론 정확히 이 순서로 복사, 수정할 필요는 없고, 순서만 잘 맞으면 됩니다.
예를 들어 특정 포인터 필드를 복사본으로 바꾸려면 먼저 그 복사본을 만들어야겠죠.
시간 복잡도는 복사된 노드의 크기(필드의 개수)의 합에 비례합니다.&lt;&#x2F;p&gt;
&lt;p&gt;위의 &lt;code&gt;change_second&lt;&#x2F;code&gt;를 예로 들어보면,&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$N$은 두 번째 노드 하나로 이루어져 있습니다.&lt;&#x2F;li&gt;
&lt;li&gt;$S$는 첫 번째와 두 번째 노드로 이루어져 있습니다.&lt;&#x2F;li&gt;
&lt;li&gt;$O(1)$ 크기의 노드 $O(1)$개를 복사했으므로, 시간 복잡도는 $O(1)$입니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;persistent-tree&quot;&gt;Persistent Tree&lt;&#x2F;h1&gt;
&lt;p&gt;트리를 persistent하게 바꿔봅시다. 만약 아래 그림에서 파란색 노드를 수정하려고 한다면,
복사해야 하는 노드는 파란색과 빨간색 노드입니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;assets&#x2F;images&#x2F;persistent&#x2F;tree.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;재귀 호출을 하면서 한 단계씩 내려가고,
재귀 호출이 반환한 복사본을 현재 노드의 포인터 필드에 넣으면 구현하기 쉽습니다.
아래 코드에 이 방식으로 binary search tree에 값을 추가하는 연산을 구현하였습니다.
시간 복잡도는 트리의 높이에 비례합니다.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; class=&quot;language-cpp z-code&quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-storage z-type z-c++&quot;&gt;struct&lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-struct z-c++&quot;&gt;Node&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-storage z-type z-c&quot;&gt;int&lt;&#x2F;span&gt; v&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    Node &lt;span class=&quot;z-keyword z-operator z-c++&quot;&gt;*&lt;&#x2F;span&gt;l&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-operator z-c&quot;&gt;*&lt;&#x2F;span&gt;r&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-meta z-method z-constructor z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-function z-constructor z-c++&quot;&gt;Node&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-storage z-type z-c&quot;&gt;int&lt;&#x2F;span&gt; &lt;span class=&quot;z-variable z-parameter z-c++&quot;&gt;V&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; Node &lt;span class=&quot;z-keyword z-operator z-c&quot;&gt;*&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-parameter z-c++&quot;&gt;L&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; Node &lt;span class=&quot;z-keyword z-operator z-c&quot;&gt;*&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-parameter z-c++&quot;&gt;R&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-constructor z-initializer-list z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-separator z-initializer-list z-c++&quot;&gt;:&lt;&#x2F;span&gt; &lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;v&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;V&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; &lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;l&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;L&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; &lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;r&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;R&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    Node &lt;span class=&quot;z-keyword z-operator z-c++&quot;&gt;*&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-function z-c++&quot;&gt;copy&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        &lt;span class=&quot;z-keyword z-control z-flow z-return z-c++&quot;&gt;return&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;new&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;Node&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;v&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; l&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; r&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    Node &lt;span class=&quot;z-keyword z-operator z-c++&quot;&gt;*&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-function z-c++&quot;&gt;insert&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-storage z-type z-c&quot;&gt;int&lt;&#x2F;span&gt; &lt;span class=&quot;z-variable z-parameter z-c++&quot;&gt;k&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        Node &lt;span class=&quot;z-keyword z-operator z-c&quot;&gt;*&lt;&#x2F;span&gt;n &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;copy&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;if&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;k &lt;span class=&quot;z-keyword z-operator z-comparison z-c&quot;&gt;&amp;lt;&lt;&#x2F;span&gt; v&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;            &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;if&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-keyword z-operator z-arithmetic z-c&quot;&gt;!&lt;&#x2F;span&gt;n&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;l&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; n&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;l&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;new&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;Node&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;k&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; &lt;span class=&quot;z-constant z-language z-c&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; &lt;span class=&quot;z-constant z-language z-c&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;            &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;else&lt;&#x2F;span&gt; n&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;l&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; n&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;l&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;k&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        &lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;else&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt; &lt;span class=&quot;z-comment z-line z-double-slash z-c&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-c&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; k &amp;gt; v
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;            &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;if&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-keyword z-operator z-arithmetic z-c&quot;&gt;!&lt;&#x2F;span&gt;n&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;r&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; n&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;r&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;new&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;Node&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;k&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; &lt;span class=&quot;z-constant z-language z-c&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; &lt;span class=&quot;z-constant z-language z-c&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;            &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;else&lt;&#x2F;span&gt; n&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;r&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; n&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-other z-readwrite z-member z-c++&quot;&gt;r&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;k&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        &lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        &lt;span class=&quot;z-keyword z-control z-flow z-return z-c++&quot;&gt;return&lt;&#x2F;span&gt; n&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-storage z-type z-c&quot;&gt;bool&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-function z-c++&quot;&gt;search&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-storage z-type z-c&quot;&gt;int&lt;&#x2F;span&gt; &lt;span class=&quot;z-variable z-parameter z-c++&quot;&gt;k&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;if&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;k &lt;span class=&quot;z-keyword z-operator z-comparison z-c&quot;&gt;==&lt;&#x2F;span&gt; v&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-control z-flow z-return z-c++&quot;&gt;return&lt;&#x2F;span&gt; &lt;span class=&quot;z-constant z-language z-c&quot;&gt;true&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;if&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;k &lt;span class=&quot;z-keyword z-operator z-comparison z-c&quot;&gt;&amp;lt;&lt;&#x2F;span&gt; v &lt;span class=&quot;z-keyword z-operator z-arithmetic z-c&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt; l&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-control z-flow z-return z-c++&quot;&gt;return&lt;&#x2F;span&gt; l&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;search&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;k&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;if&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;k &lt;span class=&quot;z-keyword z-operator z-comparison z-c&quot;&gt;&amp;gt;&lt;&#x2F;span&gt; v &lt;span class=&quot;z-keyword z-operator z-arithmetic z-c&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt; r&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-control z-flow z-return z-c++&quot;&gt;return&lt;&#x2F;span&gt; r&lt;span class=&quot;z-punctuation z-accessor z-arrow z-c++&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;search&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;k&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;        &lt;span class=&quot;z-keyword z-control z-flow z-return z-c++&quot;&gt;return&lt;&#x2F;span&gt; &lt;span class=&quot;z-constant z-language z-c&quot;&gt;false&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;persistent-segment-tree&quot;&gt;Persistent Segment Tree&lt;&#x2F;h1&gt;
&lt;p&gt;세그먼트 트리는 balanced binary tree의 형태를 띠고 있습니다.
그래서 persistent tree를 조금만 변형하면 persistent segment tree가 됩니다.
다음 두 가지만 추가하면 됩니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;각 노드마다 그 서브트리의 크기를 저장합니다.&lt;&#x2F;li&gt;
&lt;li&gt;재귀를 사용하여 점 업데이트 연산을 구현합니다.
위의 persistent BST에서 봤던 대로, 왼쪽 또는 오른쪽 서브트리에 재귀 호출을 하고,
포인터를 그 호출이 반환한 복사본으로 바꿔치면 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;재귀를 사용하여 구간 쿼리 연산을 구현합니다.
각 서브트리의 크기를 알고 있으므로 노드, $l$, $r$만 피연산자로 사용하면 됩니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;source&#x2F;share&#x2F;22a4c19521af496895666c32ee0b6206&quot;&gt;C++ 구현&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;source&#x2F;share&#x2F;124093e2ff72441d8288957b2db321cd&quot;&gt;Python 구현&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;persistent-array&quot;&gt;Persistent Array&lt;&#x2F;h1&gt;
&lt;p&gt;우리가 흔히 쓰는 형태의 배열을 그대로 persistent하게 만드는 건 의미가 없습니다.
그냥 배열을 통째로 복사하는 거나 마찬가지니까요.
하지만 persistent array를 다른 방법으로 구현할 수는 있습니다.
그냥 persistent segment tree와 똑같이 구현하되, 구간 합 쿼리 대신 점 쿼리를 구현해 주고,
업데이트 후에 값을 합체하는 과정을 없애면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;각 연산의 시간 복잡도는 $O(\log N)$입니다.&lt;&#x2F;p&gt;
&lt;p&gt;꼭 이진 트리일 필요는 없고, $K$진 트리를 만들어서 깊이를 줄이는 대신 노드의 크기를 늘릴 수도 있습니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;persistent-queue&quot;&gt;Persistent Queue&lt;&#x2F;h1&gt;
&lt;p&gt;Linked list 형태의 큐를 그대로 persistent하게 만드는 건 의미가 없습니다.
$S$가 노드 전체의 집합이 되어 버리기 때문에, 큐를 통째로 복사하는 거나 마찬가지니까요.
하지만 array 형태의 큐도 있죠? Array는 persistent하게 만들 수 있음을 위에서 보았으니,
이걸 그대로 사용해서 persistent queue를 만들 수 있습니다.
마찬가지로 각 연산의 시간 복잡도는 $O(\log N)$입니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;judge.yosupo.jp&#x2F;submission&#x2F;58767&quot;&gt;Python 구현&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;persistent-union-find&quot;&gt;Persistent Union-find&lt;&#x2F;h1&gt;
&lt;p&gt;Union-find를 배열 두 개로 구현할 수 있으므로,
persistent union-find는 persistent array 두 개로 구현할 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;주의할 점은 &lt;strong&gt;path compression을 쓰면 안 된다&lt;&#x2F;strong&gt;는 것입니다.
왜냐하면 persistence를 추가하면 amortized analysis가 깨지기 때문입니다.
Amortized 시간 복잡도는 &lt;strong&gt;같은 자료구조에서 연이어서 연산&lt;&#x2F;strong&gt;을 했을 때의 평균 시간 복잡도로,
어떤 연산에서 $O(N)$이 걸리더라도 그 이후의 연산에서 계속 $O(1)$이 걸린다면
amortized 시간 복잡도는 더 낮아질 수 있습니다.
하지만 persistent한 자료구조에서는 $O(N)$이 걸리는 바로 그 연산을 반복적으로
수행할 수 있기 때문에, amortization이 더 이상 의미가 없습니다.&lt;&#x2F;p&gt;
&lt;p&gt;따라서 &lt;strong&gt;union by rank&lt;&#x2F;strong&gt;를 써야 하고,
이때 $O(\log N)$ 시간 복잡도의 persistent array 연산을 $O(\log N)$번 수행하므로
시간 복잡도는 $O(\log^2 N)$이 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;judge.yosupo.jp&#x2F;submission&#x2F;58752&quot;&gt;Python 구현&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;persistent-next-steps&quot;&gt;Persistent Next Steps&lt;&#x2F;h1&gt;
&lt;p&gt;한편, $S$의 크기에 관계 없이 $O(\log N)$ 시간에 노드를 업데이트할 수 있으며, in-degree가 $O(1)$이라는 가정 하에 $O(1)$ 시간에도 노드를 업데이트할 수 있음이 알려져 있습니다. 관심 있으신 분은 다음 논문을 참조하세요: James R. Driscoll, Neil Sarnak, Daniel D. Sleator, Robert E. Tarjan, &lt;em&gt;Making data structures persistent&lt;&#x2F;em&gt;, Journal of Computer and System Sciences, Volume 38, Issue 1, 1989, Pages 86-124.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>BOJ 20846 수열과 쿼리 40</title>
        <published>2021-02-04T00:00:00+00:00</published>
        <updated>2021-02-04T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              jh05013
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://jh05013.github.io/blog/boj20846/"/>
        <id>https://jh05013.github.io/blog/boj20846/</id>
        
        <content type="html" xml:base="https://jh05013.github.io/blog/boj20846/">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;acmicpc.net&#x2F;problem&#x2F;20846&quot;&gt;https:&#x2F;&#x2F;acmicpc.net&#x2F;problem&#x2F;20846&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;ige-museun-kweoriya&quot;&gt;이게 무슨 쿼리야?&lt;&#x2F;h1&gt;
&lt;p&gt;각각의 쿼리는 수열 B의 접미사 배열을 만들었을 때 K번째 원소가 무엇인지 묻는 쿼리로 생각할 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;수열 A의 접미사 배열을 만들고, 쿼리를 (d mod M)에 대한 오름차순으로 정렬합니다.
이제 d를 하나씩 올려 가는데, 그럴 때마다 수열 A의 모든 원소를 하나씩 올린다고 생각하지 말고,
A에 있는 원소 중 M-d가 “새로운 최솟값“이 된다고 합시다.
이렇게 하면 원소가 바뀌는 횟수는 최대 N회입니다.
이제 관건은 접미사 배열을 어떻게 동적으로 관리하는지입니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;jaryogujo&quot;&gt;자료구조&lt;&#x2F;h1&gt;
&lt;p&gt;정해가 이것일지는 모르겠으나, 저는 접미사 트리로 풀었습니다.&lt;&#x2F;p&gt;
&lt;p&gt;접미사 트리는 여러 강력한 기능을 갖고 있는데, 그중 하나는
트리를 DFS 순회하되 사전순으로 작은 자식부터 차례대로 방문하면
(termination symbol은 -1이라고 합시다), 리프 노드를 방문한 순서가 곧 접미사 배열이 된다는 것입니다.
따라서 수열 A의 접미사 트리를 만들고, 오일러 투어 트릭을 써서 일자로 편 다음,
그걸 동적으로 관리함과 동시에 K번째 리프 노드를 찾을 수 있으면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;이제 원소 M-d가 “새로운 최솟값“이 된다고 합시다.
그러면 모든 노드 p에 대해, label이 M-d로 시작하는 자식 v가 (존재하면) 현재 마지막 자식일 것이고,
이 v가 첫 번째 자식으로 옮겨집니다.
단, label이 termination symbol로 시작하는 자식이 있으면 대신 두 번째 자식으로 옮겨집니다.
오일러 투어 트릭을 생각해 보면 이는 부분배열을 잡아서
v의 서브트리의 크기 만큼 오른쪽으로 시프트하는 것이라고 생각할 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;따라서 다음을 지원하는 자료구조를 사용하면 됩니다.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;접미사 트리의 노드가 주어졌을 때, 이것이 현재 오일러 투어에서 몇 번째에 위치하는지 찾기&lt;&#x2F;li&gt;
&lt;li&gt;부분배열을 오른쪽으로 시프트하기&lt;&#x2F;li&gt;
&lt;li&gt;현재 오일러 투어에서 K번째 리프 노드 찾기&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;jaryogujo-hana-deo&quot;&gt;자료구조 하나 더&lt;&#x2F;h2&gt;
&lt;p&gt;스플레이 트리로 위 셋을 전부 구현할 수 있습니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;1번 연산은 접미사 트리의 노드 v에 대응되는 스플레이 트리의 노드 x를 찾고,
x를 스플레이한 다음 x의 왼쪽 서브트리의 크기를 구하면 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;2번 연산은 부분배열 뒤집기 연산 세 번으로 구현할 수 있습니다.&lt;&#x2F;li&gt;
&lt;li&gt;3번 연산은 스플레이 트리의 각 노드마다
“해당 (스플레이 트리) 노드의 서브트리에 있는 접미사 트리의 리프 노드 개수“를 저장해 두고,
루트에서부터 하나씩 내려가면 됩니다.
단, 그 전에 스플레이 트리가 균형이 잡혀 있음이 보장되어야 O(logN)이 됩니다.
만약 그게 보장이 안 된다면, 스플레이 트리를 만든 직후에 아무 노드나 잡아서 스플레이하는 걸
10,000번 정도 반복하면 됩니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;참고로 제 코드는 10799 바이트입니다.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>제1회 논산 코드 페스티벌 풀이</title>
        <published>2020-04-06T00:00:00+00:00</published>
        <updated>2020-04-06T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              jh05013
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://jh05013.github.io/blog/noncofe/"/>
        <id>https://jh05013.github.io/blog/noncofe/</id>
        
        <content type="html" xml:base="https://jh05013.github.io/blog/noncofe/">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;category&#x2F;detail&#x2F;2206&quot;&gt;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;category&#x2F;detail&#x2F;2206&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;18857-jib-ddeonawa-yeolca-tago&quot;&gt;18857 집 떠나와 열차 타고&lt;&#x2F;h1&gt;
&lt;p&gt;선인장의 block-cut tree를 생각해 봤을 때, 정점 1과 N 사이에 있는 경로만 생각해도 충분합니다.
그런 경로만 생각하면 그래프는 대충 이런 형태가 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;noncofe1.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;이제 1번 정점에서 N번 정점으로 못 가게 하려면, 이 그래프의 BCC 중 하나를 완전히 끊어야 합니다. 완전히 안 끊고 예를 들어 사이클에서 하나의 간선만 제거한다거나 그러면 소용이 없습니다. 따라서, 각각의 BCC를 끊는 비용을 구하고, 그 중 최솟값을 구하면 됩니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;18858-hunryeonsoro-ganeun-nal&quot;&gt;18858 훈련소로 가는 날&lt;&#x2F;h1&gt;
&lt;p&gt;DPu[i][j] = “길이 i, 마지막 정수 j이며, 마지막 두 수가 오름차순인 경우의 수”,
DPd[i][j]는 거의 똑같은데 “오름차순이 아닌 경우의 수“로 두면 O(NM^2)가 나옵니다.
이것만으로 시간 내에 돌아가지만, prefix sum을 적절히 사용하여 O(NM)으로 줄일 수도 있습니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;18859-bumonimgge-keunjeol-hago&quot;&gt;18859 부모님께 큰절 하고&lt;&#x2F;h1&gt;
&lt;p&gt;감소수열과 증가수열을 생각하지 말고,
맨 첫 원소를 공유하는 두 개의 증가수열로 분해한다고 생각해 봅시다.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;맨 첫 원소는 수열의 최솟값이어야 합니다. 그 수를 m이라고 합시다.&lt;&#x2F;li&gt;
&lt;li&gt;한 수열의 공차는 (m 제외 최솟값) - m이어야 합니다. 그 공차를 d라고 합시다. d = 0이면 답은 No입니다.&lt;&#x2F;li&gt;
&lt;li&gt;m+d에서 시작해서 공차가 d인 등차수열을 적절히 제거했을 때, 남은 수들도 등차수열을 이루어야 합니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;3번은 어떻게 할까요? 수들을 정렬하고, 인접한 수들의 차를 모두 계산했을 때,
그중 최솟값과 최댓값이 같아야만 등차수열을 이룰 수 있습니다.
인접한 수의 차를 모두 저장하는 자료구조를 생각해 봅시다.
여기서 수 x를 지우면, 이런 변화가 일어납니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;x 왼쪽과 오른쪽에 있는 수를 L, R이라고 합시다. L이나 R이 없을 수도 있습니다.&lt;&#x2F;li&gt;
&lt;li&gt;L이 있으면, 자료구조에서 L-x가 제거됩니다. R이 있으면, 자료구조에서 x-R이 제거됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;그리고 L과 R이 모두 있으면, 자료구조에 R-L이 추가됩니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;따라서 수를 제거, 추가하고, 최솟값과 최댓값을 받아오는 자료구조를 쓰면 됩니다.
가장 대표적인 것으로 multiset이 있고,
&lt;a href=&quot;https:&#x2F;&#x2F;infossm.github.io&#x2F;blog&#x2F;2020&#x2F;08&#x2F;16&#x2F;heap&#x2F;&quot;&gt;임의의 원소 삭제가 가능한 힙&lt;&#x2F;a&gt;을 만들 수도 있습니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;18860-daemun-baggeul-naseol-ddae&quot;&gt;18860 대문 밖을 나설 때&lt;&#x2F;h1&gt;
&lt;p&gt;특정 펌프가 처음으로 작동을 시작한다고 하면, 전체 과정은 이렇게 생각할 수 있습니다.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;현재 작동 중인 펌프가 포함된 가장 작은 서브트리를 채웁니다.&lt;&#x2F;li&gt;
&lt;li&gt;이제 석유가 넘쳐서 더 큰 서브트리로 흘러 가는데, 이 순간에 가능한 한 많은 펌프를 작동시켜야 합니다.
x만큼의 석유가 넘치면 min(도달 가능한 펌프 개수, x)개의 펌프를 작동시킬 수 있습니다.&lt;&#x2F;li&gt;
&lt;li&gt;그 다음 순간에는 도달 가능한 모든 펌프를 작동시킬 수 있습니다.&lt;&#x2F;li&gt;
&lt;li&gt;1번으로 돌아갑니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;2번과 3번은 O(1)에 구현할 수 있습니다. 가장 시간이 오래 걸리는 부분은 1번인데,
채워야 되는 서브트리의 크기를 미리 DP로 계산해 놓으면 이것도 O(1)에 구현할 수 있습니다.
그리고 이 모든 과정은 O(logN)번 반복되므로,
특정 펌프에서 시작할 때 다 채우는 데 걸리는 시간은 O(logN)만에 계산할 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;모든 펌프에 대해 시간을 계산하면 됩니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;18861-gaseum-soge-mueosinga&quot;&gt;18861 가슴 속에 무엇인가&lt;&#x2F;h1&gt;
&lt;p&gt;만약 그래프가 포레스트임이 보장된다면, 간선 추가, 삭제, 경로 최솟값을 구하는 쿼리가 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;포레스트가 아니라면 어떨까요? 트리에 간선 하나를 추가해 봅시다.
그러면 사이클이 정확히 하나 만들어집니다. 그 사이클의 간선 중 가중치가 가장 작은 것을 봅시다.
(여러 개면 아무거나 선택합니다.) 그러면 그 간선은 더 이상 쓸모가 없습니다.
3번 쿼리의 경우 그 간선을 쓰는 대신 사이클 반대 방향으로 돌아서 가면 되며,
2번 쿼리의 경우 사이클의 다른 간선들이 제거되기 전에 자신이 먼저 제거되기 때문입니다.&lt;&#x2F;p&gt;
&lt;p&gt;따라서 새로운 간선을 추가하기 전에, 가중치가 가장 작은 그 간선을 먼저 제거하면,
결과에 영향을 주지 않으면서 포레스트를 유지시킬 수 있습니다. 결국 이것도 경로 최솟값 쿼리가 됩니다.
이 모든 것은 링크-컷 트리로 구현할 수 있습니다. 신난다!&lt;&#x2F;p&gt;
&lt;h1 id=&quot;18862-aswiumi-namjiman&quot;&gt;18862 아쉬움이 남지만&lt;&#x2F;h1&gt;
&lt;p&gt;EDIT(2022년):
음… 사실 이 글을 네이버 블로그에 2년 전에 썼는데요, 이거랑 그 다음 두 문제는 풀이를 안 썼습니다.
이 문제는 풀이가 정확히 기억나지 않아서 쓰려면 다시 풀어야 합니다…&lt;&#x2F;p&gt;
&lt;h1 id=&quot;18863-pul-han-pogi-cingu-eolgul&quot;&gt;18863 풀 한 포기 친구 얼굴&lt;&#x2F;h1&gt;
&lt;p&gt;격자의 각 칸마다 (물론 도착점은 제외하고) 어떤 명령을 내릴 수 있는지 판별하면
정점 NM개, 간선 10NM개 이하의 그래프가 만들어집니다.
문제는 출발점에서 유한 개의 간선을 타고 도착점으로 오는 방법의 수를 구하는 것입니다.&lt;&#x2F;p&gt;
&lt;p&gt;우선 특정 칸에서 특정 명령을 내릴 수 있는지 판별합시다.
각 명령을 전처리하면서 “이 명령을 수행하는 동안,
명령을 시작한 위치를 기준으로 이동하는 최소&#x2F;최대 x&#x2F;y좌표“를 구하면,
특정 칸에서 이 명령을 내릴 때 격자를 벗어나는 경우가 존재하는지 O(1) 만에 판별할 수 있습니다.
예를 들어 명령이 &lt;code&gt;EWN&lt;&#x2F;code&gt;이라면 최소&#x2F;최대 x좌표는 0과 1, 최소&#x2F;최대 y좌표는 -1과 0입니다.&lt;&#x2F;p&gt;
&lt;p&gt;이제 그래프가 주어졌을 때, (1) 시작점에서 도달할 수 있으면서
(2) 거기서부터 도착점으로 갈 수 있는 칸을 구합니다.
이 두 조건 중 하나라도 만족하지 않는 칸은 욱제가 아예 도달할 수 없거나,
욱제를 (N, M)으로 못 보내서 욱제의 훈련을 끝낼 수 없습니다.
(1)은 그대로 그래프 순회를 돌리면 구할 수 있고,
(2)는 모든 간선의 방향을 뒤집은 다음 도착점에서 그래프 순회를 돌리면 구할 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;이렇게 정점을 쳐낸 후, 그래프에 사이클이 남아있으면 답은 -1이고,
아니면 위상정렬 후 통상적인 DP로 답을 구할 수 있습니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;18864-modeun-geosi-saerobda&quot;&gt;18864 모든 것이 새롭다&lt;&#x2F;h1&gt;
&lt;p&gt;예제 1은 불가능한 퍼즐로 알려진
&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;15_puzzle#Solvability&quot;&gt;매우 유명한 퍼즐&lt;&#x2F;a&gt;입니다. 왜 불가능할까요?&lt;&#x2F;p&gt;
&lt;p&gt;퍼즐의 각 조각마다 그 조각이 (조각이 없을 경우, 빈 칸이) 원래 어디로 와야 되는지를 계산하면,
퍼즐 전체를 하나의 순열로 나타낼 수 있습니다.
조각 하나를 움직이는 것은 조각과 빈 칸을 서로 바꾸는 것이므로
순열에 또 다른 순열 (a b)를 곱하는 것과 같습니다.
(a b)는 홀순열이므로, 조각 하나를 움직일 때마다 순열의 홀짝성이 바뀝니다.
그런데 빈 칸이 맨 처음 상태와 마지막 상태에서 위치가 같기 때문에 조각은 짝수 번 움직여야 하고,
따라서 맨 처음 상태와 마지막 상태는 홀짝성이 같습니다.
그런데 실제로는 맨 처음 상태가 홀순열이고, 마지막 상태가 짝순열이기 때문에 이 퍼즐은 맞출 수 없습니다.&lt;&#x2F;p&gt;
&lt;p&gt;이를 일반화하면 문제를 풀 수 있습니다.
일단 여섯 차원 중 다섯 개의 크기가 1이면 예외처리를 해야 합니다.&lt;&#x2F;p&gt;
&lt;p&gt;이제 맨 처음 상태의 홀짝성을 확인합니다.
마지막 상태는 무조건 짝순열입니다.
따라서 (맨 처음 상태가 홀순열)과 (빈 칸이 홀수 번 움직여야 함)이 동치가 아니면 이 퍼즐은 맞출 수 없습니다.
반대로 동치이면 이 퍼즐은 맞출 수 있는데, 이건 증명하기 조금 까다롭습니다.
한번에 한 레이어씩 맞추면 되던 걸로 기억합니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;18865-ije-dasi-sijagida&quot;&gt;18865  이제 다시 시작이다&lt;&#x2F;h1&gt;
&lt;p&gt;한 스피커에 대해, 볼륨을 점차 증가시키면 훈련소 내부에서 소리가 들리는 영역이 다음과 같이 변합니다.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;a초까지는 들리는 영역이 없습니다.&lt;&#x2F;li&gt;
&lt;li&gt;a초부터 b초까지는 한 변의 길이가 V-a인 직각이등변삼각형이 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;b초부터 c초까지는 한 변의 길이가 V-a인 직각이등변삼각형에서, 위쪽 또는 오른쪽 일부분을 제거한 형태가 됩니다. 단, 둘 중 한 부분만 제거됩니다. b=c일 수도 있습니다.&lt;&#x2F;li&gt;
&lt;li&gt;c초부터 d초까지는 위쪽과 오른쪽을 둘 다 제거한 형태가 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;d초부터는 직사각형이 되고 영역이 더 이상 변하지 않습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;noncofe2.png&quot; alt=&quot;.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;이제 영역의 넓이가 어떻게 변하는지 생각해 봅시다.
1번의 경우 따로 해야 될 일이 없습니다. 2번의 경우, a초부터 시작하는 이차함수를 만들 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;3번의 경우, V-a 크기의 직각이등변삼각형의 넓이에서 제거된 부분의 넓이를 빼면 됩니다.
V-a 삼각형의 넓이는 2번에서 이미 추가되었기 때문에 그대로 쓰면 되고,
제거된 부분은 직각이등변삼각형이므로 이차함수로 나타낼 수 있습니다. 4번도 마찬가지입니다.
5번의 경우 두 “제거된 부분“이 겹친 것이라고 생각할 수 있습니다.
따라서 겹친 부분의 넓이를 다시 더해줘야 합니다.
이 겹친 부분도 직각이등변삼각형이므로 이차함수로 나타낼 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;이걸 구현하려면 이런 자료구조가 필요합니다.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;특정 시간 t부터 정의되는 이차함수를 추가한다.&lt;&#x2F;li&gt;
&lt;li&gt;특정 시간 t에서 이차함수들의 합을 구한다.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;이건 펜윅 트리를 3개 만들어서 풀 수 있습니다.
각 펜윅 트리는 이차함수의 이차항의 계수, 일차항의 계수, 상수항을 각각 저장하면 됩니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;18866-jeolmeun-nalyi-saengiyeo&quot;&gt;18866 젊은 날의 생이여&lt;&#x2F;h1&gt;
&lt;p&gt;1~K년이 젊은 날이 될 수 있는지 판별해 봅시다.&lt;&#x2F;p&gt;
&lt;p&gt;먼저, K년까지의 행복도 중 최솟값은 이후의 행복도 중 최댓값보다 커야 합니다.
그걸 판별하려면 행복도 중 누락된 값을 아예 “없는 데이터“로 취급해도 무방합니다.
어차피 K년까지의 행복도 중 누락된 값은 매우 크게 잡아야 하고,
이후의 행복도 중 누락된 값은 매우 낮게 잡아야 하기 때문입니다.
마찬가지로, K년까지의 피로도 중 최댓값이 이후의 피로도 중 최솟값보다 낮아야 합니다.&lt;&#x2F;p&gt;
&lt;p&gt;따라서 “첫 x년의 최소 행복도”, “첫 x년의 최대 피로도”, “마지막 x년의 최대 행복도”,
“마지막 x년의 최소 피로도“를 모두 구하면 됩니다. DP로 풀 수 있습니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;18867-pyeonji-ggog-haedao&quot;&gt;18867 편지 꼭 해다오&lt;&#x2F;h1&gt;
&lt;p&gt;제한이 많이 널널하기 때문에, 여러 가지 방법으로 풀 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;가장 짧은 답안을 찾고 싶다면 냅색을 풀면 됩니다.
&lt;code&gt;[a-zA-Z0-9]&lt;&#x2F;code&gt;에 있는 글자만 사용할 때는 5글자가 가장 짧습니다.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>펜윅 트리 200% 활용하기</title>
        <published>2019-10-13T00:00:00+00:00</published>
        <updated>2019-10-13T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              jh05013
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://jh05013.github.io/blog/fenwick-more/"/>
        <id>https://jh05013.github.io/blog/fenwick-more/</id>
        
        <content type="html" xml:base="https://jh05013.github.io/blog/fenwick-more/">&lt;p&gt;&lt;em&gt;이 글은 &lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;blog&#x2F;view&#x2F;88&quot;&gt;BOJ 블로그에 있는 글&lt;&#x2F;a&gt;과 동일합니다.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;흔히 lazy propagation을 사용하여 푸는 것으로 알려진 이 두 문제는 사실 펜윅 트리만으로 풀 수 있습니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;gugan-deossem-pointeu-kweori&quot;&gt;구간 덧셈, 포인트 쿼리&lt;&#x2F;h1&gt;
&lt;p&gt;다음 연산을 효율적으로 수행하는 자료구조를 만들어 봅시다. 이것으로 &lt;a href=&quot;https:&#x2F;&#x2F;acmicpc.net&#x2F;problem&#x2F;16975&quot;&gt;16975번 - 수열과 쿼리 21&lt;&#x2F;a&gt;을 풀 수 있습니다.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;$A_L$, $A_{L+1}$, $\cdots$, $A_R$에 각각 $x$씩 더한다.&lt;&#x2F;li&gt;
&lt;li&gt;$A_k$를 출력한다.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;$B_1 = A_1$, $B_k = A_k - A_{k-1}$이라고 두면, 각각의 쿼리는 이렇게 변합니다.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;$B_L$에 $x$를 더하고, R이 마지막 인덱스가 아니면 $B_{R+1}$에서 $x$를 뺀다.&lt;&#x2F;li&gt;
&lt;li&gt;$B_1 + \cdots + B_k$를 출력한다.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;따라서 펜윅 트리로 구현할 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;같은 원리로, 1번 쿼리만 계속 들어온 다음 2번 쿼리만 계속 들어옴이 보장되면, 단순 배열 연산으로 O(N+Q)에 풀 수 있습니다. 스위핑을 생각하시면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;workbook&#x2F;view&#x2F;5043&quot;&gt;연습 문제집&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;gugan-deossem-gugan-hab-kweori&quot;&gt;구간 덧셈, 구간 합 쿼리&lt;&#x2F;h1&gt;
&lt;p&gt;세그먼트 트리 lazy propagation을 쓰는 대표적인 예시로 알려진 이 문제 역시 놀랍게도 펜윅 트리 두 개로 풀 수 있습니다.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;$L, L+1, \cdots, R$번째 원소에 각각 $x$씩 더한다.&lt;&#x2F;li&gt;
&lt;li&gt;$L, L+1, \cdots, R$번째 원소의 합을 출력한다.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;우선, L과 R이 있는 것이 거슬리니까 이렇게 바꿉시다. 원래 있었던 쿼리는 밑의 쿼리 두 번으로 처리할 수 있습니다.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;$k, k+1, \cdots, N$번째 원소에 각각 $x$씩 더한다.&lt;&#x2F;li&gt;
&lt;li&gt;$1, 2, \cdots, k$번째 원소의 합을 출력한다.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;$k, k+1, \cdots, N$번째 원소에 각각 $x$씩 더할 때, 각 $m = 1, 2, \cdots, N$에 대해 “$m$번째까지 원소의 합“이 얼마나 늘어나는지 생각해봅시다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$m &amp;lt; k$라면, $m$번째까지 원소의 합은 변화하지 않습니다.&lt;&#x2F;li&gt;
&lt;li&gt;$m \geq k$라면, $m$번째까지 원소의 합은 $(m-k+1)x$ 늘어납니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;이것은 곧 $k$번째 칸에 일차함수 $f(m) = xm + (-k+1)x$를 집어넣는 펜윅 트리라고 볼 수 있습니다. 두 일차함수의 합은 여전히 일차함수이므로 각 칸마다 일차항의 계수를 저장하는 펜윅 트리를 만들고, 각 칸마다 상수항을 저장하는 펜윅 트리를 만들면 됩니다. 그렇게 만든 트리에서 첫 번째부터 $k$번째까지 원소(일차함수)의 합을 계산하여 또다른 일차함수를 얻고, 그 일차함수의 변수에 $k$를 집어넣어 계산한 값이 2번 쿼리의 답입니다.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Connection Profile DP</title>
        <published>2019-08-21T00:00:00+00:00</published>
        <updated>2019-08-21T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              jh05013
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://jh05013.github.io/blog/cpdp/"/>
        <id>https://jh05013.github.io/blog/cpdp/</id>
        
        <content type="html" xml:base="https://jh05013.github.io/blog/cpdp/">&lt;h1 id=&quot;connection-profile-dp&quot;&gt;Connection Profile DP&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;em&gt;이 글은 비트마스크 DP를 배경지식으로 합니다.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;격자에서 비트마스크 DP를 돌리는 문제가 있습니다.
예를 들어 &lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;1648&quot;&gt;BOJ 1648 (격자판 채우기)&lt;&#x2F;a&gt; 문제에서는
위에서 아래로, 왼쪽에서 오른쪽으로 훑으면서, 최근 M개의 칸의 상태를 비트마스크로 저장합니다.
각 칸의 상태는 그 칸에 도미노가 채워졌으면 1, 아니면 0입니다. 그림으로 나타내면 이렇게 되겠죠.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;cpdp1.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;connection-profile&quot;&gt;Connection Profile??&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;1144&quot;&gt;이 문제를 풀어봅시다.&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;격자에서 연결 요소를 만들되 비용의 합을 최소화하는 문제입니다.
위에서 다룬 것처럼 비트마스크 DP를 하고 싶어집니다. 최근 M개의 칸의 상태를 비트마스크로 저장합니다.
각 칸의 상태는 그 칸이 연결 요소에 포함되어 있으면 1, 아니면 0입니다.&lt;&#x2F;p&gt;
&lt;p&gt;하지만 그러면 안 됩니다.
최근 M개의 칸이 사용되었는지 아닌지만 따져서는 연결 요소가 생겼는지 알 수 없기 때문입니다.
예를 들어, 아래 그림에서 최근 M개의 칸의 상태가 왼쪽과 같을 때,
가운데처럼 모든 칸이 연결되었는지, 오른쪽처럼 모든 칸이 연결되지 않았는지 알 방법이 없습니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;cpdp2.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;그렇다고 지금까지 본 모든 칸의 상태를 다 저장하면 당연히 안 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;그래서 우리는 &lt;strong&gt;어떤 칸들이 서로 연결되어 있는지를 저장할 겁니다.&lt;&#x2F;strong&gt;
연결 요소에 번호를 붙였다고 해봅시다. 단, 선택되지 않은 칸은 0으로 채워넣습니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;cpdp3.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;이제 최근 M개의 칸의 상태만 저장해 놓으면 됩니다!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;cpdp4.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;sangtae-jeoni&quot;&gt;상태 전이&lt;&#x2F;h2&gt;
&lt;p&gt;상태 전이를 분석해 봅시다.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;keiseu-1-hyeon-eul-seontaeghaji-anhneunda&quot;&gt;케이스 1: “현“을 선택하지 않는다.&lt;&#x2F;h3&gt;
&lt;p&gt;“현“을 선택하지 않으면, “현“의 위쪽 칸을 제외하여 최근 M-1개의 칸의 상태가 하나씩 밀리고,
최근 칸의 상태는 0이 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;단, 이 케이스를 따라가면 안 되는 경우가 하나 있습니다.
“현“의 위쪽 칸이 선택되었고, 최근 M-1개의 칸 중 누구와도 연결되어 있지 않을 때입니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;cpdp5.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;이때는 “현“을 선택하지 않는 순간,&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;만약에 최근 M-1개의 칸 중 선택된 칸이 존재한다면,
위쪽 칸은 나머지 칸들과 하나의 연결 요소를 이루는데 실패하게 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;만약에 최근 M-1개의 칸 중 선택된 칸이 없다면, 모든 칸이 하나의 연결 요소를 이루는 데에는 성공했으나,
“이미 하나의 연결 요소가 있었다“는 정보가 소실됩니다.
그래서 “현” 이후의 칸들을 선택해야 하는지 말아야 하는지를 결정할 수 없습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;따라서 이 상황에서는 케이스 1을 건너뛰어야 합니다.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;keiseu-2-hyeon-eul-seontaeghanda&quot;&gt;케이스 2: “현“을 선택한다.&lt;&#x2F;h3&gt;
&lt;p&gt;이때는 “현“의 위쪽 칸과 왼쪽 칸의 상태에 따라 세 가지 경우가 생깁니다.&lt;&#x2F;p&gt;
&lt;p&gt;(1) 위쪽 칸과 왼쪽 칸이 선택되지 않았다면, “현“은 그 자체로 새로운 연결 요소를 이루게 됩니다.
따라서 최근 M개의 칸에서 사용하지 않은 연결 요소 번호를 새로 만들어 그 칸에 집어넣습니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;cpdp6.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;(2) 위쪽 칸과 왼쪽 칸 중 하나만 선택되었다면, 그 칸의 연결 요소의 번호를 “현“이 그대로 따라갑니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;cpdp7.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;(3) 위쪽 칸과 왼쪽 칸이 모두 선택되었다면, 두 칸의 연결 요소가 하나로 합쳐집니다.
두 칸의 연결 요소 번호를 각각 x와 y라고 할 때, 최근 M-1개의 칸 중 번호가 y인 것들의 번호가 x로 바뀝니다
(물론 x에서 y로 바꿀 수도 있습니다.)
그리고 “현“은 그 번호를 그대로 따라갑니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;cpdp8.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;puliyi-mamuri&quot;&gt;풀이의 마무리&lt;&#x2F;h2&gt;
&lt;p&gt;마지막으로, 선택된 칸들이 연결 요소를 이룰 때마다 정답을 갱신해 주면 됩니다.
선택된 칸들이 연결 요소를 이루는지 판별하려면 서로 다른 양수가 1개 이하인지 검사하면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;아쉽게도, N=M=9인 입력을 아무거나 넣어 보면 너무 느리다는 것을 알 수 있습니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;coejeoghwa&quot;&gt;최적화&lt;&#x2F;h1&gt;
&lt;p&gt;물론 연결된 칸끼리는 같은 번호를 가지니 DP 상태의 개수가 M^M개나 되지는 않겠지만,
제가 구현한 바로는 칸 하나를 볼 때마다 7만 개의 상태가 생겼습니다.&lt;&#x2F;p&gt;
&lt;p&gt;이를 최적화하려면 같은 상태들을 하나로 합쳐 줘야 합니다.
예를 들어 다음 두 상태는 같습니다. 연결 요소들에 번호만 다시 붙여 주면 같아지기 때문입니다.
상태 전이를 하면서 최근 M개의 칸의 상태를 “정규화“하는 과정이 필요합니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;cpdp9.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;간단한 방법으로 사전순으로 가장 앞선 상태로 정규화하는 방법이 있습니다.
위쪽 칸에서부터 하나씩 보면서, 상태가 0이면 그대로 0으로 둡니다.
양수이면서 이전에 만난 적 없는 번호면, 새로운 번호를 할당합니다.
이전에 만난 적 있는 번호면, 그 번호가 할당받았던 새로운 번호를 그대로 줍니다.
예를 들어 위 그림의 오른쪽 상태는 왼쪽 상태로 정규화됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;위에 언급했듯이 인접한 칸은 같은 번호를 가지므로 정확한 시간 복잡도를 분석하기는 어렵지만,
적당한 상한은 잡아줄 수 있습니다.
정규화를 했기 때문에, 최근 M개의 칸의 상태로 가능한 조합의 개수는
M개의 칸을 몇 개의 집합으로 분할하는 방법의 수보다 작거나 같습니다.
그 수는 bell number라고 하고, 0번째 bell number부터 차례대로 나열한 수열이
&lt;a href=&quot;http:&#x2F;&#x2F;oeis.org&#x2F;A000110&quot;&gt;OEIS에 번호 A000110&lt;&#x2F;a&gt;으로 있습니다.
9번째 bell number는 21,147입니다.
적당한 상한만 잡은 건데도 위에서 보았던 7만 개보다 훨씬 적고,
실제로 돌려 보면 나타나는 상태의 개수는 2천 개밖에 되지 않습니다.&lt;&#x2F;p&gt;
&lt;p&gt;정규화 작업까지 해 주고 N=M=9인 입력을 넣어 보면 답이 순식간에 나오는 것을 확인할 수 있고,
저의 구현은 0.1초 안에 &lt;strong&gt;맞았습니다!!&lt;&#x2F;strong&gt; 를 받았습니다.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
