<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>jh05013 - algorithm</title>
      <link>https://jh05013.github.io</link>
      <description></description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://jh05013.github.io/tags/algorithm/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Sun, 30 Mar 2025 00:00:00 +0000</lastBuildDate>
      <item>
          <title>재귀의 본질</title>
          <pubDate>Sun, 30 Mar 2025 00:00:00 +0000</pubDate>
          <author>jh05013</author>
          <link>https://jh05013.github.io/blog/recursion/</link>
          <guid>https://jh05013.github.io/blog/recursion/</guid>
          <description xml:base="https://jh05013.github.io/blog/recursion/">&lt;blockquote class=&quot;note&quot;&gt;
	&lt;p class=&quot;alert-title&quot;&gt;
		&lt;i class=&quot;icon&quot;&gt;&lt;&#x2F;i&gt;Note&lt;&#x2F;p&gt;
	&lt;p&gt;재귀를 처음 배우신다면 맨 아래에 첨부한 링크를 같이 참조하는 것이 좋습니다.&lt;&#x2F;p&gt;

&lt;&#x2F;blockquote&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;재귀를 배웁니다. 재귀 함수는 자기 자신을 호출하는 함수입니다. 좋습니다.&lt;&#x2F;p&gt;
&lt;p&gt;재귀로 팩토리얼을 구현합니다. 잘 돌아갑니다. &lt;code&gt;factorial(5)&lt;&#x2F;code&gt;는 &lt;code&gt;factorial(4)&lt;&#x2F;code&gt;를 부르고, 이건 다시 &lt;code&gt;factorial(3)&lt;&#x2F;code&gt;을 부르고… &lt;code&gt;factorial(0)&lt;&#x2F;code&gt;을 부르고, 이건 1을 반환하고, &lt;code&gt;factorial(1)&lt;&#x2F;code&gt;이 여기에 1을 곱해서 1을 반환하고… &lt;code&gt;factorial(5)&lt;&#x2F;code&gt;가 여기에 5를 곱해서 120을 반환합니다. 그럴싸합니다.&lt;&#x2F;p&gt;
&lt;p&gt;재귀로 피보나치를 구현합니다. 잘 돌아갑니다. 강좌에 두 갈래로 마구 뻗는 함수 호출 과정이 그림으로 등장합니다. 구체적으로 뭐가 어떤 순서로 호출되는 건지는 안 나와있지만 넘어갑니다.&lt;&#x2F;p&gt;
&lt;p&gt;문제는 하노이 탑입니다. 풀이가 있지만 이게 왜 동작하는지, 이걸 어떻게 생각해 내는 건지는 알 수 없습니다. 원판 n-1개를 1에서 2로 옮긴다고 했지만 함수 호출이 어떻게 일어나서 그렇게 되는지 추적할 수 없습니다. 원판을 일곱 번 옮기는 그림이 있지만 도움이 되지 않습니다. 며칠째 호출 과정을 추적하다가 결국 포기하고 풀이를 암기하기로 합니다.&lt;&#x2F;p&gt;
&lt;p&gt;제 경험이 그랬다는 건 아니지만, 위와 같은 일을 겪는 사례를 심심찮게 찾아볼 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;재귀가 원래 이렇게 이상한 존재일까요? 그렇지 않습니다. 재귀의 본질은 이 복잡한 호출 과정을 따라가는 데서 나오지 않습니다. &lt;em&gt;오히려 따라가지 않는 데서 나옵니다.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;jaegwireul-puneun-bangbeob&quot;&gt;재귀를 푸는 방법&lt;&#x2F;h1&gt;
&lt;p&gt;재귀로 문제를 푸는 규칙은 이렇습니다.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;입력 크기가 가장 작을 때 (0, 1 등) 문제를 풉니다.&lt;&#x2F;li&gt;
&lt;li&gt;입력 크기가 N보다 작을 때 문제를 풀 수 있다고 가정합니다. &lt;strong&gt;구체적으로 어떻게 풀었는지는 생각하지 않습니다.&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;이제 입력 크기가 N일 때 문제를 풉니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;재귀의 장벽을 깨뜨리는 첫걸음은 2번입니다. &lt;em&gt;“구체적으로 어떻게 풀었는지는 생각하지 않습니다.”&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;사실 생각해 보면 프로그램의 동작 과정을 바닥까지 다 따라갈 필요가 없습니다. 예를 들어 &lt;code&gt;print&lt;&#x2F;code&gt; (&lt;code&gt;printf&lt;&#x2F;code&gt;, &lt;code&gt;cout&lt;&#x2F;code&gt;, …)도 내부적으로 뭔가를 호출할 텐데, 우리는 &lt;code&gt;print&lt;&#x2F;code&gt;를 처음 배울 때 내부를 굳이 뜯어보지 않습니다. &lt;code&gt;print&lt;&#x2F;code&gt;가 뭔가를 출력하는 함수라고 &lt;em&gt;믿고&lt;&#x2F;em&gt; 그냥 씁니다. 재귀도 마찬가지입니다. 단지 내부가 자기 자신이 될 뿐입니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;paegtorieol&quot;&gt;팩토리얼&lt;&#x2F;h2&gt;
&lt;p&gt;위 규칙으로 팩토리얼을 풀어봅시다. 먼저 &lt;code&gt;N == 0&lt;&#x2F;code&gt;이라면 1을 반환합니다.&lt;&#x2F;p&gt;
&lt;p&gt;이제 입력 크기가 &lt;code&gt;N&lt;&#x2F;code&gt;보다 작을 때 문제를 풀 수 있다고 가정합니다. 즉 &lt;code&gt;factorial(N-1)&lt;&#x2F;code&gt;은 $(N-1)!$을 반환합니다. &lt;strong&gt;구체적으로 &lt;code&gt;factorial(N-1)&lt;&#x2F;code&gt;이 어떻게 동작하는지는 생각하지 않습니다.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;이제 $N! = (N-1)! \times N$이고 $(N-1)!$은 &lt;code&gt;factorial(N-1)&lt;&#x2F;code&gt;이니까, &lt;code&gt;factorial(N-1) * N&lt;&#x2F;code&gt;을 반환하면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;이를 재귀로 구현했을 때 왜 제대로 동작하는지를 이해하려면, 마찬가지로 입력 크기가 N보다 작을 때 제대로 동작한다고 가정합니다. 이번에도 구체적으로 왜 그런지는 생각하지 않습니다. &lt;code&gt;factorial(5)&lt;&#x2F;code&gt;를 계산하려고 한번에 다섯 단계까지 깊이 들어갈 필요가 없습니다. &lt;code&gt;factorial(4) = 4!&lt;&#x2F;code&gt;임을 이미 아는 상태라고 가정하고 거기서 바로 끝내면 됩니다. 이걸 일일이 풀어 계산하는 건 컴퓨터의 몫입니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hanoi-tab&quot;&gt;하노이 탑&lt;&#x2F;h2&gt;
&lt;p&gt;우선 하노이 탑을 풀이할 때 “재귀를 사용해 보자“가 먼저 나오면 안 됩니다. 문제에 대해 아직 아무것도 알아낸 게 없는 상태에서는 재귀를 떠올릴 수 없습니다.&lt;&#x2F;p&gt;
&lt;p&gt;하노이 탑을 손으로 풀려고 시도해 보면, 원판이 클수록 그 위에 있을 수 있는 다른 원판이 많아지기 때문에 옮기기 어렵다는 것을 알 수 있습니다. 특히 맨 밑에 있는 N번째 원판은 매우 제한적인 상황에서만 옮길 수 있습니다. 그럼에도 N번째 원판을 어떻게든 기둥 1에서 3으로 옮겨야 합니다.&lt;&#x2F;p&gt;
&lt;p&gt;N번째 원판을 기둥 1에서 3으로 옮길 수 있는 상황은 어떤 상황일까요?&lt;&#x2F;p&gt;
&lt;details&gt;
  &lt;summary&gt;해답&lt;&#x2F;summary&gt;
  (1) N번째 원판 위에 있는 다른 모든 원판을 어떻게든 치워야 하고, (2) 기둥 3에 아무 원판도 있지 않아야 합니다.
&lt;p&gt;그런 상황은 하나 밖에 없습니다. 기둥 1에 N번째 원판 하나, 기둥 2에 다른 모든 원판이 있고, 기둥 3은 비어있을 때입니다.&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;p&gt;그래서 맨 처음 해야 되는 일은…&lt;&#x2F;p&gt;
&lt;details&gt;
  &lt;summary&gt;해답&lt;&#x2F;summary&gt;
  어떻게든 &quot;다른 모든 원판&quot;을 전부 기둥 1에서 2로 옮기는 것입니다.
&lt;p&gt;그런데 이건 하노이 탑 문제와 동일합니다. 원판이 하나 줄었고 도착지가 바뀌었을 뿐입니다.&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;p&gt;그러면 그 문제는 어떻게 풀어야 할까요?&lt;&#x2F;p&gt;
&lt;details&gt;
  &lt;summary&gt;해답&lt;&#x2F;summary&gt;
  같은 문제가 다시 등장했으니 재귀를 사용합니다.
&lt;p&gt;재귀의 규칙에 따라, 원판 N-1개를 다 옮길 수 있다고 가정하고 &lt;strong&gt;구체적으로 어떻게 옮기는지는 생각하지 않습니다.&lt;&#x2F;strong&gt; 도착점 이슈는 번호를 다시 붙이면 같은 문제가 되기 때문에 걱정할 필요가 없습니다. 그렇게 가정하고… 가정에 따라 그냥 옮기면 됩니다.&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;p&gt;나머지 과정은 비슷합니다. N번째 원판을 1에서 3으로 옮기고, 2에 있었던 “다른 모든 원판“을 전부 3으로 옮깁니다. 이번에도 구체적으로 어떻게 옮기는지는 생각하지 않습니다.&lt;&#x2F;p&gt;
&lt;p&gt;이를 정리하면,&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;재귀적으로 원판 N-1개짜리 하노이 탑을 풀어서 1에서 2로 옮긴다.&lt;&#x2F;li&gt;
&lt;li&gt;N번째 원판을 1에서 3으로 옮긴다.&lt;&#x2F;li&gt;
&lt;li&gt;재귀적으로 원판 N-1개짜리 하노이 탑을 풀어서 2에서 3으로 옮긴다.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;가 됩니다. 이제 위 과정을 그대로 코드로 옮기면 끝입니다. (물론 원판이 1개일 때는 따로 처리합시다.) 재귀의 규칙을 잘 따랐기 때문에 올바르게 동작합니다.&lt;&#x2F;p&gt;
&lt;p&gt;그래도 조금 의심된다면 풀이를 검토해 봅시다.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;1번 과정이 끝나면 원판 1부터 N-1까지가 기둥 1에서 2로 옮겨집니다. 재귀의 규칙에 따라, &lt;strong&gt;그게 왜 되는지는 생각하지 않습니다.&lt;&#x2F;strong&gt; 그냥 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;그 상태에서는 N번째 원판을 1에서 3으로 옮길 수 있습니다.&lt;&#x2F;li&gt;
&lt;li&gt;3번 과정이 끝나면 원판 1부터 N-1까지가 기둥 2에서 3으로 옮겨집니다. 이번에도 그게 왜 되는지는 생각하지 않습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h1 id=&quot;ige-jinjja-dwaeyo&quot;&gt;이게 진짜 돼요?&lt;&#x2F;h1&gt;
&lt;p&gt;얼핏 보면 뭔가 사기인 것 같지만, 이 논리가 통하는 이유는 다음과 같습니다.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;factorial(0) = 1&lt;&#x2F;code&gt;입니다. 재귀 함수에서 이 경우를 따로 처리했을 것입니다.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;factorial(1) = 1 * factorial(0)&lt;&#x2F;code&gt;입니다. 바로 위에서 &lt;code&gt;factorial(0) = 1&lt;&#x2F;code&gt;임을 이미 파악했습니다. 따라서 &lt;code&gt;factorial(1) = 1 * 1 = 1&lt;&#x2F;code&gt;입니다.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;factorial(2) = 2 * factorial(1)&lt;&#x2F;code&gt;입니다. 바로 위에서 &lt;code&gt;factorial(1) = 1&lt;&#x2F;code&gt;임을 이미 파악했습니다. 따라서 &lt;code&gt;factorial(2) = 2 * 1 = 2&lt;&#x2F;code&gt;입니다.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;factorial(3) = 3 * factorial(2)&lt;&#x2F;code&gt;입니다. 바로 위에서 &lt;code&gt;factorial(2) = 2&lt;&#x2F;code&gt;임을 이미 파악했습니다. 따라서 &lt;code&gt;factorial(3) = 3 * 2 = 6&lt;&#x2F;code&gt;입니다.&lt;&#x2F;li&gt;
&lt;li&gt;…&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;factorial(N) = N * factorial(N-1)&lt;&#x2F;code&gt;입니다. 바로 위에서 &lt;code&gt;factorial(N-1) = (N-1)!&lt;&#x2F;code&gt;임을 이미 파악했습니다. 따라서 &lt;code&gt;factorial(N) = N * (N-1)! = N!&lt;&#x2F;code&gt;입니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;하노이 탑도 마찬가지입니다.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;원판이 1개일 때 잘 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;원판이 1개일 때 잘 된다고 가정하면, 재귀의 규칙에 따라 원판이 2개일 때도 잘 됩니다. 원판이 1개일 때 잘 된다는 것을 바로 위에서 파악했습니다. 따라서 원판이 2개일 때도 잘 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;원판이 2개일 때 잘 된다고 가정하면, 재귀의 규칙에 따라 원판이 3개일 때도 잘 됩니다. 원판이 2개일 때 잘 된다는 것을 바로 위에서 파악했습니다. 따라서 원판이 3개일 때도 잘 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;…&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;수학적 배경이 있으시다면 사실 이게 수학적 귀납법과 같은 이치임을 눈치채셨을 수도 있겠습니다. 이것이 바로 재귀의 본질입니다.&lt;&#x2F;p&gt;
&lt;details&gt;
  &lt;summary&gt;수학적 귀납법이란?&lt;&#x2F;summary&gt;
  자연수 $N$에 대한 명제 $P$를 증명할 때 다음 두 사실을 증명하는 테크닉을 수학적 귀납법이라고 합니다.
&lt;p&gt;(1) $P(0)$은 참이다. &lt;small&gt;0도 자연수라고 합시다.&lt;&#x2F;small&gt;&lt;&#x2F;p&gt;
&lt;p&gt;(2) 모든 자연수 $k$에 대해, $P(k)$가 참이라면 $P(k+1)$도 참이다.&lt;&#x2F;p&gt;
&lt;p&gt;그러면 $P(0)$이 참이고, $P(0)$이 참이니까 $P(1)$이 참이고, 그래서 $P(2)$도 참이고, … 어떤 $N$을 보더라도 $P(N)$이 참이기 때문에, 명제 $P$는 참입니다.&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;p&gt;이처럼 재귀의 규칙을 수학이 정당화해 주기 때문에, 우리는 재귀의 규칙을 따르는 것에만 신경 쓰면 됩니다. 심지어 저 “$P(1)$이 참이고 그래서 $P(2)$가 참이고…“에도 신경 쓸 필요가 없습니다. 컴퓨터와 수학이 알아서 처리해 줄 것입니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;biseushan-geul&quot;&gt;비슷한 글&lt;&#x2F;h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.encrypted.gg&#x2F;943&quot;&gt;BaaaaaaaarkingDog, 실전 알고리즘 0x0B강 - 재귀&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;velog.io&#x2F;@eddy_song&#x2F;you-can-solve-recursion#3%EB%8B%A8%EA%B3%84-%EB%B6%84%ED%95%B4-1&quot;&gt;Eddy, 야, 너두 재귀할 수 있어: 재귀가 풀리는 4단계 접근법&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;infossm.github.io&#x2F;blog&#x2F;2021&#x2F;07&#x2F;09&#x2F;recursion&#x2F;&quot;&gt;djm03178, 재귀 함수에 대한 이해&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
      </item>
      <item>
          <title>빅-O, 빅-Ω, 빅-Ө는 최악, 최선, 평균을 의미하지 않습니다.</title>
          <pubDate>Wed, 18 Dec 2024 00:00:00 +0000</pubDate>
          <author>jh05013</author>
          <link>https://jh05013.github.io/blog/big-o/</link>
          <guid>https://jh05013.github.io/blog/big-o/</guid>
          <description xml:base="https://jh05013.github.io/blog/big-o/">&lt;p&gt;&lt;em&gt;이 글은 &lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;blog&#x2F;view&#x2F;136&quot;&gt;BOJ 블로그에 있는 글&lt;&#x2F;a&gt;과 동일합니다.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;알고리즘 공부를 시작할 때 맨 처음 만나는 개념 중 시간, 공간 복잡도가 있습니다.
안타깝게도, 이는 오개념이 가장 많이 퍼진 주제이기도 합니다.
여러 오개념이 있지만 이 글에서는…&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;“빅-Ω 표기법은 최선의 경우를 다룰 때 사용한다. 빅-Ө 표기법은 평균의 경우를 다룰 때 사용한다. 빅-O 표기법은 최악의 경우를 다룰 때 사용한다.”&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;…라는 오개념을 다룹니다. 이 주장은 각종 블로그 글은 물론, 이름 있는 출처에도 가끔씩 나오며
&lt;a href=&quot;https:&#x2F;&#x2F;hanbit.co.kr&#x2F;channel&#x2F;category&#x2F;category_view.html?cms_code=CMS7965376216&quot;&gt;심지어 책으로도 나왔습니다&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;잘못된 말입니다. 빅-O, 빅-Ω, 빅-Ө 표기법은 그 자체로 최선, 최악 등의 경우를 가정하지 않으며,
&lt;strong&gt;세 표기법 모두를 최선, 최악, 평균의 경우에 모두 사용할 수 있습니다.&lt;&#x2F;strong&gt;
단지 최악의 경우 및 빅-O 표기법을 가장 많이 쓸 뿐입니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;olbareun-yongrye&quot;&gt;올바른 용례&lt;&#x2F;h1&gt;
&lt;p&gt;“길이가 n인 정수 리스트 L에 정수 target이 있는지 판별하세요“라는 문제를
다음과 같은 의사코드로 풀었다고 해봅시다.&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;function find(L, target):
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  for x in L:
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    if x == target: return true
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  return false
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;최악의 경우는 L에 target이 없어서 L 전부를 훑어볼 때이고,
최선의 경우는 맨 첫 수가 target과 같을 때입니다. 따라서&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;이 알고리즘의 최선의 경우 시간 복잡도는 O(1)이자, Ω(1)이자, Ө(1)입니다.&lt;&#x2F;li&gt;
&lt;li&gt;이 알고리즘의 최악의 경우 시간 복잡도는 O(n)이자, Ω(n)이자, Ө(n)입니다.&lt;&#x2F;li&gt;
&lt;li&gt;평균 시간 복잡도는 정의하기 조금 어렵지만, 직관적으로 생각할 수 있는 평균의 기준을 따른다면 시간 복잡도는 O(n)이자, Ω(n)이자, Ө(n)일 것입니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;시간 복잡도가 O(f(n))이라는 것은 수행 시간이 최대 f(n)만큼 커진다는 뜻입니다.
그것뿐입니다. 정확히 무슨 수행 시간인지는 맥락에 따라 다릅니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;sanghaneun-coeageul-yimihaji-anhseubnida&quot;&gt;상한은 최악을 의미하지 않습니다&lt;&#x2F;h1&gt;
&lt;p&gt;“빅-O 표기법은 수행 시간의 상한을 표현한다“는 맞는 말입니다.
최악의 경우에서 빅-O 표기법을 쓰면 최악의 수행 시간의 상한이 되고,
최선의 경우에서 빅-O 표기법을 쓰면 최선의 수행 시간의 상한이 됩니다.
딱 보면 뭔가 말이 안 되는 것 같은데요.&lt;&#x2F;p&gt;
&lt;p&gt;쉬운 이해를 위해, 알고리즘 중간고사를 봤다고 생각해 봅시다.
시험이 막 끝나서 정확한 점수는 모르지만, 어느 정도 예상은 할 수 있습니다.
최악의 경우(실수를 꽤 했을 때)와 최선의 경우(시도한 문제들의 풀이가 완벽할 때)
얼마나 받을지 예상을 해봅니다.&lt;&#x2F;p&gt;
&lt;p&gt;이제 친구가 여러분에게 물어봅니다. “몇 점 받을 것 같아?”&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;“못 봐도 80점은 나오지 않을까?“라고 답한다면,
“못 봐도“는 최악의 경우, “80점“은 예상 점수의 하한입니다.
아무리 실수를 많이 해서 마구 틀리더라도 적어도 80점은 될 것 같다는 뜻입니다.&lt;&#x2F;li&gt;
&lt;li&gt;“잘 보면 90점도 나올 것 같아!“라고 답한다면,
“잘 보면“은 최선의 경우, “90점“은 예상 점수의 하한입니다.
정말 잘 봐서 시도한 모든 풀이가 완벽하면 적어도 90점은 될 것 같다는 뜻입니다.&lt;&#x2F;li&gt;
&lt;li&gt;“못 보면 70점 밑으로도 갈 것 같아…“라고 답한다면,
“못 보면“은 최악의 경우, “70점“은 예상 점수의 상한입니다.&lt;&#x2F;li&gt;
&lt;li&gt;“잘 봐도 60점 안 될 거야……“라고 답한다면,
“잘 봐도“는 최선의 경우, “60점“은 예상 점수의 상한입니다.
괜찮습니다. 기말고사를 잘 보면 되죠.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;이처럼 최선과 최악의 케이스에서 모두 예상 점수의 하한과 상한을 논할 수 있습니다.
중요한 것은 하한, 상한이 그 자체로 최선, 최악을 의미하는 것이 아니라,
단순히 &lt;em&gt;특정 시나리오&lt;&#x2F;em&gt;에서 예상 점수의 범위를 표현할 때 쓰인다는 것입니다.&lt;&#x2F;p&gt;
&lt;p&gt;알고리즘도 마찬가지입니다. 최선과 최악의 케이스에서 모두 수행 시간의 하한과 상한을 논할 수 있습니다.
하한, 상한은 단순히 &lt;em&gt;특정 시나리오&lt;&#x2F;em&gt;에서 수행 시간의 범위를 표현합니다. 그래서,&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;“최악의 시간 복잡도가 O(n)“이라는 것은, 최악의 경우에 정확한 연산 횟수는 세보지 않았지만
그래도 선형 시간 안에는 돈다는 뜻입니다. 이때 n은 &lt;em&gt;최악의 경우&lt;&#x2F;em&gt;에 대한 상한입니다.&lt;&#x2F;li&gt;
&lt;li&gt;“최선의 시간 복잡도가 O(n)“이라는 것은, 최선의 경우에 정확한 연산 횟수는 세보지 않았지만
그래도 선형 시간 안에는 돈다는 뜻입니다. 이때 n은 &lt;em&gt;최선의 경우&lt;&#x2F;em&gt;에 대한 상한입니다.&lt;&#x2F;li&gt;
&lt;li&gt;“최악의 시간 복잡도가 Ω(n)“이라는 것은, 최악의 …중략…
그래도 선형 시간보다 빠르지는 않다는 뜻입니다.&lt;&#x2F;li&gt;
&lt;li&gt;“최악의 시간 복잡도가 Ө(n)“이라는 것은, 최악의 …중략…
그래도 딱 선형 시간이 걸린다는 뜻입니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;그러고 보니 Ө도 하나 얘기를 해야 되는데요…&lt;&#x2F;p&gt;
&lt;h1 id=&quot;big-oneun-jungganeul-yimihajido-anhseubnida&quot;&gt;빅-Ө는 중간을 의미하지도 않습니다&lt;&#x2F;h1&gt;
&lt;p&gt;비슷한 오개념으로 “빅-Ө는 빅-O와 빅-Ω의 중간을 의미한다“라는 것이 있습니다.
n과 n^2의 중간은 어디일까요?&lt;&#x2F;p&gt;
&lt;p&gt;시간 복잡도가 Ө(f(n))이라는 것은 O(f(n))인 동시에 Ω(f(n))이라는 뜻입니다.
알고 있는 Ω(하한)과 O(상한)이 다르다면, Ө는 아마도 중간 어딘가이긴 하겠지만,
정확히는 Ө를 논할 수 없다고 말해야 옳습니다.
O와 Ω가 한 함수에서 딱 만나야 Ө가 생기는 것입니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;ohaega-peojin-iyu&quot;&gt;오해가 퍼진 이유&lt;&#x2F;h1&gt;
&lt;p&gt;“빅-O가 최악의 경우를 의미한다“라는 오개념이 퍼진 이유는 여러 가지가 있겠지만,
이런 이유를 들 수 있을 것 같습니다.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;빅-O와 최악의 경우가 대개 자주 엮입니다.
아무 입력이나 들어올 수 있는 온라인 저지 환경에서는 최악의 경우에서도 빠른 알고리즘이 선호됩니다.
그리고 수행 시간이 얼마 이하임을 알아야 알고리즘이 정당하다고 할 수 있는데,
그 상한의 역할을 하는 게 빅-O 표기법입니다.
그래서 알고리즘 문제 풀이에서는 빅-O로 최악의 시간 복잡도를 구하는 경우가 많습니다.&lt;&#x2F;li&gt;
&lt;li&gt;“상한“과 “최악의 경우“가 의미상으로 비슷해 보입니다.
그도 그럴 게, 최악의 시간 복잡도가 O(f(n))인 알고리즘은 모든 경우에서 O(f(n))의 시간에 돕니다.
최악의 시간 복잡도는 어떻게 보면 모든 입력의 시간 복잡도에 대한 상한인 셈입니다.
하지만 다시 정리하자면 빅-O에서 얘기하는 상한은 최선, 최악 관계없이
&lt;em&gt;특정 경우&lt;&#x2F;em&gt;에서 함수의 상한을 얘기하는 것으로, 꼭 모든 경우에 대한 상한일 필요는 없습니다.&lt;&#x2F;li&gt;
&lt;li&gt;Ө를 쓸 수 있는 상황에서도 O를 쓰는 경우가 많습니다.
물론 잘못된 것은 아니지만, 최악과 빅-O가 더 깊게 엮이는 효과를 어느 정도 불렀을 것 같습니다.
(사실 저도 씁니다. 셋 중에 아스키 문자가 O밖에 없어서요…)&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;빅-O가 최악의 경우를 뜻한다고 잘못 생각한다면,
반대로 빅-Ω가 최선의 경우라고 잘못 생각하는 것도 자연스러워 보입니다.
그리고 최악과 최선을 빼고 남은 게 평균이라서
빅-Ө가 평균이라는 오개념까지 완성된 게 아닐까 추정해 봅니다.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>삼각형 찾기</title>
          <pubDate>Mon, 02 Oct 2023 00:00:00 +0000</pubDate>
          <author>jh05013</author>
          <link>https://jh05013.github.io/blog/enumerating-triangles/</link>
          <guid>https://jh05013.github.io/blog/enumerating-triangles/</guid>
          <description xml:base="https://jh05013.github.io/blog/enumerating-triangles/">&lt;p&gt;단순 그래프의 정점의 개수를 $n$, 간선의 개수를 $m$이라고 합시다. 이 그래프에 있는 삼각형, 즉 길이 3의 사이클을 모두 찾을 수 있을까요?&lt;&#x2F;p&gt;
&lt;h1 id=&quot;o-frac-nm-w&quot;&gt;$O(\frac{nm}{w})$&lt;&#x2F;h1&gt;
&lt;p&gt;간선 하나 $uv$를 고정하고, 그 간선을 포함하는 삼각형을 찾아봅시다.&lt;&#x2F;p&gt;
&lt;p&gt;인접 행렬을 만듭니다. 그러면 $u$와 $v$에 인접한 모든 정점 $a$에 대해 삼각형 $uva$를 찾을 수 있습니다. 인접 행렬의 $u$행과 $v$행에서 둘 다 인접 표시가 된 열을 찾으면 됩니다. 시간 복잡도는 $O(nm)$입니다.&lt;&#x2F;p&gt;
&lt;p&gt;이 과정을 비트셋의 교집합 연산으로 최적화하면 시간 복잡도 $O(\frac{nm}{w})$에 모든 삼각형을 찾을 수 있습니다. 64비트 컴퓨터에서 $w = 64$입니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yeonseubmunje&quot;&gt;연습문제&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;20501&quot;&gt;BOJ 20501 Facebook&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;atcoder.jp&#x2F;contests&#x2F;abc258&#x2F;tasks&#x2F;abc258_g&quot;&gt;ABC258 Triangle&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;8907&quot;&gt;BOJ 8907 네온 사인&lt;&#x2F;a&gt; &#x2F; &lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;8096&quot;&gt;BOJ 8096 Monochromatic Triangles&lt;&#x2F;a&gt;를 말그대로 붉은색, 파란색 삼각형을 직접 세서 풀 수 있습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;o-m-sqrt-m&quot;&gt;$O(m \sqrt m)$&lt;&#x2F;h1&gt;
&lt;p&gt;정점 $v$의 차수를 $\deg(v)$라고 할 때, 다음 식을 생각해 봅시다.&lt;&#x2F;p&gt;
&lt;p&gt;$$\sum_{uv \in E} \min(\deg(u), \deg(v))$$&lt;&#x2F;p&gt;
&lt;p&gt;이 값은 $O(m \sqrt m)$입니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;증명.&lt;&#x2F;strong&gt; $\sum_{v \in V} \deg(v) = 2m$이므로, $\deg(v) \geq \sqrt m$인 정점은 많아야 $O(\sqrt m)$개입니다. 그래프가 단순하므로, $\min(\deg(u), \deg(v)) \geq \sqrt m$인 간선은 많아야 $O(m)$개입니다. 나머지 간선은 $\min(\deg(u), \deg(v)) \leq \sqrt m$입니다. ■&lt;&#x2F;p&gt;
&lt;p&gt;이제 정점을 차수 순으로, 동점일 경우 번호 순으로 정렬해서 위에서 아래로 늘어놓읍시다. 위 $v$에서 아래 $p$로 가는 간선을 $v \downarrow p$라고 합시다.&lt;&#x2F;p&gt;
&lt;p&gt;모든 간선 $v \downarrow p$에 대해 간선 $pq$(위아래 상관없음)를 모두 찾을 수 있습니다. 예를 들면 아래와 같은 경우가 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;triangle_downpq.png&quot; alt=&quot;TODO: add subtitle&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;그러한 $(v, p, q)$ 쌍은 $O(\sum_{v \rightarrow p \in E} \deg(p)) = O(m \sqrt m)$개 존재합니다. $\min(\deg(v), \deg(p)) = \deg(p)$이기 때문입니다.&lt;&#x2F;p&gt;
&lt;p&gt;따라서, 위에서 아래로 가는 $v \downarrow p \downarrow q$ 꼴의 경로도 당연히 모두 찾을 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;이제 각 $v \downarrow p \downarrow q$에 대해 $q$와 $v$가 인접한지 확인하면 됩니다. 간단하게는 해시셋으로 구현할 수 있지만 이는 너무 무겁고, 다음과 같은 방법으로 진행할 수 있습니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;우선 크기 $n$의 배열 $A$를 초기화합니다.&lt;&#x2F;li&gt;
&lt;li&gt;각 $v$에 대해…
&lt;ul&gt;
&lt;li&gt;각 간선 $v \downarrow p$에 대해 $A[p]$를 마킹합니다. 즉 $A[p]$는 “$p$가 $v$의 아래에 있으면서 인접하다“라는 뜻입니다.&lt;&#x2F;li&gt;
&lt;li&gt;다시 각 간선 $v \downarrow p$에 대해, 간선 $p \downarrow q$들을 순회합니다. $A[q]$가 마킹되어 있다면 삼각형 $vpq$를 찾았습니다.&lt;&#x2F;li&gt;
&lt;li&gt;다시 각 간선 $v \downarrow p$에 대해 $A[p]$의 마킹을 지웁니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;각 삼각형은 $a \downarrow b \downarrow c$ 꼴의 경로를 정확히 하나씩 갖고 있으므로, 각 삼각형이 정확히 한 번씩 세어집니다. 총 시간 복잡도는 $O(m \sqrt m)$입니다. 같은 방법으로 그래프에는 삼각형이 최대 $O(m \sqrt m)$개 있음을 증명할 수 있습니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yeonseubmunje-1&quot;&gt;연습문제&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;judge.yosupo.jp&#x2F;problem&#x2F;enumerate_triangles&quot;&gt;LC Enumerate Triangles&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;1762&quot;&gt;BOJ 1762 평면그래프와 삼각형&lt;&#x2F;a&gt;을 평면그래프 조건 없이 풀 수 있습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;cuga-yeonseubmunje&quot;&gt;추가 연습문제&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;boj-14571-moraesigye-in-o-m-sqrt-m&quot;&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;14571&quot;&gt;BOJ 14571 모래시계&lt;&#x2F;a&gt; in $O(m \sqrt m)$&lt;&#x2F;h3&gt;
&lt;p&gt;모든 삼각형을 $O(m \sqrt m)$에 찾습니다. 각 정점 $v$에 대해, $v$를 포함하는 삼각형 $vpq$에 대해 간선 $pq$의 목록을 저장해 둡니다.&lt;&#x2F;p&gt;
&lt;p&gt;모래시계의 중심 $v$를 고정하고, $v$에 대한 간선 $pq$로 이루어진 부분그래프를 생각해 봅시다. 이 부분그래프의 간선 $e$개 중 두 개를 고르되 겹치는 정점이 없도록 하는 경우의 수를 구하면 됩니다. 첫 번째 간선 $ab$를 고르고, 나머지 간선 중 $a$ 또는 $b$와 이어지는 것을 모두 제외하면, 남은 간선의 개수는 $e - \deg(a) - \deg(b) + 1$입니다. 이때 $\deg$는 부분그래프 기준입니다.&lt;&#x2F;p&gt;
&lt;p&gt;부분그래프에서 차수를 관리하는 것은 위의 $A$ 배열과 같은 방식으로 진행할 수 있습니다.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;sagaghyeongyi-gaesu&quot;&gt;&lt;a href=&quot;https:&#x2F;&#x2F;judge.yosupo.jp&#x2F;problem&#x2F;counting_c4&quot;&gt;사각형의 개수&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;삼각형뿐만 아니라 사각형도 셀 수 있습니다! 사각형은 최대 $O(m^2)$개 있을 수 있지만, 개수는 $O(m \sqrt m)$에 구할 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;메인 아이디어는 아래 그림과 같습니다. 사각형을 $v \downarrow p \rightarrow q$ 꼴의 경로 두 개로 분할할 수 있으니, 그런 형태의 경로를 세는 것입니다. 각 $v \downarrow p$에 대해, $v$의 아래에 있으면서 $v$와 $p$에 인접한 정점 $q$의 개수를 $k_{vp}$라고 하면, 모든 $\frac{k_{vq}(k_{vq}-1)}{2}$의 합을 구하면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;count_4cycles.png&quot; alt=&quot;graph with directed edges v-&amp;gt;p1, v-&amp;gt;p2, v-&amp;gt;p3, p1-&amp;gt;q, and p3-&amp;gt;q going downwards, and p2-&amp;gt;q going upwards.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;앞에서 보았듯이 $k_{vq} &amp;gt; 0$인 $(v, q)$는 $O(m \sqrt m)$개이고, 0보다 큰 모든 $k_{vq}$를 $O(m \sqrt m)$에 구할 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;위 과정을 조금 변형하면 각 정점을 포함하는 사각형의 개수도 셀 수 있습니다.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;boj-2390&quot;&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;2390&quot;&gt;BOJ 2390 ⎐&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;제가 이 알고리즘을 배운 계기가 된 문제입니다. 검수하면서 풀이를 고민하다가 “사각형을 $O(M^2)$보다 빠르게 셀 수 없는데 어떻게 ⎐를 셀 수 있지?“라고 생각했는데, 사각형을 $O(M \sqrt M)$에 셀 수 있더라고요…&lt;&#x2F;p&gt;
&lt;p&gt;바로 위에서 보았듯이, 각 정점 $v$에 대해 $v$를 포함하는 사각형의 개수를 셉니다. 이제 ⎐에서 차수가 4인 정점을 “⎐의 중심“이라고 하면, 각 정점 $v$에 대해 $v$가 중심인 ⎐의 개수를 셉니다. 사각형의 개수에 $deg(v)-2$를 곱하면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;모든 $v$에 대해 위 값을 구하고 합하면, 놀랍게도 크기 5의 완전 그래프에서 출력이 60이 나옵니다. 왜냐하면 다음 🪁 모양 케이스를 제외하지 않았기 때문입니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;kite2390.png&quot; alt=&quot;undirected graph formed by joining two triangles with a common edge, one endpoint being labeled v and having one more edge sprout out of v.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;🪁를 세기 위해, 각 간선 $pq$에 대해 $pq$를 포함하는 삼각형의 개수를 셉니다. 그 후 각 간선 $pq$에 대해 $pq$가 사각형의 대각선인 🪁의 개수를 세줍니다. 삼각형의 개수를 $k$라고 할 때 $\binom{k}{2} (deg(p)-3) (deg(q)-3)$이 답입니다.&lt;&#x2F;p&gt;
&lt;p&gt;참고로 이 ⎐ 문양의 정체는 &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Open_collector&quot;&gt;NPN open collector&lt;&#x2F;a&gt;로, 전기회로에서 사용하는 문양입니다.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;boj-28200-4&quot;&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;28200&quot;&gt;BOJ 28200 4&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;모든 삼각형을 찾습니다. 각 정점 $v$에 대해, $v$를 포함하는 삼각형 $vpq$에 대해 간선 $pq$의 목록을 저장해 둡니다.&lt;&#x2F;p&gt;
&lt;p&gt;한 점 $v$를 고정하고, $v$에 대한 간선 $pq$로 이루어진 부분그래프를 생각해 봅시다. 이 부분그래프에서 삼각형의 개수를 세면 되는데, 대부분의 정점에 대해서는 부분그래프가 작을 것이기 때문에 비트셋으로 풀 수 있습니다. 자세한 내용은 &lt;a href=&quot;https:&#x2F;&#x2F;qoj.ac&#x2F;download.php?type=attachments&amp;amp;id=1212&amp;amp;r=2&quot;&gt;에디토리얼&lt;&#x2F;a&gt;을 참조하세요.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;camjo&quot;&gt;참조&lt;&#x2F;h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2303.06090&quot;&gt;Paul Burkhardt, David G. Harris, Simple and efficient four-cycle counting on sparse graphs&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
      </item>
      <item>
          <title>도형의 합집합과 넓이</title>
          <pubDate>Sun, 18 Sep 2022 00:00:00 +0000</pubDate>
          <author>jh05013</author>
          <link>https://jh05013.github.io/blog/shape-union/</link>
          <guid>https://jh05013.github.io/blog/shape-union/</guid>
          <description xml:base="https://jh05013.github.io/blog/shape-union/">&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;upload.wikimedia.org&#x2F;wikipedia&#x2F;commons&#x2F;thumb&#x2F;7&#x2F;7a&#x2F;Boolean_operations_on_shapes-en.svg&#x2F;330px-Boolean_operations_on_shapes-en.svg.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;도형의 불리언 연산&lt;&#x2F;strong&gt;이란, 여러 도형의 영역에 대한 집합 연산을 말합니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;7869&quot;&gt;두 원의 교집합의 넓이&lt;&#x2F;a&gt;를 구하는 방법은 잘 알려져 있습니다.
부채꼴 2개의 넓이를 합친 다음, 이등변삼각형 2개의 넓이를 빼는 방식으로 구할 수 있습니다.
같은 방법으로 두 원의 합집합의 넓이도 구할 수 있습니다.
하지만 원이 3개만 되어도 이런 “포함 배제” 접근을 하기 어렵습니다.&lt;&#x2F;p&gt;
&lt;p&gt;이 글에서는 도형의 합집합 및 그 넓이를 구하는 일반적인 방법을 소개합니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;teduri-ddagi&quot;&gt;테두리 따기&lt;&#x2F;h1&gt;
&lt;p&gt;아래 그림에서 테두리가 갖고 있는 중요한 성질을 찾아봅시다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;circle_union.png&quot; alt=&quot;A few circles, whose union of interior is colored.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;테두리는 도형의 둘레로 이루어져 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;그런데 이뿐만이 아닙니다. 도형의 둘레 중 &lt;strong&gt;다른 도형의 내부에 포함되지 않는 부분&lt;&#x2F;strong&gt;만이 테두리가 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;도형의 합집합의 테두리를 구하는 방법은 다음과 같습니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;도형 사이의 모든 교점을 구합니다.&lt;&#x2F;li&gt;
&lt;li&gt;각 도형마다 둘레를 다른 도형들과의 교점으로 분할합니다. 분할한 각 부분을 “조각“이라고 부릅시다.
&lt;ul&gt;
&lt;li&gt;위 그림에서 예를 들어보면, 맨 아래의 원은 네 조각으로 분할되어 있습니다.&lt;&#x2F;li&gt;
&lt;li&gt;원의 경우, 교점들을 각도 순으로 정렬하면 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;다각형의 경우, 우선 꼭짓점으로 분할하고, 각 변마다 그 위의 교점들을 정렬하면 됩니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;각 조각마다, 원래 자신이 속했던 도형을 제외하고 나머지 중 적어도 하나의 내부에 포함되는지 판별합니다.
포함되지 않는다면 그 조각은 테두리의 일부가 됩니다.
&lt;ul&gt;
&lt;li&gt;꼭 조각 전체를 생각할 필요는 없고, 조각 위의 한 점을 잡아서 점이 도형 내부에 속하는지 판별해도 됩니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;모든 도형이 원일 경우, 교점은 $O(n^2)$개이므로 조각도 $O(n^2)$개이고,
각 조각이 테두리를 이루는지 $O(n)$에 판별할 수 있으므로 전체 시간 복잡도는 $O(n^3)$입니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;javaeseoyi-sayong&quot;&gt;Java에서의 사용&lt;&#x2F;h2&gt;
&lt;p&gt;Java에는 이 기능이 내장되어 있습니다. 합집합만이 아니라 교집합, 차집합, 대칭차집합 등을 지원합니다.&lt;&#x2F;p&gt;
&lt;p&gt;도형은 &lt;code&gt;java.awt.geom&lt;&#x2F;code&gt;에 있는 클래스 &lt;code&gt;Path2D&lt;&#x2F;code&gt;, &lt;code&gt;Ellipse2D&lt;&#x2F;code&gt; 등으로 만들고 &lt;code&gt;Area&lt;&#x2F;code&gt;로 관리합니다. 만든 &lt;code&gt;Area&lt;&#x2F;code&gt;의 테두리를 &lt;code&gt;PathIterator&lt;&#x2F;code&gt;로 따올 수도 있습니다.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;java&quot; class=&quot;language-java z-code&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-support z-class z-java&quot;&gt;Area&lt;&#x2F;span&gt; &lt;span class=&quot;z-support z-class z-java&quot;&gt;A&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-assignment z-rhs z-java&quot;&gt;&lt;span class=&quot;z-keyword z-operator z-assignment z-java&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-instantiation z-java&quot;&gt;&lt;span class=&quot;z-keyword z-other z-storage z-new z-java&quot;&gt;new&lt;&#x2F;span&gt; &lt;span class=&quot;z-support z-class z-java&quot;&gt;Area&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-parens z-constructor-arguments z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-java&quot;&gt;;&lt;&#x2F;span&gt;  &lt;span class=&quot;z-comment z-line z-double-slash z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-java&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; 빈 Area를 만듦
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-support z-class z-java&quot;&gt;Path2D&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-support z-class z-java&quot;&gt;Double&lt;&#x2F;span&gt; p &lt;span class=&quot;z-meta z-assignment z-rhs z-java&quot;&gt;&lt;span class=&quot;z-keyword z-operator z-assignment z-java&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-instantiation z-java&quot;&gt;&lt;span class=&quot;z-keyword z-other z-storage z-new z-java&quot;&gt;new&lt;&#x2F;span&gt; &lt;span class=&quot;z-support z-class z-java&quot;&gt;Path2D&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-support z-class z-java&quot;&gt;Double&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-parens z-constructor-arguments z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-java&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;p&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-java&quot;&gt;&lt;span class=&quot;z-variable z-function z-java&quot;&gt;moveTo&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;a&lt;span class=&quot;z-punctuation z-separator z-comma z-java&quot;&gt;,&lt;&#x2F;span&gt; b&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-java&quot;&gt;;&lt;&#x2F;span&gt; &lt;span class=&quot;z-comment z-line z-double-slash z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-java&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; 커서를 이동
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;p&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-java&quot;&gt;&lt;span class=&quot;z-variable z-function z-java&quot;&gt;lineTo&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;a&lt;span class=&quot;z-punctuation z-separator z-comma z-java&quot;&gt;,&lt;&#x2F;span&gt; b&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-java&quot;&gt;;&lt;&#x2F;span&gt; &lt;span class=&quot;z-comment z-line z-double-slash z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-java&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; 커서를 이동시키면서 선분을 그림
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;p&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-java&quot;&gt;&lt;span class=&quot;z-variable z-function z-java&quot;&gt;closePath&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-java&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-support z-class z-java&quot;&gt;Area&lt;&#x2F;span&gt; &lt;span class=&quot;z-constant z-other z-java&quot;&gt;A2&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-assignment z-rhs z-java&quot;&gt;&lt;span class=&quot;z-keyword z-operator z-assignment z-java&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-instantiation z-java&quot;&gt;&lt;span class=&quot;z-keyword z-other z-storage z-new z-java&quot;&gt;new&lt;&#x2F;span&gt; &lt;span class=&quot;z-support z-class z-java&quot;&gt;Area&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-parens z-constructor-arguments z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;p&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-java&quot;&gt;;&lt;&#x2F;span&gt; &lt;span class=&quot;z-comment z-line z-double-slash z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-java&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; Path2D로부터 Area를 만듦
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-support z-class z-java&quot;&gt;A&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-java&quot;&gt;&lt;span class=&quot;z-variable z-function z-java&quot;&gt;add&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-constant z-other z-java&quot;&gt;A2&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-java&quot;&gt;;&lt;&#x2F;span&gt; &lt;span class=&quot;z-comment z-line z-double-slash z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-java&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; A에 A2를 합집합
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-support z-class z-java&quot;&gt;PathIterator&lt;&#x2F;span&gt; it &lt;span class=&quot;z-meta z-assignment z-rhs z-java&quot;&gt;&lt;span class=&quot;z-keyword z-operator z-assignment z-java&quot;&gt;=&lt;&#x2F;span&gt; area&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-java&quot;&gt;&lt;span class=&quot;z-variable z-function z-java&quot;&gt;getPathIterator&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-constant z-language z-java&quot;&gt;null&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-java&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-keyword z-control z-loop z-while z-java&quot;&gt;while&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-parens z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-keyword z-operator z-logical z-java&quot;&gt;!&lt;&#x2F;span&gt;it&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-java&quot;&gt;&lt;span class=&quot;z-variable z-function z-java&quot;&gt;isDone&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-block z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-java&quot;&gt;{&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;  &lt;span class=&quot;z-keyword z-control z-conditional z-switch z-java&quot;&gt;switch&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-parens z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;it&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-java&quot;&gt;&lt;span class=&quot;z-variable z-function z-java&quot;&gt;currentSegment&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;tmp&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-block z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-java&quot;&gt;{&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;    &lt;span class=&quot;z-keyword z-control z-conditional z-case z-java&quot;&gt;case&lt;&#x2F;span&gt; &lt;span class=&quot;z-support z-class z-java&quot;&gt;PathIterator&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-constant z-other z-java&quot;&gt;SEG_MOVETO&lt;&#x2F;span&gt;&lt;span class=&quot;z-keyword z-operator z-ternary z-java&quot;&gt;:&lt;&#x2F;span&gt; &lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;    &lt;span class=&quot;z-keyword z-control z-conditional z-case z-java&quot;&gt;case&lt;&#x2F;span&gt; &lt;span class=&quot;z-support z-class z-java&quot;&gt;PathIterator&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-constant z-other z-java&quot;&gt;SEG_LINETO&lt;&#x2F;span&gt;&lt;span class=&quot;z-keyword z-operator z-ternary z-java&quot;&gt;:&lt;&#x2F;span&gt; &lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;    &lt;span class=&quot;z-keyword z-control z-conditional z-case z-java&quot;&gt;case&lt;&#x2F;span&gt; &lt;span class=&quot;z-support z-class z-java&quot;&gt;PathIterator&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-constant z-other z-java&quot;&gt;SEG_CLOSE&lt;&#x2F;span&gt;&lt;span class=&quot;z-keyword z-operator z-ternary z-java&quot;&gt;:&lt;&#x2F;span&gt; &lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;  &lt;span class=&quot;z-punctuation z-section z-block z-end z-java&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;  it&lt;span class=&quot;z-punctuation z-accessor z-dot z-java&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-java&quot;&gt;&lt;span class=&quot;z-variable z-function z-java&quot;&gt;next&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-begin z-java&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-parens z-end z-java&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-java&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-java&quot;&gt;&lt;span class=&quot;z-meta z-block z-java&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-java&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;자세한 내용은 &lt;a href=&quot;https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;7&#x2F;docs&#x2F;api&#x2F;java&#x2F;awt&#x2F;geom&#x2F;package-summary.html&quot;&gt;공식 문서&lt;&#x2F;a&gt;를 참조하세요.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;neolbi-guhagi&quot;&gt;넓이 구하기&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;strong&gt;그린 정리(Green theorem)&lt;&#x2F;strong&gt;&lt;sup class=&quot;footnote-reference&quot; id=&quot;fr-1-1&quot;&gt;&lt;a href=&quot;#fn-1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;는 닫힌 곡선에 대한 면적분을 선적분으로 바꿔주는 정리입니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$C$를 조각마다 매끄러운 단순 닫힌 곡선이라고 합시다.
&lt;ul&gt;
&lt;li&gt;“조각마다 매끄러운“은 무한 번 미분 가능한 곡선을 여러 개 이어붙인 형태를 의미합니다.&lt;&#x2F;li&gt;
&lt;li&gt;“단순“은 자기 자신과 교차하지 않음을 의미합니다.&lt;&#x2F;li&gt;
&lt;li&gt;“닫힌“은 출발했던 점으로 돌아옴을 의미합니다.&lt;&#x2F;li&gt;
&lt;li&gt;이러한 곡선의 예로 원이나 단순다각형이 있습니다.
단순다각형의 경우 선분이 무한 번 미분 가능한 곡선이고,
그 선분을 여러 개 이어붙인 형태이기 때문에 조각마다 매끄러운 곡선입니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;$D$를 그 곡선의 내부 영역이라고 합시다.&lt;&#x2F;li&gt;
&lt;li&gt;$L$과 $M$이 $(x, y)$에 대한 함수라고 합시다. 여기에도 조건이 더 붙지만 이 글에서는 필요하지 않습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;그러면 $C$를 반시계 방향으로 돌면서 선적분($\oint$)을 한다고 할 때 다음이 성립합니다.&lt;&#x2F;p&gt;
&lt;p&gt;$$
\oint_C(L\ dx+ M\ dy) =
\iint_D(\frac{\partial M}{\partial x} - \frac{\partial L}{\partial y}) \ dx \ dy
$$&lt;&#x2F;p&gt;
&lt;p&gt;이것으로 면적을 어떻게 구할 수 있을까요? 면적은 다음과 같습니다.&lt;&#x2F;p&gt;
&lt;p&gt;$$
\iint_D 1 \ dx \ dy
$$&lt;&#x2F;p&gt;
&lt;p&gt;따라서 $\frac{\partial M}{\partial x} - \frac{\partial L}{\partial y} = 1$이 되도록
$M$과 $L$을 잡아주면 됩니다.
대표적으로 $M = \frac{x}{2}$, $L = -\frac{y}{2}$를 사용하고, 이때 그린 정리는 이렇게 바뀝니다.&lt;&#x2F;p&gt;
&lt;p&gt;$$
\frac{1}{2} \oint_C(x\ dy - y\ dx) =
\iint_D 1 \ dx \ dy
$$&lt;&#x2F;p&gt;
&lt;p&gt;이제 우리가 원하는 곡선 $C$를 잡아준 다음 선적분을 열심히 계산하면 됩니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;weon-hana&quot;&gt;원 하나&lt;&#x2F;h2&gt;
&lt;p&gt;우선 중심이 $(x_c, y_c)$, 반지름이 $r$인 원 하나의 넓이를 구해봅시다.
그러려면 $C$를 $\theta$에 대한 매개변수 곡선으로 나타내면 됩니다.
즉 $x = x_c + r \cos \theta$, $y = y_c + r \sin \theta$, $0 \leq \theta &amp;lt; 2 \pi$입니다. 이제,&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;연쇄 법칙(chain rule)에 의해 $\oint (x\ dy - y\ dx) = \oint (x \frac{dy}{d\theta} d\theta - y \frac{dx}{d\theta} d\theta)$&lt;&#x2F;li&gt;
&lt;li&gt;$\frac{dy}{d\theta} = r \cos \theta$&lt;&#x2F;li&gt;
&lt;li&gt;$\oint x \frac{dy}{d\theta} d\theta = \oint (x_c + r \cos \theta)(r \cos \theta) d\theta = r \oint (x_c \cos \theta + r \cos^2 \theta) d\theta$&lt;&#x2F;li&gt;
&lt;li&gt;$-\oint y \frac{dx}{d\theta} d\theta = \oint (y_c + r \sin \theta)(r \sin \theta) d\theta = r \oint (y_c \sin \theta + r \sin^2 \theta) d\theta$&lt;&#x2F;li&gt;
&lt;li&gt;$\frac{1}{2} \oint (x \frac{dy}{d\theta} d\theta - y \frac{dx}{d\theta} d\theta) = \frac{r}{2} \oint (x_c \cos \theta + y_c \sin \theta + r) d\theta$&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;따라서 적분 결과는 $\frac{r}{2}(x_c \sin \theta - y_c \cos \theta + r\theta) + C$입니다.
실제로 $\theta$에 $0$과 $2\pi$를 넣어서 빼보면 원의 넓이인 $\pi r^2$만 남는 것을 확인할 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;한편, $a \leq \theta \leq b$에 해당하는 부채꼴 영역의 넓이를 구하려고
$\theta$에 $a$와 $b$를 넣어서 빼보면 이상한 값이 나오는데,
이는 부채꼴 영역이 호 하나만 있는 게 아니라 선분 두 개가 더 있기 때문입니다.
따라서 선분에 대해서도 선적분을 해줘야 합니다. 이에 대해서는 후술합니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;weon-du-gae&quot;&gt;원 두 개&lt;&#x2F;h2&gt;
&lt;p&gt;테두리가 호 두 개로 이루어져 있다고 해봅시다.
그러면 각각의 호를 매개변수 곡선으로 생각할 수 있습니다.
호의 매개변수 곡선은 위와 별반 다르지 않습니다.
방정식은 원과 같은데, $\theta$의 범위만 다릅니다.&lt;&#x2F;p&gt;
&lt;p&gt;이제 그린 정리를 여기에도 적용하려면 매개변수 곡선 두 개를 이어붙여
하나의 매개변수 곡선으로 만들어야 합니다.
그러려면 곡선의 방정식을 어떻게 바꿔야 할까요?&lt;&#x2F;p&gt;
&lt;p&gt;안 바꿔도 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;좀 더 단순화해서, 함수 $y = f_1(x)$ ($l_1 \leq x \leq r_1$), $y = f_2(x)$ ($l_2 \leq x \leq r_2$)
두 개를 이어붙여 만든 함수 ($l_1 \leq x \leq r_1 + r_2 - l_2$)를 적분한다고 해봅시다.
그러면 그 함수는&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$x \leq r_1$이면 $y = f_1(x)$&lt;&#x2F;li&gt;
&lt;li&gt;아니면 $y = f_2(x - r_1 + l_2)$&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;가 됩니다. 그런데
$\int_{r_1}^{r_1 + r_2 - l_2} f_2(x - r_1 + l_2) dx = \int_{l_2}^{r_2} f_2(x) dx$라서,
그냥 두 함수를 따로 적분하고 합하면 됩니다.
직관적으로, 함수를 $x$ 방향으로 평행이동한 것이라서 적분값이 달라질 리가 없습니다.&lt;&#x2F;p&gt;
&lt;p&gt;매개변수 곡선도 마찬가지입니다.
곡선들을 모아 하나의 큰 곡선으로 만들 필요 없이, 곡선 각각을 적분하고 합치면 됩니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;weon-yeoreo-gae&quot;&gt;원 여러 개&lt;&#x2F;h2&gt;
&lt;p&gt;원이 여러 개 있을 때로 절차를 확장하면 다음과 같습니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;원의 합집합의 테두리를 이루는 호를 모두 구합니다.&lt;&#x2F;li&gt;
&lt;li&gt;각 호에 대해 그린 정리를 적용해서 합칩니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;네, 이게 끝입니다. 매우 복잡한 디테일이 있을 것 같이 생겼지만 그렇지 않습니다.&lt;&#x2F;p&gt;
&lt;p&gt;첫째로 들 수 있는 의문점은 “테두리를 ‘순서대로’ 따라가면서 적분해야 하지 않나?“일텐데요,
그렇지 않습니다. 테두리의 모든 부분을 한 번씩 지나가기만 하면 됩니다.
즉, 적분을 할 호를 선택하는 순서는 중요하지 않습니다.&lt;&#x2F;p&gt;
&lt;p&gt;둘째로 “구멍이 있으면 이상해지지 않을까?“라는 의문이 들 수 있습니다.
다행히도 구멍이 얼마나 있든 넓이는 잘 계산됩니다.
왜냐하면 그 구멍은 시계방향으로 돌게 되어서, 자연스럽게 음의 넓이로 계산되기 때문입니다.
아래 그림에서 빨간색 테두리는 반시계방향으로 도는 부분, 파란색 테두리는 시계방향으로 도는 부분입니다.
원의 둘레를 반시계방향으로 돌 때 파란색 테두리에서 어떻게 되는지 확인해 보세요.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;circle_union.png&quot; alt=&quot;A few circles, whose union of interior is colored.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;seonbuni-pohamdoen-dohyeong&quot;&gt;선분이 포함된 도형&lt;&#x2F;h2&gt;
&lt;p&gt;다각형이나 부채꼴처럼 둘레에 선분이 포함될 경우,
꼭짓점을 기준으로 분할해서 선분 단위로 생각하면 편합니다.&lt;&#x2F;p&gt;
&lt;p&gt;선분은 매개변수 곡선 $x = x_c + v_x t$, $y = y_c + v_y t$, $0 \leq t \leq 1$로 표현할 수 있습니다.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;연쇄 법칙(chain rule)에 의해 $\oint (x\ dy - y\ dx) = \oint (x \frac{dy}{dt} dt - y \frac{dx}{dt} dt)$&lt;&#x2F;li&gt;
&lt;li&gt;$= \oint(v_y (x_c + v_x t)dt - v_x (y_c + v_y t)dt)$&lt;&#x2F;li&gt;
&lt;li&gt;$= \oint(v_y x_c - v_x y_c)dt$&lt;&#x2F;li&gt;
&lt;li&gt;$= (v_y x_c - v_x y_c)t + C$&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;$t$에 0과 1을 넣어서 빼면 그냥 $v_y x_c - v_x y_c$가 됩니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;munje-puli&quot;&gt;문제 풀이&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;boj-17804&quot;&gt;BOJ 17804&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;17804&quot;&gt;BOJ 17804 Knocked Ink&lt;&#x2F;a&gt;는 잉크가 원형으로 퍼질 때,
합집합의 넓이가 특정 값이 되는 순간을 구하는 문제입니다.&lt;&#x2F;p&gt;
&lt;p&gt;원의 합집합의 넓이는 시간에 따른 증가함수이기 때문에 이분탐색으로 답을 구할 수 있습니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ojuz-saegjongi&quot;&gt;ojuz 색종이&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;oj.uz&#x2F;problem&#x2F;view&#x2F;kriii3_T&quot;&gt;ojuz 색종이&lt;&#x2F;a&gt;는 색종이를 놓을 때마다
각 색종이가 보이는 영역의 넓이를 구하는 문제입니다.
서브태스크 1에서는 모든 색종이가 원이고, 2에서는 원 또는 삼각형입니다.&lt;&#x2F;p&gt;
&lt;p&gt;$A_{i,j}$를 첫 $i$개의 색종이를 놓았을 때 $j$번째 색종이가 보이는 영역의 넓이라고 합시다.
즉 우리가 구해야 하는 값은 모든 $A_{i,j}$입니다.
$i = j$일 때는 그냥 도형 하나의 넓이를 구해주면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;$S_{l,r}$을 $l$번째부터 $r$번째까지의 색종이를 놓았을 때 전체 영역의 넓이라고 합시다.
그러면 $i &amp;lt; j$일 때 $A_{i,j} = S_{j,i} - S_{j+1,i}$입니다.&lt;&#x2F;p&gt;
&lt;p&gt;모든 $A$ 값 대신에 모든 $S$ 값을 구해줍시다.
일단 색종이를 다 놓은 다음 모든 도형의 둘레를 조각으로 나눕니다.
그 다음 각 조각 및 모든 $l \leq r$에 대해,
그 조각이 $S_{l,r}$의 테두리를 이룰 경우 그 조각에 대한 적분값을 $S_{l, r}$에 더합니다.
도형 $k$로부터 나온 조각 하나가 $S_{l,r}$의 테두리를 이루려면&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;물론 $l \leq k \leq r$이어야 합니다.&lt;&#x2F;li&gt;
&lt;li&gt;도형 $k$를 놓는 순간 그 조각이 테두리에 있어야 합니다.
즉 도형 $l, \cdots, k-1$ 바깥에 그 조각이 있어야 합니다.&lt;&#x2F;li&gt;
&lt;li&gt;도형 $r$을 놓을 때까지 그 조각이 테두리에 남아있어야 합니다.
즉 도형 $k+1, \cdots, r$ 바깥에 그 조각이 있어야 합니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;$S_{l, r}$에 대한 표를 그려본다고 생각하면 각 조각이 영향을 미치는 $S$들은 직사각형을 이루기 때문에,
누적합으로 각 $S$를 계산할 수 있습니다.&lt;&#x2F;p&gt;
&lt;p&gt;주의할 점은 여러 조각이 완전히 일치할 수도 있다는 것입니다.
예를 들어 두 원이 완전히 일치하거나, 두 삼각형의 둘레가 선분으로 겹칠 수 있습니다.
이 경우 나중에 나타난 조각이 우위를 점하고 이전에 나타난 조각은 사라집니다.
그래서 각 조각이 $S_{l,r}$의 테두리를 이루는지 판별할 때 주의를 기울여야 합니다.&lt;&#x2F;p&gt;
&lt;p&gt;아쉽게도 서브태스크 1만 해도 구현량이 상당하기 때문에
&lt;a href=&quot;https:&#x2F;&#x2F;oj.uz&#x2F;submission&#x2F;565066&quot;&gt;서브태스크 1 코드&lt;&#x2F;a&gt;만 첨부합니다.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;boj-9598&quot;&gt;BOJ 9598&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;9598&quot;&gt;BOJ 9598 Cleaning the Hallway&lt;&#x2F;a&gt;는
도넛의 합집합의 넓이를 구하는 문제입니다.&lt;&#x2F;p&gt;
&lt;p&gt;도넛의 바깥쪽 원은 반시계방향으로 돌고, 안쪽 원은 시계방향으로 돌면 됩니다.
나머지는 원의 합집합과 동일합니다. 교점을 구하고 조각으로 나눈 다음 그린 정리를 써주되,
테두리를 구할 때는 조각이 &lt;strong&gt;도넛&lt;&#x2F;strong&gt;의 안에 속하는지 판별하면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;del&gt;참고로 전 안 풀었습니다.&lt;&#x2F;del&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gwanryeon-munje&quot;&gt;관련 문제&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;17804&quot;&gt;BOJ 17804 Knocked Ink&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;10900&quot;&gt;BOJ 10900 Lonely mdic&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;codeforces.com&#x2F;problemset&#x2F;problem&#x2F;107&#x2F;E&quot;&gt;CF 107E Darts&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;oj.uz&#x2F;problem&#x2F;view&#x2F;kriii3_T&quot;&gt;ojuz 색종이&lt;&#x2F;a&gt;의 서브태스크 1&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;9598&quot;&gt;BOJ 9598 Cleaning the Hallway&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;19368&quot;&gt;BOJ 19368 Circular Sectors&lt;&#x2F;a&gt; (왜 이런 문제를…)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;11392&quot;&gt;BOJ 11392 색종이&lt;&#x2F;a&gt;
(즉 위에 있는 ojuz 색종이의 서브태스크 2를 풀면 됩니다.)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;camgo-jaryo&quot;&gt;참고 자료&lt;&#x2F;h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;codeforces.com&#x2F;blog&#x2F;entry&#x2F;2111&quot;&gt;Area of union of circles (Codeforces)&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Boolean_operations_on_polygons&quot;&gt;Boolean operations on polygons (Wikipedia)&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;footer class=&quot;footnotes&quot;&gt;
&lt;ol class=&quot;footnotes-list&quot;&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;이 정리를 만든 수학자 &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;George_Green_(mathematician)&quot;&gt;George Green&lt;&#x2F;a&gt;을 따서 이름이 붙었습니다. &lt;a href=&quot;#fr-1-1&quot;&gt;↩&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;footer&gt;
</description>
      </item>
      <item>
          <title>Connection Profile DP</title>
          <pubDate>Wed, 21 Aug 2019 00:00:00 +0000</pubDate>
          <author>jh05013</author>
          <link>https://jh05013.github.io/blog/cpdp/</link>
          <guid>https://jh05013.github.io/blog/cpdp/</guid>
          <description xml:base="https://jh05013.github.io/blog/cpdp/">&lt;h1 id=&quot;connection-profile-dp&quot;&gt;Connection Profile DP&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;em&gt;이 글은 비트마스크 DP를 배경지식으로 합니다.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;격자에서 비트마스크 DP를 돌리는 문제가 있습니다.
예를 들어 &lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;1648&quot;&gt;BOJ 1648 (격자판 채우기)&lt;&#x2F;a&gt; 문제에서는
위에서 아래로, 왼쪽에서 오른쪽으로 훑으면서, 최근 M개의 칸의 상태를 비트마스크로 저장합니다.
각 칸의 상태는 그 칸에 도미노가 채워졌으면 1, 아니면 0입니다. 그림으로 나타내면 이렇게 되겠죠.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;cpdp1.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;connection-profile&quot;&gt;Connection Profile??&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.acmicpc.net&#x2F;problem&#x2F;1144&quot;&gt;이 문제를 풀어봅시다.&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;격자에서 연결 요소를 만들되 비용의 합을 최소화하는 문제입니다.
위에서 다룬 것처럼 비트마스크 DP를 하고 싶어집니다. 최근 M개의 칸의 상태를 비트마스크로 저장합니다.
각 칸의 상태는 그 칸이 연결 요소에 포함되어 있으면 1, 아니면 0입니다.&lt;&#x2F;p&gt;
&lt;p&gt;하지만 그러면 안 됩니다.
최근 M개의 칸이 사용되었는지 아닌지만 따져서는 연결 요소가 생겼는지 알 수 없기 때문입니다.
예를 들어, 아래 그림에서 최근 M개의 칸의 상태가 왼쪽과 같을 때,
가운데처럼 모든 칸이 연결되었는지, 오른쪽처럼 모든 칸이 연결되지 않았는지 알 방법이 없습니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;cpdp2.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;그렇다고 지금까지 본 모든 칸의 상태를 다 저장하면 당연히 안 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;그래서 우리는 &lt;strong&gt;어떤 칸들이 서로 연결되어 있는지를 저장할 겁니다.&lt;&#x2F;strong&gt;
연결 요소에 번호를 붙였다고 해봅시다. 단, 선택되지 않은 칸은 0으로 채워넣습니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;cpdp3.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;이제 최근 M개의 칸의 상태만 저장해 놓으면 됩니다!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;cpdp4.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;sangtae-jeoni&quot;&gt;상태 전이&lt;&#x2F;h2&gt;
&lt;p&gt;상태 전이를 분석해 봅시다.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;keiseu-1-hyeon-eul-seontaeghaji-anhneunda&quot;&gt;케이스 1: “현“을 선택하지 않는다.&lt;&#x2F;h3&gt;
&lt;p&gt;“현“을 선택하지 않으면, “현“의 위쪽 칸을 제외하여 최근 M-1개의 칸의 상태가 하나씩 밀리고,
최근 칸의 상태는 0이 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;단, 이 케이스를 따라가면 안 되는 경우가 하나 있습니다.
“현“의 위쪽 칸이 선택되었고, 최근 M-1개의 칸 중 누구와도 연결되어 있지 않을 때입니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;cpdp5.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;이때는 “현“을 선택하지 않는 순간,&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;만약에 최근 M-1개의 칸 중 선택된 칸이 존재한다면,
위쪽 칸은 나머지 칸들과 하나의 연결 요소를 이루는데 실패하게 됩니다.&lt;&#x2F;li&gt;
&lt;li&gt;만약에 최근 M-1개의 칸 중 선택된 칸이 없다면, 모든 칸이 하나의 연결 요소를 이루는 데에는 성공했으나,
“이미 하나의 연결 요소가 있었다“는 정보가 소실됩니다.
그래서 “현” 이후의 칸들을 선택해야 하는지 말아야 하는지를 결정할 수 없습니다.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;따라서 이 상황에서는 케이스 1을 건너뛰어야 합니다.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;keiseu-2-hyeon-eul-seontaeghanda&quot;&gt;케이스 2: “현“을 선택한다.&lt;&#x2F;h3&gt;
&lt;p&gt;이때는 “현“의 위쪽 칸과 왼쪽 칸의 상태에 따라 세 가지 경우가 생깁니다.&lt;&#x2F;p&gt;
&lt;p&gt;(1) 위쪽 칸과 왼쪽 칸이 선택되지 않았다면, “현“은 그 자체로 새로운 연결 요소를 이루게 됩니다.
따라서 최근 M개의 칸에서 사용하지 않은 연결 요소 번호를 새로 만들어 그 칸에 집어넣습니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;cpdp6.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;(2) 위쪽 칸과 왼쪽 칸 중 하나만 선택되었다면, 그 칸의 연결 요소의 번호를 “현“이 그대로 따라갑니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;cpdp7.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;(3) 위쪽 칸과 왼쪽 칸이 모두 선택되었다면, 두 칸의 연결 요소가 하나로 합쳐집니다.
두 칸의 연결 요소 번호를 각각 x와 y라고 할 때, 최근 M-1개의 칸 중 번호가 y인 것들의 번호가 x로 바뀝니다
(물론 x에서 y로 바꿀 수도 있습니다.)
그리고 “현“은 그 번호를 그대로 따라갑니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;cpdp8.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;puliyi-mamuri&quot;&gt;풀이의 마무리&lt;&#x2F;h2&gt;
&lt;p&gt;마지막으로, 선택된 칸들이 연결 요소를 이룰 때마다 정답을 갱신해 주면 됩니다.
선택된 칸들이 연결 요소를 이루는지 판별하려면 서로 다른 양수가 1개 이하인지 검사하면 됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;아쉽게도, N=M=9인 입력을 아무거나 넣어 보면 너무 느리다는 것을 알 수 있습니다.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;coejeoghwa&quot;&gt;최적화&lt;&#x2F;h1&gt;
&lt;p&gt;물론 연결된 칸끼리는 같은 번호를 가지니 DP 상태의 개수가 M^M개나 되지는 않겠지만,
제가 구현한 바로는 칸 하나를 볼 때마다 7만 개의 상태가 생겼습니다.&lt;&#x2F;p&gt;
&lt;p&gt;이를 최적화하려면 같은 상태들을 하나로 합쳐 줘야 합니다.
예를 들어 다음 두 상태는 같습니다. 연결 요소들에 번호만 다시 붙여 주면 같아지기 때문입니다.
상태 전이를 하면서 최근 M개의 칸의 상태를 “정규화“하는 과정이 필요합니다.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;cpdp9.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;간단한 방법으로 사전순으로 가장 앞선 상태로 정규화하는 방법이 있습니다.
위쪽 칸에서부터 하나씩 보면서, 상태가 0이면 그대로 0으로 둡니다.
양수이면서 이전에 만난 적 없는 번호면, 새로운 번호를 할당합니다.
이전에 만난 적 있는 번호면, 그 번호가 할당받았던 새로운 번호를 그대로 줍니다.
예를 들어 위 그림의 오른쪽 상태는 왼쪽 상태로 정규화됩니다.&lt;&#x2F;p&gt;
&lt;p&gt;위에 언급했듯이 인접한 칸은 같은 번호를 가지므로 정확한 시간 복잡도를 분석하기는 어렵지만,
적당한 상한은 잡아줄 수 있습니다.
정규화를 했기 때문에, 최근 M개의 칸의 상태로 가능한 조합의 개수는
M개의 칸을 몇 개의 집합으로 분할하는 방법의 수보다 작거나 같습니다.
그 수는 bell number라고 하고, 0번째 bell number부터 차례대로 나열한 수열이
&lt;a href=&quot;http:&#x2F;&#x2F;oeis.org&#x2F;A000110&quot;&gt;OEIS에 번호 A000110&lt;&#x2F;a&gt;으로 있습니다.
9번째 bell number는 21,147입니다.
적당한 상한만 잡은 건데도 위에서 보았던 7만 개보다 훨씬 적고,
실제로 돌려 보면 나타나는 상태의 개수는 2천 개밖에 되지 않습니다.&lt;&#x2F;p&gt;
&lt;p&gt;정규화 작업까지 해 주고 N=M=9인 입력을 넣어 보면 답이 순식간에 나오는 것을 확인할 수 있고,
저의 구현은 0.1초 안에 &lt;strong&gt;맞았습니다!!&lt;&#x2F;strong&gt; 를 받았습니다.&lt;&#x2F;p&gt;
</description>
      </item>
    </channel>
</rss>
